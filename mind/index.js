var _FN, _document$getElementB;
function _construct(e, t, r) {
    return (_construct = _isNativeReflectConstruct() ? Reflect.construct.bind() : function(e, t, r) {
        var i = [null];
        i.push.apply(i, t);
        var n = new (Function.bind.apply(e, i));
        return r && _setPrototypeOf(n, r.prototype),
        n
    }
    ).apply(null, arguments)
}
function ownKeys(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var i = Object.getOwnPropertySymbols(e);
        t && (i = i.filter((function(t) {
            return Object.getOwnPropertyDescriptor(e, t).enumerable
        }
        ))),
        r.push.apply(r, i)
    }
    return r
}
function _objectSpread(e) {
    for (var t = 1; t < arguments.length; t++) {
        var r = null != arguments[t] ? arguments[t] : {};
        t % 2 ? ownKeys(Object(r), !0).forEach((function(t) {
            _defineProperty(e, t, r[t])
        }
        )) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : ownKeys(Object(r)).forEach((function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
        }
        ))
    }
    return e
}
function _toConsumableArray(e) {
    return _arrayWithoutHoles(e) || _iterableToArray(e) || _unsupportedIterableToArray(e) || _nonIterableSpread()
}
function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
}
function _iterableToArray(e) {
    if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
        return Array.from(e)
}
function _arrayWithoutHoles(e) {
    if (Array.isArray(e))
        return _arrayLikeToArray(e)
}
function asyncGeneratorStep(e, t, r, i, n, a, o) {
    try {
        var s = e[a](o)
          , l = s.value
    } catch (u) {
        return void r(u)
    }
    s.done ? t(l) : Promise.resolve(l).then(i, n)
}
function _asyncToGenerator(e) {
    return function() {
        var t = this
          , r = arguments;
        return new Promise((function(i, n) {
            var a = e.apply(t, r);
            function o(e) {
                asyncGeneratorStep(a, i, n, o, s, "next", e)
            }
            function s(e) {
                asyncGeneratorStep(a, i, n, o, s, "throw", e)
            }
            o(void 0)
        }
        ))
    }
}
function _slicedToArray(e, t) {
    return _arrayWithHoles(e) || _iterableToArrayLimit(e, t) || _unsupportedIterableToArray(e, t) || _nonIterableRest()
}
function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
}
function _iterableToArrayLimit(e, t) {
    var r = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
    if (null != r) {
        var i, n, a = [], o = !0, s = !1;
        try {
            for (r = r.call(e); !(o = (i = r.next()).done) && (a.push(i.value),
            !t || a.length !== t); o = !0)
                ;
        } catch (l) {
            s = !0,
            n = l
        } finally {
            try {
                o || null == r.return || r.return()
            } finally {
                if (s)
                    throw n
            }
        }
        return a
    }
}
function _arrayWithHoles(e) {
    if (Array.isArray(e))
        return e
}
function _get() {
    return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e, t, r) {
        var i = _superPropBase(e, t);
        if (i) {
            var n = Object.getOwnPropertyDescriptor(i, t);
            return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value
        }
    }
    ,
    _get.apply(this, arguments)
}
function _superPropBase(e, t) {
    for (; !Object.prototype.hasOwnProperty.call(e, t) && null !== (e = _getPrototypeOf(e)); )
        ;
    return e
}
function _inherits(e, t) {
    if ("function" != typeof t && null !== t)
        throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, {
        constructor: {
            value: e,
            writable: !0,
            configurable: !0
        }
    }),
    Object.defineProperty(e, "prototype", {
        writable: !1
    }),
    t && _setPrototypeOf(e, t)
}
function _setPrototypeOf(e, t) {
    return (_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, t) {
        return e.__proto__ = t,
        e
    }
    )(e, t)
}
function _createSuper(e) {
    var t = _isNativeReflectConstruct();
    return function() {
        var r, i = _getPrototypeOf(e);
        if (t) {
            var n = _getPrototypeOf(this).constructor;
            r = Reflect.construct(i, arguments, n)
        } else
            r = i.apply(this, arguments);
        return _possibleConstructorReturn(this, r)
    }
}
function _possibleConstructorReturn(e, t) {
    if (t && ("object" === _typeof(t) || "function" == typeof t))
        return t;
    if (void 0 !== t)
        throw new TypeError("Derived constructors may only return object or undefined");
    return _assertThisInitialized(e)
}
function _assertThisInitialized(e) {
    if (void 0 === e)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e
}
function _isNativeReflectConstruct() {
    if ("undefined" == typeof Reflect || !Reflect.construct)
        return !1;
    if (Reflect.construct.sham)
        return !1;
    if ("function" == typeof Proxy)
        return !0;
    try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}
        ))),
        !0
    } catch (e) {
        return !1
    }
}
function _getPrototypeOf(e) {
    return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
        return e.__proto__ || Object.getPrototypeOf(e)
    }
    )(e)
}
function _defineProperty(e, t, r) {
    return t in e ? Object.defineProperty(e, t, {
        value: r,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = r,
    e
}
function _regeneratorRuntime() {
    _regeneratorRuntime = function() {
        return e
    }
    ;
    var e = {}
      , t = Object.prototype
      , r = t.hasOwnProperty
      , i = "function" == typeof Symbol ? Symbol : {}
      , n = i.iterator || "@@iterator"
      , a = i.asyncIterator || "@@asyncIterator"
      , o = i.toStringTag || "@@toStringTag";
    function s(e, t, r) {
        return Object.defineProperty(e, t, {
            value: r,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }),
        e[t]
    }
    try {
        s({}, "")
    } catch (C) {
        s = function(e, t, r) {
            return e[t] = r
        }
    }
    function l(e, t, r, i) {
        var n, a, o, s, l = t && t.prototype instanceof h ? t : h, d = Object.create(l.prototype), p = new w(i || []);
        return d._invoke = (n = e,
        a = r,
        o = p,
        s = "suspendedStart",
        function(e, t) {
            if ("executing" === s)
                throw new Error("Generator is already running");
            if ("completed" === s) {
                if ("throw" === e)
                    throw t;
                return {
                    value: void 0,
                    done: !0
                }
            }
            for (o.method = e,
            o.arg = t; ; ) {
                var r = o.delegate;
                if (r) {
                    var i = x(r, o);
                    if (i) {
                        if (i === c)
                            continue;
                        return i
                    }
                }
                if ("next" === o.method)
                    o.sent = o._sent = o.arg;
                else if ("throw" === o.method) {
                    if ("suspendedStart" === s)
                        throw s = "completed",
                        o.arg;
                    o.dispatchException(o.arg)
                } else
                    "return" === o.method && o.abrupt("return", o.arg);
                s = "executing";
                var l = u(n, a, o);
                if ("normal" === l.type) {
                    if (s = o.done ? "completed" : "suspendedYield",
                    l.arg === c)
                        continue;
                    return {
                        value: l.arg,
                        done: o.done
                    }
                }
                "throw" === l.type && (s = "completed",
                o.method = "throw",
                o.arg = l.arg)
            }
        }
        ),
        d
    }
    function u(e, t, r) {
        try {
            return {
                type: "normal",
                arg: e.call(t, r)
            }
        } catch (C) {
            return {
                type: "throw",
                arg: C
            }
        }
    }
    e.wrap = l;
    var c = {};
    function h() {}
    function d() {}
    function p() {}
    var f = {};
    s(f, n, (function() {
        return this
    }
    ));
    var m = Object.getPrototypeOf
      , v = m && m(m(M([])));
    v && v !== t && r.call(v, n) && (f = v);
    var g = p.prototype = h.prototype = Object.create(f);
    function _(e) {
        ["next", "throw", "return"].forEach((function(t) {
            s(e, t, (function(e) {
                return this._invoke(t, e)
            }
            ))
        }
        ))
    }
    function y(e, t) {
        function i(n, a, o, s) {
            var l = u(e[n], e, a);
            if ("throw" !== l.type) {
                var c = l.arg
                  , h = c.value;
                return h && "object" == _typeof(h) && r.call(h, "__await") ? t.resolve(h.__await).then((function(e) {
                    i("next", e, o, s)
                }
                ), (function(e) {
                    i("throw", e, o, s)
                }
                )) : t.resolve(h).then((function(e) {
                    c.value = e,
                    o(c)
                }
                ), (function(e) {
                    return i("throw", e, o, s)
                }
                ))
            }
            s(l.arg)
        }
        var n;
        this._invoke = function(e, r) {
            function a() {
                return new t((function(t, n) {
                    i(e, r, t, n)
                }
                ))
            }
            return n = n ? n.then(a, a) : a()
        }
    }
    function x(e, t) {
        var r = e.iterator[t.method];
        if (void 0 === r) {
            if (t.delegate = null,
            "throw" === t.method) {
                if (e.iterator.return && (t.method = "return",
                t.arg = void 0,
                x(e, t),
                "throw" === t.method))
                    return c;
                t.method = "throw",
                t.arg = new TypeError("The iterator does not provide a 'throw' method")
            }
            return c
        }
        var i = u(r, e.iterator, t.arg);
        if ("throw" === i.type)
            return t.method = "throw",
            t.arg = i.arg,
            t.delegate = null,
            c;
        var n = i.arg;
        return n ? n.done ? (t[e.resultName] = n.value,
        t.next = e.nextLoc,
        "return" !== t.method && (t.method = "next",
        t.arg = void 0),
        t.delegate = null,
        c) : n : (t.method = "throw",
        t.arg = new TypeError("iterator result is not an object"),
        t.delegate = null,
        c)
    }
    function b(e) {
        var t = {
            tryLoc: e[0]
        };
        1 in e && (t.catchLoc = e[1]),
        2 in e && (t.finallyLoc = e[2],
        t.afterLoc = e[3]),
        this.tryEntries.push(t)
    }
    function S(e) {
        var t = e.completion || {};
        t.type = "normal",
        delete t.arg,
        e.completion = t
    }
    function w(e) {
        this.tryEntries = [{
            tryLoc: "root"
        }],
        e.forEach(b, this),
        this.reset(!0)
    }
    function M(e) {
        if (e) {
            var t = e[n];
            if (t)
                return t.call(e);
            if ("function" == typeof e.next)
                return e;
            if (!isNaN(e.length)) {
                var i = -1
                  , a = function t() {
                    for (; ++i < e.length; )
                        if (r.call(e, i))
                            return t.value = e[i],
                            t.done = !1,
                            t;
                    return t.value = void 0,
                    t.done = !0,
                    t
                };
                return a.next = a
            }
        }
        return {
            next: T
        }
    }
    function T() {
        return {
            value: void 0,
            done: !0
        }
    }
    return d.prototype = p,
    s(g, "constructor", p),
    s(p, "constructor", d),
    d.displayName = s(p, o, "GeneratorFunction"),
    e.isGeneratorFunction = function(e) {
        var t = "function" == typeof e && e.constructor;
        return !!t && (t === d || "GeneratorFunction" === (t.displayName || t.name))
    }
    ,
    e.mark = function(e) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(e, p) : (e.__proto__ = p,
        s(e, o, "GeneratorFunction")),
        e.prototype = Object.create(g),
        e
    }
    ,
    e.awrap = function(e) {
        return {
            __await: e
        }
    }
    ,
    _(y.prototype),
    s(y.prototype, a, (function() {
        return this
    }
    )),
    e.AsyncIterator = y,
    e.async = function(t, r, i, n, a) {
        void 0 === a && (a = Promise);
        var o = new y(l(t, r, i, n),a);
        return e.isGeneratorFunction(r) ? o : o.next().then((function(e) {
            return e.done ? e.value : o.next()
        }
        ))
    }
    ,
    _(g),
    s(g, o, "Generator"),
    s(g, n, (function() {
        return this
    }
    )),
    s(g, "toString", (function() {
        return "[object Generator]"
    }
    )),
    e.keys = function(e) {
        var t = [];
        for (var r in e)
            t.push(r);
        return t.reverse(),
        function r() {
            for (; t.length; ) {
                var i = t.pop();
                if (i in e)
                    return r.value = i,
                    r.done = !1,
                    r
            }
            return r.done = !0,
            r
        }
    }
    ,
    e.values = M,
    w.prototype = {
        constructor: w,
        reset: function(e) {
            if (this.prev = 0,
            this.next = 0,
            this.sent = this._sent = void 0,
            this.done = !1,
            this.delegate = null,
            this.method = "next",
            this.arg = void 0,
            this.tryEntries.forEach(S),
            !e)
                for (var t in this)
                    "t" === t.charAt(0) && r.call(this, t) && !isNaN(+t.slice(1)) && (this[t] = void 0)
        },
        stop: function() {
            this.done = !0;
            var e = this.tryEntries[0].completion;
            if ("throw" === e.type)
                throw e.arg;
            return this.rval
        },
        dispatchException: function(e) {
            if (this.done)
                throw e;
            var t = this;
            function i(r, i) {
                return o.type = "throw",
                o.arg = e,
                t.next = r,
                i && (t.method = "next",
                t.arg = void 0),
                !!i
            }
            for (var n = this.tryEntries.length - 1; n >= 0; --n) {
                var a = this.tryEntries[n]
                  , o = a.completion;
                if ("root" === a.tryLoc)
                    return i("end");
                if (a.tryLoc <= this.prev) {
                    var s = r.call(a, "catchLoc")
                      , l = r.call(a, "finallyLoc");
                    if (s && l) {
                        if (this.prev < a.catchLoc)
                            return i(a.catchLoc, !0);
                        if (this.prev < a.finallyLoc)
                            return i(a.finallyLoc)
                    } else if (s) {
                        if (this.prev < a.catchLoc)
                            return i(a.catchLoc, !0)
                    } else {
                        if (!l)
                            throw new Error("try statement without catch or finally");
                        if (this.prev < a.finallyLoc)
                            return i(a.finallyLoc)
                    }
                }
            }
        },
        abrupt: function(e, t) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                var n = this.tryEntries[i];
                if (n.tryLoc <= this.prev && r.call(n, "finallyLoc") && this.prev < n.finallyLoc) {
                    var a = n;
                    break
                }
            }
            a && ("break" === e || "continue" === e) && a.tryLoc <= t && t <= a.finallyLoc && (a = null);
            var o = a ? a.completion : {};
            return o.type = e,
            o.arg = t,
            a ? (this.method = "next",
            this.next = a.finallyLoc,
            c) : this.complete(o)
        },
        complete: function(e, t) {
            if ("throw" === e.type)
                throw e.arg;
            return "break" === e.type || "continue" === e.type ? this.next = e.arg : "return" === e.type ? (this.rval = this.arg = e.arg,
            this.method = "return",
            this.next = "end") : "normal" === e.type && t && (this.next = t),
            c
        },
        finish: function(e) {
            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                var r = this.tryEntries[t];
                if (r.finallyLoc === e)
                    return this.complete(r.completion, r.afterLoc),
                    S(r),
                    c
            }
        },
        catch: function(e) {
            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                var r = this.tryEntries[t];
                if (r.tryLoc === e) {
                    var i = r.completion;
                    if ("throw" === i.type) {
                        var n = i.arg;
                        S(r)
                    }
                    return n
                }
            }
            throw new Error("illegal catch attempt")
        },
        delegateYield: function(e, t, r) {
            return this.delegate = {
                iterator: M(e),
                resultName: t,
                nextLoc: r
            },
            "next" === this.method && (this.arg = void 0),
            c
        }
    },
    e
}
function _classCallCheck(e, t) {
    if (!(e instanceof t))
        throw new TypeError("Cannot call a class as a function")
}
function _defineProperties(e, t) {
    for (var r = 0; r < t.length; r++) {
        var i = t[r];
        i.enumerable = i.enumerable || !1,
        i.configurable = !0,
        "value"in i && (i.writable = !0),
        Object.defineProperty(e, i.key, i)
    }
}
function _createClass(e, t, r) {
    return t && _defineProperties(e.prototype, t),
    r && _defineProperties(e, r),
    Object.defineProperty(e, "prototype", {
        writable: !1
    }),
    e
}
function _typeof(e) {
    return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    }
    : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }
    )(e)
}
function _createForOfIteratorHelper(e, t) {
    var r = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
    if (!r) {
        if (Array.isArray(e) || (r = _unsupportedIterableToArray(e)) || t && e && "number" == typeof e.length) {
            r && (e = r);
            var i = 0
              , n = function() {};
            return {
                s: n,
                n: function() {
                    return i >= e.length ? {
                        done: !0
                    } : {
                        done: !1,
                        value: e[i++]
                    }
                },
                e: function(e) {
                    throw e
                },
                f: n
            }
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
    }
    var a, o = !0, s = !1;
    return {
        s: function() {
            r = r.call(e)
        },
        n: function() {
            var e = r.next();
            return o = e.done,
            e
        },
        e: function(e) {
            s = !0,
            a = e
        },
        f: function() {
            try {
                o || null == r.return || r.return()
            } finally {
                if (s)
                    throw a
            }
        }
    }
}
function _unsupportedIterableToArray(e, t) {
    if (e) {
        if ("string" == typeof e)
            return _arrayLikeToArray(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        return "Object" === r && e.constructor && (r = e.constructor.name),
        "Map" === r || "Set" === r ? Array.from(e) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? _arrayLikeToArray(e, t) : void 0
    }
}
function _arrayLikeToArray(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var r = 0, i = new Array(t); r < t; r++)
        i[r] = e[r];
    return i
}
var p = function() {
    var e = document.createElement("link").relList;
    if (!(e && e.supports && e.supports("modulepreload"))) {
        var t, r = _createForOfIteratorHelper(document.querySelectorAll('link[rel="modulepreload"]'));
        try {
            for (r.s(); !(t = r.n()).done; )
                i(t.value)
        } catch (n) {
            r.e(n)
        } finally {
            r.f()
        }
        new MutationObserver((function(e) {
            var t, r = _createForOfIteratorHelper(e);
            try {
                for (r.s(); !(t = r.n()).done; ) {
                    var a = t.value;
                    if ("childList" === a.type) {
                        var o, s = _createForOfIteratorHelper(a.addedNodes);
                        try {
                            for (s.s(); !(o = s.n()).done; ) {
                                var l = o.value;
                                "LINK" === l.tagName && "modulepreload" === l.rel && i(l)
                            }
                        } catch (n) {
                            s.e(n)
                        } finally {
                            s.f()
                        }
                    }
                }
            } catch (n) {
                r.e(n)
            } finally {
                r.f()
            }
        }
        )).observe(document, {
            childList: !0,
            subtree: !0
        })
    }
    function i(e) {
        if (!e.ep) {
            e.ep = !0;
            var t = function(e) {
                var t = {};
                return e.integrity && (t.integrity = e.integrity),
                e.referrerpolicy && (t.referrerPolicy = e.referrerpolicy),
                "use-credentials" === e.crossorigin ? t.credentials = "include" : "anonymous" === e.crossorigin ? t.credentials = "omit" : t.credentials = "same-origin",
                t
            }(e);
            fetch(e.href, t)
        }
    }
};
p();
var index = function() {
    return '@font-face{font-family:itc-benguiat;src:url(https://use.typekit.net/af/2edd02/00000000000000007735bc54/30/l?primer=7fa3915bdafdf03041871920a205bef951d72bf64dd4c4460fb992e3ecc3a862&fvd=n7&v=3) format("woff2"),url(https://use.typekit.net/af/2edd02/00000000000000007735bc54/30/d?primer=7fa3915bdafdf03041871920a205bef951d72bf64dd4c4460fb992e3ecc3a862&fvd=n7&v=3) format("woff"),url(https://use.typekit.net/af/2edd02/00000000000000007735bc54/30/a?primer=7fa3915bdafdf03041871920a205bef951d72bf64dd4c4460fb992e3ecc3a862&fvd=n7&v=3) format("opentype");font-display:swap;font-style:normal;font-weight:700;font-stretch:normal}@font-face{font-family:itc-benguiat-condensed;src:url(https://use.typekit.net/af/c8b670/00000000000000007735bc70/30/l?primer=7fa3915bdafdf03041871920a205bef951d72bf64dd4c4460fb992e3ecc3a862&fvd=n4&v=3) format("woff2"),url(https://use.typekit.net/af/c8b670/00000000000000007735bc70/30/d?primer=7fa3915bdafdf03041871920a205bef951d72bf64dd4c4460fb992e3ecc3a862&fvd=n4&v=3) format("woff"),url(https://use.typekit.net/af/c8b670/00000000000000007735bc70/30/a?primer=7fa3915bdafdf03041871920a205bef951d72bf64dd4c4460fb992e3ecc3a862&fvd=n4&v=3) format("opentype");font-display:swap;font-style:normal;font-weight:400;font-stretch:normal}.tk-itc-benguiat{font-family:itc-benguiat,serif}.tk-itc-benguiat-condensed{font-family:itc-benguiat-condensed,sans-serif}:where(html){line-height:1.15}:where(h1){font-size:2em;-webkit-margin-after:.67em;margin-block-end:.67em;-webkit-margin-before:.67em;margin-block-start:.67em}:where(dl,ol,ul) :where(dl,ol,ul){-webkit-margin-after:0;margin-block-end:0;-webkit-margin-before:0;margin-block-start:0}:where(hr){box-sizing:content-box;color:inherit;height:0}:where(pre){font-family:monospace,monospace;font-size:1em}:where(abbr[title]){text-decoration:underline;-webkit-text-decoration:underline dotted;text-decoration:underline dotted}:where(b,strong){font-weight:bolder}:where(code,kbd,samp){font-family:monospace,monospace;font-size:1em}:where(small){font-size:80%}:where(table){border-color:currentColor;text-indent:0}:where(button,input,select){margin:0}:where(button){text-transform:none}:where(button,input:is([type="button" i],[type="reset" i],[type="submit" i])){-webkit-appearance:button}:where(progress){vertical-align:baseline}:where(select){text-transform:none}:where(textarea){margin:0}:where(input[type="search" i]){-webkit-appearance:textfield;outline-offset:-2px}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}:where(button,input:is([type="button" i],[type="color" i],[type="reset" i],[type="submit" i]))::-moz-focus-inner{border-style:none;padding:0}:where(button,input:is([type="button" i],[type="color" i],[type="reset" i],[type="submit" i]))::-moz-focusring{outline:1px dotted ButtonText}:where(:-moz-ui-invalid){box-shadow:none}:where(dialog){background-color:#fff;border:solid;color:#000;height:-moz-fit-content;height:-webkit-fit-content;height:fit-content;left:0;margin:auto;padding:1em;position:absolute;right:0;width:-moz-fit-content;width:-webkit-fit-content;width:fit-content}:where(dialog:not([open])){display:none}:where(summary){display:list-item}*,*:before,*:after{box-sizing:border-box}a{text-decoration:none}a,a:active,a:hover,a:visited{color:currentColor;outline:0}:root{--color-white: #efefef;--color-white-transparent: rgba(239, 239, 239, .15);--color-black: #000000;--color-black-transparent: rgba(0, 0, 0, .25);--color-red: #dc1a31;--color-red-transparent: rgba(220, 26, 49, .15);--color-dark-red: #5e040e;--color-dark-blue: #030a13}.template--no-select{-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;-webkit-touch-callout:none;-webkit-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent}.template--no-select:focus{outline:none}.template--no-scroll{-webkit-overflow-scrolling:touch;overflow:hidden;overscroll-behavior:none;-ms-overflow-style:none;scrollbar-width:none}.template--no-scroll::-webkit-scrollbar,.template--no-scroll::-webkit-scrollbar-track,.template--no-scroll::-webkit-scrollbar-thumb{-webkit-appearance:none;appearance:none;width:0;height:0;background:transparent;display:none}.template--hide-scrollbar{-ms-overflow-style:none;scrollbar-width:none}.template--hide-scrollbar::-webkit-scrollbar,.template--hide-scrollbar::-webkit-scrollbar-track,.template--hide-scrollbar::-webkit-scrollbar-thumb{-webkit-appearance:none;appearance:none;width:0;height:0;background:transparent;display:none}.template--fixed-full-screen{position:fixed;top:0;left:0;right:0;bottom:0;margin:0;padding:0;border:0;overflow:hidden;overscroll-behavior:none;touch-action:none}.template--is-active{display:none}.template--is-active.is-active{display:block}.template--button{pointer-events:auto;cursor:pointer;height:2.8rem;width:2.8rem;border-radius:50%;background-color:transparent;border:2px solid var(--color-red)}.template--button .btn-icon{height:100%;width:100%;display:flex;align-items:center;justify-content:center}.template--outline:before{content:"";position:absolute;top:-.8rem;left:-.8rem;right:-.8rem;bottom:-.8rem;border:.8rem solid var(--color-red-transparent);border-radius:50%}.font-title{font-family:itc-benguiat,serif;font-weight:700;font-size:2.8rem}.font-subtitle{font-family:itc-benguiat-condensed,-apple-system,BlinkMacSystemFont,Inter var,Inter,Segoe UI,Helvetica Neue,Helvetica,Arial,Roboto,Ubuntu,sans-serif;font-weight:400;font-size:2rem}.font-body{font-family:itc-benguiat-condensed,-apple-system,BlinkMacSystemFont,Inter var,Inter,Segoe UI,Helvetica Neue,Helvetica,Arial,Roboto,Ubuntu,sans-serif;font-weight:400;font-size:1.6rem;line-height:1.25}.font-mono{font-family:Roboto Mono,SFMono-Regular,Jetbrains Mono,Menlo,Monaco,Consolas,Liberation Mono,Courier New,Lucida Console,monospace;font-weight:500;font-size:1rem}html{font-size:10px}html,body,button{font-family:Roboto Mono,SFMono-Regular,Jetbrains Mono,Menlo,Monaco,Consolas,Liberation Mono,Courier New,Lucida Console,monospace;font-weight:400;font-style:normal}body{font-size:1.3rem;font-family:itc-benguiat-condensed,-apple-system,BlinkMacSystemFont,Inter var,Inter,Segoe UI,Helvetica Neue,Helvetica,Arial,Roboto,Ubuntu,sans-serif;font-weight:400;font-size:1.6rem;line-height:1.25}.dg.ac input,.dg.ac select,.dg.ac .property-name,.dg.ac .close-button{font-family:Roboto Mono,SFMono-Regular,Jetbrains Mono,Menlo,Monaco,Consolas,Liberation Mono,Courier New,Lucida Console,monospace}.dg .dg.main{margin-right:0;margin-left:10px}.dg.main .property-name{padding-right:5px}.dg.main li.title{background-image:none;position:relative}.dg.main li.title:before{position:absolute;content:"-";left:5px}.dg.main .closed li.title{background-image:none}.dg.main .closed li.title:before{content:"+"}.dg.main .c .slider{position:relative;background:transparent}.dg.main .c .slider:hover{background:transparent}.dg.main .c .slider:hover .slider-fg{background:#0ff}.dg.main .c .slider:before{position:absolute;content:"";display:block;top:25%;height:50%;width:100%;background-color:#111}.dg.main .c .slider-fg{background:#0cc;position:absolute;top:25%;height:50%}.dg.main .cr.number{border-left:3px solid #0ff}.dg.main .cr.number input[type=text]{color:#0ff}html,body{-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;-webkit-touch-callout:none;-webkit-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;position:fixed;top:0;left:0;right:0;bottom:0;margin:0;padding:0;border:0;overflow:hidden;overscroll-behavior:none;touch-action:none;background-color:var(--color-dark-blue);color:var(--color-white)}html:focus,body:focus{outline:none}html.no-js body{display:none}#canvas,#ui{position:fixed;top:0;left:0;right:0;bottom:0;margin:0;padding:0;border:0;overflow:hidden;overscroll-behavior:none;touch-action:none;background-color:transparent}#canvas{pointer-events:auto;display:none}.is-ready #canvas{display:block}#ui{pointer-events:none}.overlay-loading{position:fixed;top:0;left:0;right:0;bottom:0;margin:0;padding:0;border:0;overflow:hidden;overscroll-behavior:none;touch-action:none;display:none;pointer-events:none}.overlay-loading.is-active{display:block}.overlay-loading .overlay-content{position:absolute;top:50%;left:50%;transform:translate3d(-50%,-50%,0);text-align:center;display:flex;flex-direction:column;justify-content:center;align-items:center}.overlay-loading .overlay-background{position:fixed;top:0;left:0;right:0;bottom:0;margin:0;padding:0;border:0;overflow:hidden;overscroll-behavior:none;touch-action:none;background-color:var(--color-dark-blue)}.loading-logo{margin-bottom:6rem}.loading-logo path{filter:drop-shadow(0px 0px 1.5rem var(--color-red))}@media (max-width: 1000px){.loading-logo{transform:scale3d(.75,.75,.75);margin-bottom:3rem}}@media (max-width: 560px){.loading-logo{transform:scale3d(.5,.5,.5);margin-bottom:0}}.loading-logo.cfx{pointer-events:none}.loading-bar{position:relative;width:30rem;height:13px;box-sizing:border-box;border:1px solid var(--color-red)}@media (max-width: 560px){.loading-bar{width:25rem}}.loading-bar:before,.loading-bar:after{position:absolute;width:3px;height:3px;background-color:var(--color-red);content:"";top:5px;margin-top:-1px}.loading-bar:before{left:4px}.loading-bar:after{right:4px}.loading-bar--inner{position:absolute;top:50%;left:50%;transform:translate3d(-50%,-50%,0);width:calc(100% - 2rem);height:3px}.loading-bar--inner{background-color:var(--color-dark-red)}.loading-bar--progress{background-color:var(--color-red);position:absolute;left:0;top:0;width:100%;height:100%;transform:scaleX(0);transform-origin:0 0}.overlay-credits{position:fixed;top:0;left:0;right:0;bottom:0;margin:0;padding:0;border:0;overflow:hidden;overscroll-behavior:none;touch-action:none;display:none;background-color:var(--color-dark-blue);pointer-events:auto}.overlay-credits.is-active{display:block}.overlay-credits .overlay-content{height:100%;width:70rem;max-width:100%;margin:0 auto;padding:5rem 3rem 0;display:flex;flex-direction:column;justify-content:center;align-items:center}@media (max-height: 560px){.overlay-credits .overlay-content{padding:5rem 3rem 0}}.credits-title,.credits-section{width:100%}.credits-title{font-family:itc-benguiat,serif;font-weight:700;font-size:2.8rem;text-align:center;margin-bottom:5rem;position:relative}@media (max-height: 812px){.credits-title{display:none}}.credits-section{display:flex;align-items:flex-start;justify-content:flex-start;flex-direction:row}@media (max-width: 560px){.credits-section{flex-direction:column;align-items:center}}.credits-section:not(:last-child){margin-bottom:2rem}.credits-section .section-title,.credits-section .section-content{padding:0 1rem}.credits-section .section-title{font-family:itc-benguiat-condensed,-apple-system,BlinkMacSystemFont,Inter var,Inter,Segoe UI,Helvetica Neue,Helvetica,Arial,Roboto,Ubuntu,sans-serif;font-weight:400;font-size:2rem;flex:2;margin-bottom:1rem}.credits-section .section-content{font-family:itc-benguiat-condensed,-apple-system,BlinkMacSystemFont,Inter var,Inter,Segoe UI,Helvetica Neue,Helvetica,Arial,Roboto,Ubuntu,sans-serif;font-weight:400;font-size:1.6rem;line-height:1.25;flex:4}.credits-section .section-content a{color:var(--color-red)}@media (max-width: 560px){.credits-section .section-content{text-align:center}}.credits-section.section-role a{margin-left:.5rem}.credits-section.section-lusion .spacing{margin-top:1rem;text-align:center;display:inline-block;width:2rem}.btn-close{pointer-events:auto;cursor:pointer;height:2.8rem;width:2.8rem;border-radius:50%;background-color:transparent;border:2px solid var(--color-red);position:absolute;top:8rem;right:8rem;z-index:9}.btn-close .btn-icon{height:100%;width:100%;display:flex;align-items:center;justify-content:center}@media (max-width: 560px){.btn-close{top:6rem;right:4rem}}.btn-close:before{content:"";position:absolute;top:-.8rem;left:-.8rem;right:-.8rem;bottom:-.8rem;border:.8rem solid var(--color-red-transparent);border-radius:50%}.overlay-controls{position:fixed;top:0;left:0;right:0;bottom:0;margin:0;padding:0;border:0;overflow:hidden;overscroll-behavior:none;touch-action:none;display:none;pointer-events:none}.overlay-controls.is-active{display:block}.btn-dial,.btn-audio,.btn-credits{display:none;pointer-events:auto}.btn-dial.is-active,.btn-audio.is-active,.btn-credits.is-active{display:block}.btn-audio,.btn-credits{pointer-events:auto;cursor:pointer;height:2.8rem;width:2.8rem;border-radius:50%;background-color:transparent;border:2px solid var(--color-red);position:absolute;top:8rem}.btn-audio .btn-icon,.btn-credits .btn-icon{height:100%;width:100%;display:flex;align-items:center;justify-content:center}@media (max-width: 560px){.btn-audio,.btn-credits{top:6rem}}.btn-audio:before,.btn-credits:before{content:"";position:absolute;top:-.8rem;left:-.8rem;right:-.8rem;bottom:-.8rem;border:.8rem solid var(--color-red-transparent);border-radius:50%}.btn-audio{right:13rem}@media (max-width: 560px){.btn-audio{right:unset;left:4rem}}.btn-credits{right:8rem}@media (max-width: 560px){.btn-credits{right:4rem}}.btn-dial{position:absolute;height:12rem;width:12rem;bottom:8rem;left:8rem;background-color:var(--color-black-transparent);border-radius:50%}@media (max-width: 560px){.btn-dial{bottom:4rem;left:4rem}}.btn-dial-knob{border:2px solid var(--color-red)}.btn-dial-knob,.btn-dial-knob-background{position:absolute;height:4rem;width:4rem;left:50%;top:50%;margin-left:-2rem;margin-top:-2rem;background-color:var(--color-black);border-radius:50%}.btn-dial-knob-background{background-color:var(--color-red-transparent)}.btn-dial-knob-background:before{content:"";position:absolute;top:-.8rem;left:-.8rem;right:-.8rem;bottom:-.8rem;border:.8rem solid var(--color-red-transparent);border-radius:50%}.btn-arrow--top,.btn-arrow--bottom,.btn-arrow--left,.btn-arrow--right{width:0;height:0;border-style:solid;position:absolute;top:50%;left:50%}.btn-arrow--top{border-width:0 5px 10px 5px;border-color:transparent transparent var(--color-white) transparent;transform:translate3d(-50%,calc(-4.2rem - 50%),0)}.btn-arrow--bottom{border-width:10px 5px 0 5px;border-color:var(--color-white) transparent transparent transparent;transform:translate3d(-50%,calc(4.2rem - 50%),0)}.btn-arrow--left{border-width:5px 10px 5px 0;border-color:transparent var(--color-white) transparent transparent;transform:translate3d(calc(-4.2rem - 50%),-50%,0)}.btn-arrow--right{border-width:5px 0 5px 10px;border-color:transparent transparent transparent var(--color-white);transform:translate3d(calc(4.2rem - 50%),-50%,0)}.btn-keyboard{text-align:center;position:absolute;bottom:5rem;left:50%;transform:translate3d(-50%,0,0)}@media (max-width: 560px){.btn-keyboard{bottom:3rem}}.btn-keyboard .btn-keyboard-icon{margin-bottom:1rem}.btn-keyboard .btn-keyboard-text{font-family:Roboto Mono,SFMono-Regular,Jetbrains Mono,Menlo,Monaco,Consolas,Liberation Mono,Courier New,Lucida Console,monospace;font-weight:500;font-size:1rem}.cursor{z-index:9999}.cursor-inner{pointer-events:none;position:absolute;top:0;left:0;transform:translate3d(-50%,-50%,0);height:2rem;width:2rem;border-radius:2rem;border:1px solid var(--color-red);background-color:transparent;display:none}.cfx{pointer-events:auto}.logo{position:absolute;top:5rem;left:50%;transform:translate3d(-50%,0,0);opacity:0;text-align:center;pointer-events:auto}@media (max-width: 560px){.logo{top:3rem}}.logo path{filter:drop-shadow(0px 0px 1rem var(--color-red))}.logo .logo-text{margin-top:.5rem;color:var(--color-red);opacity:.6;transition:opacity .5s ease-in-out;text-transform:uppercase}.logo:hover .logo-text{opacity:1}.not-supported--content{display:none;position:absolute;top:50%;left:50%;transform:translate3d(-50%,-50%,0)}html #not-supported-container{position:fixed;top:0;left:0;right:0;bottom:0;margin:0;padding:0;border:0;overflow:hidden;overscroll-behavior:none;touch-action:none;display:none}html.not-supported #canvas,html.not-supported #ui{display:none}html.not-supported body,html.not-supported #not-supported-container{display:block;background-color:var(--color-dark-blue)}html.not-supported--device .not-supported--content#ns-device,html.not-supported--browser .not-supported--content#ns-browser,html.not-supported--webgl .not-supported--content#ns-webgl,html.not-supported--orientation .not-supported--content#ns-orientation{padding:10px;border:2px solid var(--color-red);display:block;z-index:99999}\n'
}()
  , runtime = {
    exports: {}
};
!function(e) {
    var t = function(e) {
        var t, r = Object.prototype, i = r.hasOwnProperty, n = "function" == typeof Symbol ? Symbol : {}, a = n.iterator || "@@iterator", o = n.asyncIterator || "@@asyncIterator", s = n.toStringTag || "@@toStringTag";
        function l(e, t, r) {
            return Object.defineProperty(e, t, {
                value: r,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }),
            e[t]
        }
        try {
            l({}, "")
        } catch (L) {
            l = function(e, t, r) {
                return e[t] = r
            }
        }
        function u(e, t, r, i) {
            var n = t && t.prototype instanceof v ? t : v
              , a = Object.create(n.prototype)
              , o = new P(i || []);
            return a._invoke = function(e, t, r) {
                var i = h;
                return function(n, a) {
                    if (i === p)
                        throw new Error("Generator is already running");
                    if (i === f) {
                        if ("throw" === n)
                            throw a;
                        return k()
                    }
                    for (r.method = n,
                    r.arg = a; ; ) {
                        var o = r.delegate;
                        if (o) {
                            var s = T(o, r);
                            if (s) {
                                if (s === m)
                                    continue;
                                return s
                            }
                        }
                        if ("next" === r.method)
                            r.sent = r._sent = r.arg;
                        else if ("throw" === r.method) {
                            if (i === h)
                                throw i = f,
                                r.arg;
                            r.dispatchException(r.arg)
                        } else
                            "return" === r.method && r.abrupt("return", r.arg);
                        i = p;
                        var l = c(e, t, r);
                        if ("normal" === l.type) {
                            if (i = r.done ? f : d,
                            l.arg === m)
                                continue;
                            return {
                                value: l.arg,
                                done: r.done
                            }
                        }
                        "throw" === l.type && (i = f,
                        r.method = "throw",
                        r.arg = l.arg)
                    }
                }
            }(e, r, o),
            a
        }
        function c(e, t, r) {
            try {
                return {
                    type: "normal",
                    arg: e.call(t, r)
                }
            } catch (L) {
                return {
                    type: "throw",
                    arg: L
                }
            }
        }
        e.wrap = u;
        var h = "suspendedStart"
          , d = "suspendedYield"
          , p = "executing"
          , f = "completed"
          , m = {};
        function v() {}
        function g() {}
        function _() {}
        var y = {};
        l(y, a, (function() {
            return this
        }
        ));
        var x = Object.getPrototypeOf
          , b = x && x(x(A([])));
        b && b !== r && i.call(b, a) && (y = b);
        var S = _.prototype = v.prototype = Object.create(y);
        function w(e) {
            ["next", "throw", "return"].forEach((function(t) {
                l(e, t, (function(e) {
                    return this._invoke(t, e)
                }
                ))
            }
            ))
        }
        function M(e, t) {
            function r(n, a, o, s) {
                var l = c(e[n], e, a);
                if ("throw" !== l.type) {
                    var u = l.arg
                      , h = u.value;
                    return h && "object" === _typeof(h) && i.call(h, "__await") ? t.resolve(h.__await).then((function(e) {
                        r("next", e, o, s)
                    }
                    ), (function(e) {
                        r("throw", e, o, s)
                    }
                    )) : t.resolve(h).then((function(e) {
                        u.value = e,
                        o(u)
                    }
                    ), (function(e) {
                        return r("throw", e, o, s)
                    }
                    ))
                }
                s(l.arg)
            }
            var n;
            this._invoke = function(e, i) {
                function a() {
                    return new t((function(t, n) {
                        r(e, i, t, n)
                    }
                    ))
                }
                return n = n ? n.then(a, a) : a()
            }
        }
        function T(e, r) {
            var i = e.iterator[r.method];
            if (i === t) {
                if (r.delegate = null,
                "throw" === r.method) {
                    if (e.iterator.return && (r.method = "return",
                    r.arg = t,
                    T(e, r),
                    "throw" === r.method))
                        return m;
                    r.method = "throw",
                    r.arg = new TypeError("The iterator does not provide a 'throw' method")
                }
                return m
            }
            var n = c(i, e.iterator, r.arg);
            if ("throw" === n.type)
                return r.method = "throw",
                r.arg = n.arg,
                r.delegate = null,
                m;
            var a = n.arg;
            return a ? a.done ? (r[e.resultName] = a.value,
            r.next = e.nextLoc,
            "return" !== r.method && (r.method = "next",
            r.arg = t),
            r.delegate = null,
            m) : a : (r.method = "throw",
            r.arg = new TypeError("iterator result is not an object"),
            r.delegate = null,
            m)
        }
        function C(e) {
            var t = {
                tryLoc: e[0]
            };
            1 in e && (t.catchLoc = e[1]),
            2 in e && (t.finallyLoc = e[2],
            t.afterLoc = e[3]),
            this.tryEntries.push(t)
        }
        function E(e) {
            var t = e.completion || {};
            t.type = "normal",
            delete t.arg,
            e.completion = t
        }
        function P(e) {
            this.tryEntries = [{
                tryLoc: "root"
            }],
            e.forEach(C, this),
            this.reset(!0)
        }
        function A(e) {
            if (e) {
                var r = e[a];
                if (r)
                    return r.call(e);
                if ("function" == typeof e.next)
                    return e;
                if (!isNaN(e.length)) {
                    var n = -1
                      , o = function r() {
                        for (; ++n < e.length; )
                            if (i.call(e, n))
                                return r.value = e[n],
                                r.done = !1,
                                r;
                        return r.value = t,
                        r.done = !0,
                        r
                    };
                    return o.next = o
                }
            }
            return {
                next: k
            }
        }
        function k() {
            return {
                value: t,
                done: !0
            }
        }
        return g.prototype = _,
        l(S, "constructor", _),
        l(_, "constructor", g),
        g.displayName = l(_, s, "GeneratorFunction"),
        e.isGeneratorFunction = function(e) {
            var t = "function" == typeof e && e.constructor;
            return !!t && (t === g || "GeneratorFunction" === (t.displayName || t.name))
        }
        ,
        e.mark = function(e) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(e, _) : (e.__proto__ = _,
            l(e, s, "GeneratorFunction")),
            e.prototype = Object.create(S),
            e
        }
        ,
        e.awrap = function(e) {
            return {
                __await: e
            }
        }
        ,
        w(M.prototype),
        l(M.prototype, o, (function() {
            return this
        }
        )),
        e.AsyncIterator = M,
        e.async = function(t, r, i, n, a) {
            void 0 === a && (a = Promise);
            var o = new M(u(t, r, i, n),a);
            return e.isGeneratorFunction(r) ? o : o.next().then((function(e) {
                return e.done ? e.value : o.next()
            }
            ))
        }
        ,
        w(S),
        l(S, s, "Generator"),
        l(S, a, (function() {
            return this
        }
        )),
        l(S, "toString", (function() {
            return "[object Generator]"
        }
        )),
        e.keys = function(e) {
            var t = [];
            for (var r in e)
                t.push(r);
            return t.reverse(),
            function r() {
                for (; t.length; ) {
                    var i = t.pop();
                    if (i in e)
                        return r.value = i,
                        r.done = !1,
                        r
                }
                return r.done = !0,
                r
            }
        }
        ,
        e.values = A,
        P.prototype = {
            constructor: P,
            reset: function(e) {
                if (this.prev = 0,
                this.next = 0,
                this.sent = this._sent = t,
                this.done = !1,
                this.delegate = null,
                this.method = "next",
                this.arg = t,
                this.tryEntries.forEach(E),
                !e)
                    for (var r in this)
                        "t" === r.charAt(0) && i.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t)
            },
            stop: function() {
                this.done = !0;
                var e = this.tryEntries[0].completion;
                if ("throw" === e.type)
                    throw e.arg;
                return this.rval
            },
            dispatchException: function(e) {
                if (this.done)
                    throw e;
                var r = this;
                function n(i, n) {
                    return s.type = "throw",
                    s.arg = e,
                    r.next = i,
                    n && (r.method = "next",
                    r.arg = t),
                    !!n
                }
                for (var a = this.tryEntries.length - 1; a >= 0; --a) {
                    var o = this.tryEntries[a]
                      , s = o.completion;
                    if ("root" === o.tryLoc)
                        return n("end");
                    if (o.tryLoc <= this.prev) {
                        var l = i.call(o, "catchLoc")
                          , u = i.call(o, "finallyLoc");
                        if (l && u) {
                            if (this.prev < o.catchLoc)
                                return n(o.catchLoc, !0);
                            if (this.prev < o.finallyLoc)
                                return n(o.finallyLoc)
                        } else if (l) {
                            if (this.prev < o.catchLoc)
                                return n(o.catchLoc, !0)
                        } else {
                            if (!u)
                                throw new Error("try statement without catch or finally");
                            if (this.prev < o.finallyLoc)
                                return n(o.finallyLoc)
                        }
                    }
                }
            },
            abrupt: function(e, t) {
                for (var r = this.tryEntries.length - 1; r >= 0; --r) {
                    var n = this.tryEntries[r];
                    if (n.tryLoc <= this.prev && i.call(n, "finallyLoc") && this.prev < n.finallyLoc) {
                        var a = n;
                        break
                    }
                }
                a && ("break" === e || "continue" === e) && a.tryLoc <= t && t <= a.finallyLoc && (a = null);
                var o = a ? a.completion : {};
                return o.type = e,
                o.arg = t,
                a ? (this.method = "next",
                this.next = a.finallyLoc,
                m) : this.complete(o)
            },
            complete: function(e, t) {
                if ("throw" === e.type)
                    throw e.arg;
                return "break" === e.type || "continue" === e.type ? this.next = e.arg : "return" === e.type ? (this.rval = this.arg = e.arg,
                this.method = "return",
                this.next = "end") : "normal" === e.type && t && (this.next = t),
                m
            },
            finish: function(e) {
                for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                    var r = this.tryEntries[t];
                    if (r.finallyLoc === e)
                        return this.complete(r.completion, r.afterLoc),
                        E(r),
                        m
                }
            },
            catch: function(e) {
                for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                    var r = this.tryEntries[t];
                    if (r.tryLoc === e) {
                        var i = r.completion;
                        if ("throw" === i.type) {
                            var n = i.arg;
                            E(r)
                        }
                        return n
                    }
                }
                throw new Error("illegal catch attempt")
            },
            delegateYield: function(e, r, i) {
                return this.delegate = {
                    iterator: A(e),
                    resultName: r,
                    nextLoc: i
                },
                "next" === this.method && (this.arg = t),
                m
            }
        },
        e
    }(runtime.exports);
    try {
        regeneratorRuntime = t
    } catch (r) {
        "object" === ("undefined" == typeof globalThis ? "undefined" : _typeof(globalThis)) ? globalThis.regeneratorRuntime = t : Function("r", "regeneratorRuntime = r")(t)
    }
}();
for (var REVISION = "139", MOUSE = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2,
    ROTATE: 0,
    DOLLY: 1,
    PAN: 2
}, TOUCH = {
    ROTATE: 0,
    PAN: 1,
    DOLLY_PAN: 2,
    DOLLY_ROTATE: 3
}, CullFaceNone = 0, CullFaceBack = 1, CullFaceFront = 2, PCFShadowMap = 1, PCFSoftShadowMap = 2, VSMShadowMap = 3, FrontSide = 0, BackSide = 1, DoubleSide = 2, FlatShading = 1, NoBlending = 0, NormalBlending = 1, AdditiveBlending = 2, SubtractiveBlending = 3, MultiplyBlending = 4, CustomBlending = 5, AddEquation = 100, SubtractEquation = 101, ReverseSubtractEquation = 102, MinEquation = 103, MaxEquation = 104, ZeroFactor = 200, OneFactor = 201, SrcColorFactor = 202, OneMinusSrcColorFactor = 203, SrcAlphaFactor = 204, OneMinusSrcAlphaFactor = 205, DstAlphaFactor = 206, OneMinusDstAlphaFactor = 207, DstColorFactor = 208, OneMinusDstColorFactor = 209, SrcAlphaSaturateFactor = 210, NeverDepth = 0, AlwaysDepth = 1, LessDepth = 2, LessEqualDepth = 3, EqualDepth = 4, GreaterEqualDepth = 5, GreaterDepth = 6, NotEqualDepth = 7, MultiplyOperation = 0, MixOperation = 1, AddOperation = 2, NoToneMapping = 0, LinearToneMapping = 1, ReinhardToneMapping = 2, CineonToneMapping = 3, ACESFilmicToneMapping = 4, CustomToneMapping = 5, UVMapping = 300, CubeReflectionMapping = 301, CubeRefractionMapping = 302, EquirectangularReflectionMapping = 303, EquirectangularRefractionMapping = 304, CubeUVReflectionMapping = 306, RepeatWrapping = 1e3, ClampToEdgeWrapping = 1001, MirroredRepeatWrapping = 1002, NearestFilter = 1003, NearestMipmapNearestFilter = 1004, NearestMipMapNearestFilter = 1004, NearestMipmapLinearFilter = 1005, NearestMipMapLinearFilter = 1005, LinearFilter = 1006, LinearMipmapNearestFilter = 1007, LinearMipMapNearestFilter = 1007, LinearMipmapLinearFilter = 1008, LinearMipMapLinearFilter = 1008, UnsignedByteType = 1009, ByteType = 1010, ShortType = 1011, UnsignedShortType = 1012, IntType = 1013, UnsignedIntType = 1014, FloatType = 1015, HalfFloatType = 1016, UnsignedShort4444Type = 1017, UnsignedShort5551Type = 1018, UnsignedInt248Type = 1020, AlphaFormat = 1021, RGBFormat = 1022, RGBAFormat = 1023, LuminanceFormat = 1024, LuminanceAlphaFormat = 1025, DepthFormat = 1026, DepthStencilFormat = 1027, RedFormat = 1028, RedIntegerFormat = 1029, RGFormat = 1030, RGIntegerFormat = 1031, RGBAIntegerFormat = 1033, RGB_S3TC_DXT1_Format = 33776, RGBA_S3TC_DXT1_Format = 33777, RGBA_S3TC_DXT3_Format = 33778, RGBA_S3TC_DXT5_Format = 33779, RGB_PVRTC_4BPPV1_Format = 35840, RGB_PVRTC_2BPPV1_Format = 35841, RGBA_PVRTC_4BPPV1_Format = 35842, RGBA_PVRTC_2BPPV1_Format = 35843, RGB_ETC1_Format = 36196, RGB_ETC2_Format = 37492, RGBA_ETC2_EAC_Format = 37496, RGBA_ASTC_4x4_Format = 37808, RGBA_ASTC_5x4_Format = 37809, RGBA_ASTC_5x5_Format = 37810, RGBA_ASTC_6x5_Format = 37811, RGBA_ASTC_6x6_Format = 37812, RGBA_ASTC_8x5_Format = 37813, RGBA_ASTC_8x6_Format = 37814, RGBA_ASTC_8x8_Format = 37815, RGBA_ASTC_10x5_Format = 37816, RGBA_ASTC_10x6_Format = 37817, RGBA_ASTC_10x8_Format = 37818, RGBA_ASTC_10x10_Format = 37819, RGBA_ASTC_12x10_Format = 37820, RGBA_ASTC_12x12_Format = 37821, RGBA_BPTC_Format = 36492, LoopOnce = 2200, LoopRepeat = 2201, LoopPingPong = 2202, InterpolateDiscrete = 2300, InterpolateLinear = 2301, InterpolateSmooth = 2302, ZeroCurvatureEnding = 2400, ZeroSlopeEnding = 2401, WrapAroundEnding = 2402, NormalAnimationBlendMode = 2500, AdditiveAnimationBlendMode = 2501, TrianglesDrawMode = 0, LinearEncoding = 3e3, sRGBEncoding = 3001, BasicDepthPacking = 3200, RGBADepthPacking = 3201, TangentSpaceNormalMap = 0, ObjectSpaceNormalMap = 1, SRGBColorSpace = "srgb", LinearSRGBColorSpace = "srgb-linear", KeepStencilOp = 7680, AlwaysStencilFunc = 519, StaticDrawUsage = 35044, DynamicDrawUsage = 35048, GLSL3 = "300 es", _SRGBAFormat = 1035, EventDispatcher = function() {
    function e() {
        _classCallCheck(this, e)
    }
    return _createClass(e, [{
        key: "addEventListener",
        value: function(e, t) {
            void 0 === this._listeners && (this._listeners = {});
            var r = this._listeners;
            void 0 === r[e] && (r[e] = []),
            -1 === r[e].indexOf(t) && r[e].push(t)
        }
    }, {
        key: "hasEventListener",
        value: function(e, t) {
            if (void 0 === this._listeners)
                return !1;
            var r = this._listeners;
            return void 0 !== r[e] && -1 !== r[e].indexOf(t)
        }
    }, {
        key: "removeEventListener",
        value: function(e, t) {
            if (void 0 !== this._listeners) {
                var r = this._listeners[e];
                if (void 0 !== r) {
                    var i = r.indexOf(t);
                    -1 !== i && r.splice(i, 1)
                }
            }
        }
    }, {
        key: "dispatchEvent",
        value: function(e) {
            if (void 0 !== this._listeners) {
                var t = this._listeners[e.type];
                if (void 0 !== t) {
                    e.target = this;
                    for (var r = t.slice(0), i = 0, n = r.length; i < n; i++)
                        r[i].call(this, e);
                    e.target = null
                }
            }
        }
    }]),
    e
}(), _lut = [], i = 0; i < 256; i++)
    _lut[i] = (i < 16 ? "0" : "") + i.toString(16);
var _seed = 1234567
  , DEG2RAD = Math.PI / 180
  , RAD2DEG = 180 / Math.PI;
function generateUUID() {
    var e = 4294967295 * Math.random() | 0
      , t = 4294967295 * Math.random() | 0
      , r = 4294967295 * Math.random() | 0
      , i = 4294967295 * Math.random() | 0;
    return (_lut[255 & e] + _lut[e >> 8 & 255] + _lut[e >> 16 & 255] + _lut[e >> 24 & 255] + "-" + _lut[255 & t] + _lut[t >> 8 & 255] + "-" + _lut[t >> 16 & 15 | 64] + _lut[t >> 24 & 255] + "-" + _lut[63 & r | 128] + _lut[r >> 8 & 255] + "-" + _lut[r >> 16 & 255] + _lut[r >> 24 & 255] + _lut[255 & i] + _lut[i >> 8 & 255] + _lut[i >> 16 & 255] + _lut[i >> 24 & 255]).toLowerCase()
}
function clamp(e, t, r) {
    return Math.max(t, Math.min(r, e))
}
function euclideanModulo(e, t) {
    return (e % t + t) % t
}
function mapLinear(e, t, r, i, n) {
    return i + (e - t) * (n - i) / (r - t)
}
function inverseLerp(e, t, r) {
    return e !== t ? (r - e) / (t - e) : 0
}
function lerp(e, t, r) {
    return (1 - r) * e + r * t
}
function damp(e, t, r, i) {
    return lerp(e, t, 1 - Math.exp(-r * i))
}
function pingpong(e) {
    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
    return t - Math.abs(euclideanModulo(e, 2 * t) - t)
}
function smoothstep(e, t, r) {
    return e <= t ? 0 : e >= r ? 1 : (e = (e - t) / (r - t)) * e * (3 - 2 * e)
}
function smootherstep(e, t, r) {
    return e <= t ? 0 : e >= r ? 1 : (e = (e - t) / (r - t)) * e * e * (e * (6 * e - 15) + 10)
}
function randInt(e, t) {
    return e + Math.floor(Math.random() * (t - e + 1))
}
function randFloat(e, t) {
    return e + Math.random() * (t - e)
}
function randFloatSpread(e) {
    return e * (.5 - Math.random())
}
function seededRandom(e) {
    void 0 !== e && (_seed = e);
    var t = _seed += 1831565813;
    return t = Math.imul(t ^ t >>> 15, 1 | t),
    (((t ^= t + Math.imul(t ^ t >>> 7, 61 | t)) ^ t >>> 14) >>> 0) / 4294967296
}
function degToRad(e) {
    return e * DEG2RAD
}
function radToDeg(e) {
    return e * RAD2DEG
}
function isPowerOfTwo(e) {
    return 0 == (e & e - 1) && 0 !== e
}
function ceilPowerOfTwo(e) {
    return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
}
function floorPowerOfTwo(e) {
    return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
}
function setQuaternionFromProperEuler(e, t, r, i, n) {
    var a = Math.cos
      , o = Math.sin
      , s = a(r / 2)
      , l = o(r / 2)
      , u = a((t + i) / 2)
      , c = o((t + i) / 2)
      , h = a((t - i) / 2)
      , d = o((t - i) / 2)
      , p = a((i - t) / 2)
      , f = o((i - t) / 2);
    switch (n) {
    case "XYX":
        e.set(s * c, l * h, l * d, s * u);
        break;
    case "YZY":
        e.set(l * d, s * c, l * h, s * u);
        break;
    case "ZXZ":
        e.set(l * h, l * d, s * c, s * u);
        break;
    case "XZX":
        e.set(s * c, l * f, l * p, s * u);
        break;
    case "YXY":
        e.set(l * p, s * c, l * f, s * u);
        break;
    case "ZYZ":
        e.set(l * f, l * p, s * c, s * u);
        break;
    default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + n)
    }
}
function denormalize$1(e, t) {
    switch (t.constructor) {
    case Float32Array:
        return e;
    case Uint16Array:
        return e / 65535;
    case Uint8Array:
        return e / 255;
    case Int16Array:
        return Math.max(e / 32767, -1);
    case Int8Array:
        return Math.max(e / 127, -1);
    default:
        throw new Error("Invalid component type.")
    }
}
function normalize(e, t) {
    switch (t.constructor) {
    case Float32Array:
        return e;
    case Uint16Array:
        return Math.round(65535 * e);
    case Uint8Array:
        return Math.round(255 * e);
    case Int16Array:
        return Math.round(32767 * e);
    case Int8Array:
        return Math.round(127 * e);
    default:
        throw new Error("Invalid component type.")
    }
}
var MathUtils$1 = Object.freeze({
    __proto__: null,
    DEG2RAD,
    RAD2DEG,
    generateUUID,
    clamp,
    euclideanModulo,
    mapLinear,
    inverseLerp,
    lerp,
    damp,
    pingpong,
    smoothstep,
    smootherstep,
    randInt,
    randFloat,
    randFloatSpread,
    seededRandom,
    degToRad,
    radToDeg,
    isPowerOfTwo,
    ceilPowerOfTwo,
    floorPowerOfTwo,
    setQuaternionFromProperEuler,
    normalize,
    denormalize: denormalize$1
})
  , Vector2 = function(e) {
    function t() {
        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
          , r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
        _classCallCheck(this, t),
        this.x = e,
        this.y = r
    }
    return _createClass(t, [{
        key: "width",
        get: function() {
            return this.x
        },
        set: function(e) {
            this.x = e
        }
    }, {
        key: "height",
        get: function() {
            return this.y
        },
        set: function(e) {
            this.y = e
        }
    }, {
        key: "set",
        value: function(e, t) {
            return this.x = e,
            this.y = t,
            this
        }
    }, {
        key: "setScalar",
        value: function(e) {
            return this.x = e,
            this.y = e,
            this
        }
    }, {
        key: "setX",
        value: function(e) {
            return this.x = e,
            this
        }
    }, {
        key: "setY",
        value: function(e) {
            return this.y = e,
            this
        }
    }, {
        key: "setComponent",
        value: function(e, t) {
            switch (e) {
            case 0:
                this.x = t;
                break;
            case 1:
                this.y = t;
                break;
            default:
                throw new Error("index is out of range: " + e)
            }
            return this
        }
    }, {
        key: "getComponent",
        value: function(e) {
            switch (e) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw new Error("index is out of range: " + e)
            }
        }
    }, {
        key: "clone",
        value: function() {
            return new this.constructor(this.x,this.y)
        }
    }, {
        key: "copy",
        value: function(e) {
            return this.x = e.x,
            this.y = e.y,
            this
        }
    }, {
        key: "add",
        value: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
            this.addVectors(e, t)) : (this.x += e.x,
            this.y += e.y,
            this)
        }
    }, {
        key: "addScalar",
        value: function(e) {
            return this.x += e,
            this.y += e,
            this
        }
    }, {
        key: "addVectors",
        value: function(e, t) {
            return this.x = e.x + t.x,
            this.y = e.y + t.y,
            this
        }
    }, {
        key: "addScaledVector",
        value: function(e, t) {
            return this.x += e.x * t,
            this.y += e.y * t,
            this
        }
    }, {
        key: "sub",
        value: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
            this.subVectors(e, t)) : (this.x -= e.x,
            this.y -= e.y,
            this)
        }
    }, {
        key: "subScalar",
        value: function(e) {
            return this.x -= e,
            this.y -= e,
            this
        }
    }, {
        key: "subVectors",
        value: function(e, t) {
            return this.x = e.x - t.x,
            this.y = e.y - t.y,
            this
        }
    }, {
        key: "multiply",
        value: function(e) {
            return this.x *= e.x,
            this.y *= e.y,
            this
        }
    }, {
        key: "multiplyScalar",
        value: function(e) {
            return this.x *= e,
            this.y *= e,
            this
        }
    }, {
        key: "divide",
        value: function(e) {
            return this.x /= e.x,
            this.y /= e.y,
            this
        }
    }, {
        key: "divideScalar",
        value: function(e) {
            return this.multiplyScalar(1 / e)
        }
    }, {
        key: "applyMatrix3",
        value: function(e) {
            var t = this.x
              , r = this.y
              , i = e.elements;
            return this.x = i[0] * t + i[3] * r + i[6],
            this.y = i[1] * t + i[4] * r + i[7],
            this
        }
    }, {
        key: "min",
        value: function(e) {
            return this.x = Math.min(this.x, e.x),
            this.y = Math.min(this.y, e.y),
            this
        }
    }, {
        key: "max",
        value: function(e) {
            return this.x = Math.max(this.x, e.x),
            this.y = Math.max(this.y, e.y),
            this
        }
    }, {
        key: "clamp",
        value: function(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)),
            this.y = Math.max(e.y, Math.min(t.y, this.y)),
            this
        }
    }, {
        key: "clampScalar",
        value: function(e, t) {
            return this.x = Math.max(e, Math.min(t, this.x)),
            this.y = Math.max(e, Math.min(t, this.y)),
            this
        }
    }, {
        key: "clampLength",
        value: function(e, t) {
            var r = this.length();
            return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)))
        }
    }, {
        key: "floor",
        value: function() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this
        }
    }, {
        key: "ceil",
        value: function() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this
        }
    }, {
        key: "round",
        value: function() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this
        }
    }, {
        key: "roundToZero",
        value: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this
        }
    }, {
        key: "negate",
        value: function() {
            return this.x = -this.x,
            this.y = -this.y,
            this
        }
    }, {
        key: "dot",
        value: function(e) {
            return this.x * e.x + this.y * e.y
        }
    }, {
        key: "cross",
        value: function(e) {
            return this.x * e.y - this.y * e.x
        }
    }, {
        key: "lengthSq",
        value: function() {
            return this.x * this.x + this.y * this.y
        }
    }, {
        key: "length",
        value: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        }
    }, {
        key: "manhattanLength",
        value: function() {
            return Math.abs(this.x) + Math.abs(this.y)
        }
    }, {
        key: "normalize",
        value: function() {
            return this.divideScalar(this.length() || 1)
        }
    }, {
        key: "angle",
        value: function() {
            return Math.atan2(-this.y, -this.x) + Math.PI
        }
    }, {
        key: "distanceTo",
        value: function(e) {
            return Math.sqrt(this.distanceToSquared(e))
        }
    }, {
        key: "distanceToSquared",
        value: function(e) {
            var t = this.x - e.x
              , r = this.y - e.y;
            return t * t + r * r
        }
    }, {
        key: "manhattanDistanceTo",
        value: function(e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
        }
    }, {
        key: "setLength",
        value: function(e) {
            return this.normalize().multiplyScalar(e)
        }
    }, {
        key: "lerp",
        value: function(e, t) {
            return this.x += (e.x - this.x) * t,
            this.y += (e.y - this.y) * t,
            this
        }
    }, {
        key: "lerpVectors",
        value: function(e, t, r) {
            return this.x = e.x + (t.x - e.x) * r,
            this.y = e.y + (t.y - e.y) * r,
            this
        }
    }, {
        key: "equals",
        value: function(e) {
            return e.x === this.x && e.y === this.y
        }
    }, {
        key: "fromArray",
        value: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
            return this.x = e[t],
            this.y = e[t + 1],
            this
        }
    }, {
        key: "toArray",
        value: function() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
              , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
            return e[t] = this.x,
            e[t + 1] = this.y,
            e
        }
    }, {
        key: "fromBufferAttribute",
        value: function(e, t, r) {
            return void 0 !== r && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),
            this.x = e.getX(t),
            this.y = e.getY(t),
            this
        }
    }, {
        key: "rotateAround",
        value: function(e, t) {
            var r = Math.cos(t)
              , i = Math.sin(t)
              , n = this.x - e.x
              , a = this.y - e.y;
            return this.x = n * r - a * i + e.x,
            this.y = n * i + a * r + e.y,
            this
        }
    }, {
        key: "random",
        value: function() {
            return this.x = Math.random(),
            this.y = Math.random(),
            this
        }
    }, {
        key: Symbol.iterator,
        value: _regeneratorRuntime().mark((function e() {
            return _regeneratorRuntime().wrap((function(e) {
                for (; ; )
                    switch (e.prev = e.next) {
                    case 0:
                        return e.next = 2,
                        this.x;
                    case 2:
                        return e.next = 4,
                        this.y;
                    case 4:
                    case "end":
                        return e.stop()
                    }
            }
            ), e, this)
        }
        ))
    }]),
    t
}();
Vector2.prototype.isVector2 = !0;
var Matrix3 = function() {
    function e() {
        _classCallCheck(this, e),
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
    }
    return _createClass(e, [{
        key: "set",
        value: function(e, t, r, i, n, a, o, s, l) {
            var u = this.elements;
            return u[0] = e,
            u[1] = i,
            u[2] = o,
            u[3] = t,
            u[4] = n,
            u[5] = s,
            u[6] = r,
            u[7] = a,
            u[8] = l,
            this
        }
    }, {
        key: "identity",
        value: function() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
            this
        }
    }, {
        key: "copy",
        value: function(e) {
            var t = this.elements
              , r = e.elements;
            return t[0] = r[0],
            t[1] = r[1],
            t[2] = r[2],
            t[3] = r[3],
            t[4] = r[4],
            t[5] = r[5],
            t[6] = r[6],
            t[7] = r[7],
            t[8] = r[8],
            this
        }
    }, {
        key: "extractBasis",
        value: function(e, t, r) {
            return e.setFromMatrix3Column(this, 0),
            t.setFromMatrix3Column(this, 1),
            r.setFromMatrix3Column(this, 2),
            this
        }
    }, {
        key: "setFromMatrix4",
        value: function(e) {
            var t = e.elements;
            return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
            this
        }
    }, {
        key: "multiply",
        value: function(e) {
            return this.multiplyMatrices(this, e)
        }
    }, {
        key: "premultiply",
        value: function(e) {
            return this.multiplyMatrices(e, this)
        }
    }, {
        key: "multiplyMatrices",
        value: function(e, t) {
            var r = e.elements
              , i = t.elements
              , n = this.elements
              , a = r[0]
              , o = r[3]
              , s = r[6]
              , l = r[1]
              , u = r[4]
              , c = r[7]
              , h = r[2]
              , d = r[5]
              , p = r[8]
              , f = i[0]
              , m = i[3]
              , v = i[6]
              , g = i[1]
              , _ = i[4]
              , y = i[7]
              , x = i[2]
              , b = i[5]
              , S = i[8];
            return n[0] = a * f + o * g + s * x,
            n[3] = a * m + o * _ + s * b,
            n[6] = a * v + o * y + s * S,
            n[1] = l * f + u * g + c * x,
            n[4] = l * m + u * _ + c * b,
            n[7] = l * v + u * y + c * S,
            n[2] = h * f + d * g + p * x,
            n[5] = h * m + d * _ + p * b,
            n[8] = h * v + d * y + p * S,
            this
        }
    }, {
        key: "multiplyScalar",
        value: function(e) {
            var t = this.elements;
            return t[0] *= e,
            t[3] *= e,
            t[6] *= e,
            t[1] *= e,
            t[4] *= e,
            t[7] *= e,
            t[2] *= e,
            t[5] *= e,
            t[8] *= e,
            this
        }
    }, {
        key: "determinant",
        value: function() {
            var e = this.elements
              , t = e[0]
              , r = e[1]
              , i = e[2]
              , n = e[3]
              , a = e[4]
              , o = e[5]
              , s = e[6]
              , l = e[7]
              , u = e[8];
            return t * a * u - t * o * l - r * n * u + r * o * s + i * n * l - i * a * s
        }
    }, {
        key: "invert",
        value: function() {
            var e = this.elements
              , t = e[0]
              , r = e[1]
              , i = e[2]
              , n = e[3]
              , a = e[4]
              , o = e[5]
              , s = e[6]
              , l = e[7]
              , u = e[8]
              , c = u * a - o * l
              , h = o * s - u * n
              , d = l * n - a * s
              , p = t * c + r * h + i * d;
            if (0 === p)
                return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
            var f = 1 / p;
            return e[0] = c * f,
            e[1] = (i * l - u * r) * f,
            e[2] = (o * r - i * a) * f,
            e[3] = h * f,
            e[4] = (u * t - i * s) * f,
            e[5] = (i * n - o * t) * f,
            e[6] = d * f,
            e[7] = (r * s - l * t) * f,
            e[8] = (a * t - r * n) * f,
            this
        }
    }, {
        key: "transpose",
        value: function() {
            var e, t = this.elements;
            return e = t[1],
            t[1] = t[3],
            t[3] = e,
            e = t[2],
            t[2] = t[6],
            t[6] = e,
            e = t[5],
            t[5] = t[7],
            t[7] = e,
            this
        }
    }, {
        key: "getNormalMatrix",
        value: function(e) {
            return this.setFromMatrix4(e).invert().transpose()
        }
    }, {
        key: "transposeIntoArray",
        value: function(e) {
            var t = this.elements;
            return e[0] = t[0],
            e[1] = t[3],
            e[2] = t[6],
            e[3] = t[1],
            e[4] = t[4],
            e[5] = t[7],
            e[6] = t[2],
            e[7] = t[5],
            e[8] = t[8],
            this
        }
    }, {
        key: "setUvTransform",
        value: function(e, t, r, i, n, a, o) {
            var s = Math.cos(n)
              , l = Math.sin(n);
            return this.set(r * s, r * l, -r * (s * a + l * o) + a + e, -i * l, i * s, -i * (-l * a + s * o) + o + t, 0, 0, 1),
            this
        }
    }, {
        key: "scale",
        value: function(e, t) {
            var r = this.elements;
            return r[0] *= e,
            r[3] *= e,
            r[6] *= e,
            r[1] *= t,
            r[4] *= t,
            r[7] *= t,
            this
        }
    }, {
        key: "rotate",
        value: function(e) {
            var t = Math.cos(e)
              , r = Math.sin(e)
              , i = this.elements
              , n = i[0]
              , a = i[3]
              , o = i[6]
              , s = i[1]
              , l = i[4]
              , u = i[7];
            return i[0] = t * n + r * s,
            i[3] = t * a + r * l,
            i[6] = t * o + r * u,
            i[1] = -r * n + t * s,
            i[4] = -r * a + t * l,
            i[7] = -r * o + t * u,
            this
        }
    }, {
        key: "translate",
        value: function(e, t) {
            var r = this.elements;
            return r[0] += e * r[2],
            r[3] += e * r[5],
            r[6] += e * r[8],
            r[1] += t * r[2],
            r[4] += t * r[5],
            r[7] += t * r[8],
            this
        }
    }, {
        key: "equals",
        value: function(e) {
            for (var t = this.elements, r = e.elements, i = 0; i < 9; i++)
                if (t[i] !== r[i])
                    return !1;
            return !0
        }
    }, {
        key: "fromArray",
        value: function(e) {
            for (var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, r = 0; r < 9; r++)
                this.elements[r] = e[r + t];
            return this
        }
    }, {
        key: "toArray",
        value: function() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
              , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
              , r = this.elements;
            return e[t] = r[0],
            e[t + 1] = r[1],
            e[t + 2] = r[2],
            e[t + 3] = r[3],
            e[t + 4] = r[4],
            e[t + 5] = r[5],
            e[t + 6] = r[6],
            e[t + 7] = r[7],
            e[t + 8] = r[8],
            e
        }
    }, {
        key: "clone",
        value: function() {
            return (new this.constructor).fromArray(this.elements)
        }
    }]),
    e
}();
function arrayNeedsUint32(e) {
    for (var t = e.length - 1; t >= 0; --t)
        if (e[t] > 65535)
            return !0;
    return !1
}
function createElementNS(e) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", e)
}
function SRGBToLinear(e) {
    return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
}
function LinearToSRGB(e) {
    return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
}
Matrix3.prototype.isMatrix3 = !0;
var FN = (_FN = {},
_defineProperty(_FN, SRGBColorSpace, _defineProperty({}, LinearSRGBColorSpace, SRGBToLinear)),
_defineProperty(_FN, LinearSRGBColorSpace, _defineProperty({}, SRGBColorSpace, LinearToSRGB)),
_FN)
  , ColorManagement = {
    legacyMode: !0,
    get workingColorSpace() {
        return LinearSRGBColorSpace
    },
    set workingColorSpace(e) {
        console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")
    },
    convert: function(e, t, r) {
        if (this.legacyMode || t === r || !t || !r)
            return e;
        if (FN[t] && void 0 !== FN[t][r]) {
            var i = FN[t][r];
            return e.r = i(e.r),
            e.g = i(e.g),
            e.b = i(e.b),
            e
        }
        throw new Error("Unsupported color space conversion.")
    },
    fromWorkingColorSpace: function(e, t) {
        return this.convert(e, this.workingColorSpace, t)
    },
    toWorkingColorSpace: function(e, t) {
        return this.convert(e, t, this.workingColorSpace)
    }
}
  , _colorKeywords = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
}
  , _rgb = {
    r: 0,
    g: 0,
    b: 0
}
  , _hslA = {
    h: 0,
    s: 0,
    l: 0
}
  , _hslB = {
    h: 0,
    s: 0,
    l: 0
};
function hue2rgb(e, t, r) {
    return r < 0 && (r += 1),
    r > 1 && (r -= 1),
    r < 1 / 6 ? e + 6 * (t - e) * r : r < .5 ? t : r < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - r) : e
}
function toComponents(e, t) {
    return t.r = e.r,
    t.g = e.g,
    t.b = e.b,
    t
}
var Color = function() {
    function e(t, r, i) {
        return _classCallCheck(this, e),
        void 0 === r && void 0 === i ? this.set(t) : this.setRGB(t, r, i)
    }
    return _createClass(e, [{
        key: "set",
        value: function(e) {
            return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e),
            this
        }
    }, {
        key: "setScalar",
        value: function(e) {
            return this.r = e,
            this.g = e,
            this.b = e,
            this
        }
    }, {
        key: "setHex",
        value: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : SRGBColorSpace;
            return e = Math.floor(e),
            this.r = (e >> 16 & 255) / 255,
            this.g = (e >> 8 & 255) / 255,
            this.b = (255 & e) / 255,
            ColorManagement.toWorkingColorSpace(this, t),
            this
        }
    }, {
        key: "setRGB",
        value: function(e, t, r) {
            var i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : LinearSRGBColorSpace;
            return this.r = e,
            this.g = t,
            this.b = r,
            ColorManagement.toWorkingColorSpace(this, i),
            this
        }
    }, {
        key: "setHSL",
        value: function(e, t, r) {
            var i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : LinearSRGBColorSpace;
            if (e = euclideanModulo(e, 1),
            t = clamp(t, 0, 1),
            r = clamp(r, 0, 1),
            0 === t)
                this.r = this.g = this.b = r;
            else {
                var n = r <= .5 ? r * (1 + t) : r + t - r * t
                  , a = 2 * r - n;
                this.r = hue2rgb(a, n, e + 1 / 3),
                this.g = hue2rgb(a, n, e),
                this.b = hue2rgb(a, n, e - 1 / 3)
            }
            return ColorManagement.toWorkingColorSpace(this, i),
            this
        }
    }, {
        key: "setStyle",
        value: function(e) {
            var t, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : SRGBColorSpace;
            function i(t) {
                void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
            }
            if (t = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
                var n, a = t[1], o = t[2];
                switch (a) {
                case "rgb":
                case "rgba":
                    if (n = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
                        return this.r = Math.min(255, parseInt(n[1], 10)) / 255,
                        this.g = Math.min(255, parseInt(n[2], 10)) / 255,
                        this.b = Math.min(255, parseInt(n[3], 10)) / 255,
                        ColorManagement.toWorkingColorSpace(this, r),
                        i(n[4]),
                        this;
                    if (n = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
                        return this.r = Math.min(100, parseInt(n[1], 10)) / 100,
                        this.g = Math.min(100, parseInt(n[2], 10)) / 100,
                        this.b = Math.min(100, parseInt(n[3], 10)) / 100,
                        ColorManagement.toWorkingColorSpace(this, r),
                        i(n[4]),
                        this;
                    break;
                case "hsl":
                case "hsla":
                    if (n = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) {
                        var s = parseFloat(n[1]) / 360
                          , l = parseInt(n[2], 10) / 100
                          , u = parseInt(n[3], 10) / 100;
                        return i(n[4]),
                        this.setHSL(s, l, u, r)
                    }
                }
            } else if (t = /^\#([A-Fa-f\d]+)$/.exec(e)) {
                var c = t[1]
                  , h = c.length;
                if (3 === h)
                    return this.r = parseInt(c.charAt(0) + c.charAt(0), 16) / 255,
                    this.g = parseInt(c.charAt(1) + c.charAt(1), 16) / 255,
                    this.b = parseInt(c.charAt(2) + c.charAt(2), 16) / 255,
                    ColorManagement.toWorkingColorSpace(this, r),
                    this;
                if (6 === h)
                    return this.r = parseInt(c.charAt(0) + c.charAt(1), 16) / 255,
                    this.g = parseInt(c.charAt(2) + c.charAt(3), 16) / 255,
                    this.b = parseInt(c.charAt(4) + c.charAt(5), 16) / 255,
                    ColorManagement.toWorkingColorSpace(this, r),
                    this
            }
            return e && e.length > 0 ? this.setColorName(e, r) : this
        }
    }, {
        key: "setColorName",
        value: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : SRGBColorSpace
              , r = _colorKeywords[e.toLowerCase()];
            return void 0 !== r ? this.setHex(r, t) : console.warn("THREE.Color: Unknown color " + e),
            this
        }
    }, {
        key: "clone",
        value: function() {
            return new this.constructor(this.r,this.g,this.b)
        }
    }, {
        key: "copy",
        value: function(e) {
            return this.r = e.r,
            this.g = e.g,
            this.b = e.b,
            this
        }
    }, {
        key: "copySRGBToLinear",
        value: function(e) {
            return this.r = SRGBToLinear(e.r),
            this.g = SRGBToLinear(e.g),
            this.b = SRGBToLinear(e.b),
            this
        }
    }, {
        key: "copyLinearToSRGB",
        value: function(e) {
            return this.r = LinearToSRGB(e.r),
            this.g = LinearToSRGB(e.g),
            this.b = LinearToSRGB(e.b),
            this
        }
    }, {
        key: "convertSRGBToLinear",
        value: function() {
            return this.copySRGBToLinear(this),
            this
        }
    }, {
        key: "convertLinearToSRGB",
        value: function() {
            return this.copyLinearToSRGB(this),
            this
        }
    }, {
        key: "getHex",
        value: function() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : SRGBColorSpace;
            return ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), e),
            clamp(255 * _rgb.r, 0, 255) << 16 ^ clamp(255 * _rgb.g, 0, 255) << 8 ^ clamp(255 * _rgb.b, 0, 255) << 0
        }
    }, {
        key: "getHexString",
        value: function() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : SRGBColorSpace;
            return ("000000" + this.getHex(e).toString(16)).slice(-6)
        }
    }, {
        key: "getHSL",
        value: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : LinearSRGBColorSpace;
            ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), t);
            var r, i, n = _rgb.r, a = _rgb.g, o = _rgb.b, s = Math.max(n, a, o), l = Math.min(n, a, o), u = (l + s) / 2;
            if (l === s)
                r = 0,
                i = 0;
            else {
                var c = s - l;
                switch (i = u <= .5 ? c / (s + l) : c / (2 - s - l),
                s) {
                case n:
                    r = (a - o) / c + (a < o ? 6 : 0);
                    break;
                case a:
                    r = (o - n) / c + 2;
                    break;
                case o:
                    r = (n - a) / c + 4
                }
                r /= 6
            }
            return e.h = r,
            e.s = i,
            e.l = u,
            e
        }
    }, {
        key: "getRGB",
        value: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : LinearSRGBColorSpace;
            return ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), t),
            e.r = _rgb.r,
            e.g = _rgb.g,
            e.b = _rgb.b,
            e
        }
    }, {
        key: "getStyle",
        value: function() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : SRGBColorSpace;
            return ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), e),
            e !== SRGBColorSpace ? "color(".concat(e, " ").concat(_rgb.r, " ").concat(_rgb.g, " ").concat(_rgb.b, ")") : "rgb(".concat(255 * _rgb.r | 0, ",").concat(255 * _rgb.g | 0, ",").concat(255 * _rgb.b | 0, ")")
        }
    }, {
        key: "offsetHSL",
        value: function(e, t, r) {
            return this.getHSL(_hslA),
            _hslA.h += e,
            _hslA.s += t,
            _hslA.l += r,
            this.setHSL(_hslA.h, _hslA.s, _hslA.l),
            this
        }
    }, {
        key: "add",
        value: function(e) {
            return this.r += e.r,
            this.g += e.g,
            this.b += e.b,
            this
        }
    }, {
        key: "addColors",
        value: function(e, t) {
            return this.r = e.r + t.r,
            this.g = e.g + t.g,
            this.b = e.b + t.b,
            this
        }
    }, {
        key: "addScalar",
        value: function(e) {
            return this.r += e,
            this.g += e,
            this.b += e,
            this
        }
    }, {
        key: "sub",
        value: function(e) {
            return this.r = Math.max(0, this.r - e.r),
            this.g = Math.max(0, this.g - e.g),
            this.b = Math.max(0, this.b - e.b),
            this
        }
    }, {
        key: "multiply",
        value: function(e) {
            return this.r *= e.r,
            this.g *= e.g,
            this.b *= e.b,
            this
        }
    }, {
        key: "multiplyScalar",
        value: function(e) {
            return this.r *= e,
            this.g *= e,
            this.b *= e,
            this
        }
    }, {
        key: "lerp",
        value: function(e, t) {
            return this.r += (e.r - this.r) * t,
            this.g += (e.g - this.g) * t,
            this.b += (e.b - this.b) * t,
            this
        }
    }, {
        key: "lerpColors",
        value: function(e, t, r) {
            return this.r = e.r + (t.r - e.r) * r,
            this.g = e.g + (t.g - e.g) * r,
            this.b = e.b + (t.b - e.b) * r,
            this
        }
    }, {
        key: "lerpHSL",
        value: function(e, t) {
            this.getHSL(_hslA),
            e.getHSL(_hslB);
            var r = lerp(_hslA.h, _hslB.h, t)
              , i = lerp(_hslA.s, _hslB.s, t)
              , n = lerp(_hslA.l, _hslB.l, t);
            return this.setHSL(r, i, n),
            this
        }
    }, {
        key: "equals",
        value: function(e) {
            return e.r === this.r && e.g === this.g && e.b === this.b
        }
    }, {
        key: "fromArray",
        value: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
            return this.r = e[t],
            this.g = e[t + 1],
            this.b = e[t + 2],
            this
        }
    }, {
        key: "toArray",
        value: function() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
              , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
            return e[t] = this.r,
            e[t + 1] = this.g,
            e[t + 2] = this.b,
            e
        }
    }, {
        key: "fromBufferAttribute",
        value: function(e, t) {
            return this.r = e.getX(t),
            this.g = e.getY(t),
            this.b = e.getZ(t),
            !0 === e.normalized && (this.r /= 255,
            this.g /= 255,
            this.b /= 255),
            this
        }
    }, {
        key: "toJSON",
        value: function() {
            return this.getHex()
        }
    }]),
    e
}(), _canvas;
Color.NAMES = _colorKeywords,
Color.prototype.isColor = !0,
Color.prototype.r = 1,
Color.prototype.g = 1,
Color.prototype.b = 1;
var ImageUtils = function() {
    function e() {
        _classCallCheck(this, e)
    }
    return _createClass(e, null, [{
        key: "getDataURL",
        value: function(e) {
            if (/^data:/i.test(e.src))
                return e.src;
            if ("undefined" == typeof HTMLCanvasElement)
                return e.src;
            var t;
            if (e instanceof HTMLCanvasElement)
                t = e;
            else {
                void 0 === _canvas && (_canvas = createElementNS("canvas")),
                _canvas.width = e.width,
                _canvas.height = e.height;
                var r = _canvas.getContext("2d");
                e instanceof ImageData ? r.putImageData(e, 0, 0) : r.drawImage(e, 0, 0, e.width, e.height),
                t = _canvas
            }
            return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e),
            t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
        }
    }, {
        key: "sRGBToLinear",
        value: function(e) {
            if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                var t = createElementNS("canvas");
                t.width = e.width,
                t.height = e.height;
                var r = t.getContext("2d");
                r.drawImage(e, 0, 0, e.width, e.height);
                for (var i = r.getImageData(0, 0, e.width, e.height), n = i.data, a = 0; a < n.length; a++)
                    n[a] = 255 * SRGBToLinear(n[a] / 255);
                return r.putImageData(i, 0, 0),
                t
            }
            if (e.data) {
                for (var o = e.data.slice(0), s = 0; s < o.length; s++)
                    o instanceof Uint8Array || o instanceof Uint8ClampedArray ? o[s] = Math.floor(255 * SRGBToLinear(o[s] / 255)) : o[s] = SRGBToLinear(o[s]);
                return {
                    data: o,
                    width: e.width,
                    height: e.height
                }
            }
            return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
            e
        }
    }]),
    e
}()
  , Source = function() {
    function e() {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
        _classCallCheck(this, e),
        this.uuid = generateUUID(),
        this.data = t,
        this.version = 0
    }
    return _createClass(e, [{
        key: "needsUpdate",
        set: function(e) {
            !0 === e && this.version++
        }
    }, {
        key: "toJSON",
        value: function(e) {
            var t = void 0 === e || "string" == typeof e;
            if (!t && void 0 !== e.images[this.uuid])
                return e.images[this.uuid];
            var r = {
                uuid: this.uuid,
                url: ""
            }
              , i = this.data;
            if (null !== i) {
                var n;
                if (Array.isArray(i)) {
                    n = [];
                    for (var a = 0, o = i.length; a < o; a++)
                        i[a].isDataTexture ? n.push(serializeImage(i[a].image)) : n.push(serializeImage(i[a]))
                } else
                    n = serializeImage(i);
                r.url = n
            }
            return t || (e.images[this.uuid] = r),
            r
        }
    }]),
    e
}();
function serializeImage(e) {
    return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? ImageUtils.getDataURL(e) : e.data ? {
        data: Array.prototype.slice.call(e.data),
        width: e.width,
        height: e.height,
        type: e.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."),
    {})
}
Source.prototype.isSource = !0;
var textureId = 0
  , Texture = function(e) {
    _inherits(r, EventDispatcher);
    var t = _createSuper(r);
    function r() {
        var e, i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : r.DEFAULT_IMAGE, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : r.DEFAULT_MAPPING, a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : ClampToEdgeWrapping, o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : ClampToEdgeWrapping, s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : LinearFilter, l = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : LinearMipmapLinearFilter, u = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : RGBAFormat, c = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : UnsignedByteType, h = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 1, d = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : LinearEncoding;
        return _classCallCheck(this, r),
        e = t.call(this),
        Object.defineProperty(_assertThisInitialized(e), "id", {
            value: textureId++
        }),
        e.uuid = generateUUID(),
        e.name = "",
        e.source = new Source(i),
        e.mipmaps = [],
        e.mapping = n,
        e.wrapS = a,
        e.wrapT = o,
        e.magFilter = s,
        e.minFilter = l,
        e.anisotropy = h,
        e.format = u,
        e.internalFormat = null,
        e.type = c,
        e.offset = new Vector2(0,0),
        e.repeat = new Vector2(1,1),
        e.center = new Vector2(0,0),
        e.rotation = 0,
        e.matrixAutoUpdate = !0,
        e.matrix = new Matrix3,
        e.generateMipmaps = !0,
        e.premultiplyAlpha = !1,
        e.flipY = !0,
        e.unpackAlignment = 4,
        e.encoding = d,
        e.userData = {},
        e.version = 0,
        e.onUpdate = null,
        e.isRenderTargetTexture = !1,
        e.needsPMREMUpdate = !1,
        e
    }
    return _createClass(r, [{
        key: "image",
        get: function() {
            return this.source.data
        },
        set: function(e) {
            this.source.data = e
        }
    }, {
        key: "updateMatrix",
        value: function() {
            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
        }
    }, {
        key: "clone",
        value: function() {
            return (new this.constructor).copy(this)
        }
    }, {
        key: "copy",
        value: function(e) {
            return this.name = e.name,
            this.source = e.source,
            this.mipmaps = e.mipmaps.slice(0),
            this.mapping = e.mapping,
            this.wrapS = e.wrapS,
            this.wrapT = e.wrapT,
            this.magFilter = e.magFilter,
            this.minFilter = e.minFilter,
            this.anisotropy = e.anisotropy,
            this.format = e.format,
            this.internalFormat = e.internalFormat,
            this.type = e.type,
            this.offset.copy(e.offset),
            this.repeat.copy(e.repeat),
            this.center.copy(e.center),
            this.rotation = e.rotation,
            this.matrixAutoUpdate = e.matrixAutoUpdate,
            this.matrix.copy(e.matrix),
            this.generateMipmaps = e.generateMipmaps,
            this.premultiplyAlpha = e.premultiplyAlpha,
            this.flipY = e.flipY,
            this.unpackAlignment = e.unpackAlignment,
            this.encoding = e.encoding,
            this.userData = JSON.parse(JSON.stringify(e.userData)),
            this.needsUpdate = !0,
            this
        }
    }, {
        key: "toJSON",
        value: function(e) {
            var t = void 0 === e || "string" == typeof e;
            if (!t && void 0 !== e.textures[this.uuid])
                return e.textures[this.uuid];
            var r = {
                metadata: {
                    version: 4.5,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                image: this.source.toJSON(e).uuid,
                mapping: this.mapping,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                center: [this.center.x, this.center.y],
                rotation: this.rotation,
                wrap: [this.wrapS, this.wrapT],
                format: this.format,
                type: this.type,
                encoding: this.encoding,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY,
                premultiplyAlpha: this.premultiplyAlpha,
                unpackAlignment: this.unpackAlignment
            };
            return "{}" !== JSON.stringify(this.userData) && (r.userData = this.userData),
            t || (e.textures[this.uuid] = r),
            r
        }
    }, {
        key: "dispose",
        value: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }, {
        key: "transformUv",
        value: function(e) {
            if (this.mapping !== UVMapping)
                return e;
            if (e.applyMatrix3(this.matrix),
            e.x < 0 || e.x > 1)
                switch (this.wrapS) {
                case RepeatWrapping:
                    e.x = e.x - Math.floor(e.x);
                    break;
                case ClampToEdgeWrapping:
                    e.x = e.x < 0 ? 0 : 1;
                    break;
                case MirroredRepeatWrapping:
                    1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
                }
            if (e.y < 0 || e.y > 1)
                switch (this.wrapT) {
                case RepeatWrapping:
                    e.y = e.y - Math.floor(e.y);
                    break;
                case ClampToEdgeWrapping:
                    e.y = e.y < 0 ? 0 : 1;
                    break;
                case MirroredRepeatWrapping:
                    1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
                }
            return this.flipY && (e.y = 1 - e.y),
            e
        }
    }, {
        key: "needsUpdate",
        set: function(e) {
            !0 === e && (this.version++,
            this.source.needsUpdate = !0)
        }
    }]),
    r
}();
Texture.DEFAULT_IMAGE = null,
Texture.DEFAULT_MAPPING = UVMapping,
Texture.prototype.isTexture = !0;
var Vector4 = function(e) {
    function t() {
        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
          , r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
          , i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0
          , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
        _classCallCheck(this, t),
        this.x = e,
        this.y = r,
        this.z = i,
        this.w = n
    }
    return _createClass(t, [{
        key: "width",
        get: function() {
            return this.z
        },
        set: function(e) {
            this.z = e
        }
    }, {
        key: "height",
        get: function() {
            return this.w
        },
        set: function(e) {
            this.w = e
        }
    }, {
        key: "set",
        value: function(e, t, r, i) {
            return this.x = e,
            this.y = t,
            this.z = r,
            this.w = i,
            this
        }
    }, {
        key: "setScalar",
        value: function(e) {
            return this.x = e,
            this.y = e,
            this.z = e,
            this.w = e,
            this
        }
    }, {
        key: "setX",
        value: function(e) {
            return this.x = e,
            this
        }
    }, {
        key: "setY",
        value: function(e) {
            return this.y = e,
            this
        }
    }, {
        key: "setZ",
        value: function(e) {
            return this.z = e,
            this
        }
    }, {
        key: "setW",
        value: function(e) {
            return this.w = e,
            this
        }
    }, {
        key: "setComponent",
        value: function(e, t) {
            switch (e) {
            case 0:
                this.x = t;
                break;
            case 1:
                this.y = t;
                break;
            case 2:
                this.z = t;
                break;
            case 3:
                this.w = t;
                break;
            default:
                throw new Error("index is out of range: " + e)
            }
            return this
        }
    }, {
        key: "getComponent",
        value: function(e) {
            switch (e) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw new Error("index is out of range: " + e)
            }
        }
    }, {
        key: "clone",
        value: function() {
            return new this.constructor(this.x,this.y,this.z,this.w)
        }
    }, {
        key: "copy",
        value: function(e) {
            return this.x = e.x,
            this.y = e.y,
            this.z = e.z,
            this.w = void 0 !== e.w ? e.w : 1,
            this
        }
    }, {
        key: "add",
        value: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
            this.addVectors(e, t)) : (this.x += e.x,
            this.y += e.y,
            this.z += e.z,
            this.w += e.w,
            this)
        }
    }, {
        key: "addScalar",
        value: function(e) {
            return this.x += e,
            this.y += e,
            this.z += e,
            this.w += e,
            this
        }
    }, {
        key: "addVectors",
        value: function(e, t) {
            return this.x = e.x + t.x,
            this.y = e.y + t.y,
            this.z = e.z + t.z,
            this.w = e.w + t.w,
            this
        }
    }, {
        key: "addScaledVector",
        value: function(e, t) {
            return this.x += e.x * t,
            this.y += e.y * t,
            this.z += e.z * t,
            this.w += e.w * t,
            this
        }
    }, {
        key: "sub",
        value: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
            this.subVectors(e, t)) : (this.x -= e.x,
            this.y -= e.y,
            this.z -= e.z,
            this.w -= e.w,
            this)
        }
    }, {
        key: "subScalar",
        value: function(e) {
            return this.x -= e,
            this.y -= e,
            this.z -= e,
            this.w -= e,
            this
        }
    }, {
        key: "subVectors",
        value: function(e, t) {
            return this.x = e.x - t.x,
            this.y = e.y - t.y,
            this.z = e.z - t.z,
            this.w = e.w - t.w,
            this
        }
    }, {
        key: "multiply",
        value: function(e) {
            return this.x *= e.x,
            this.y *= e.y,
            this.z *= e.z,
            this.w *= e.w,
            this
        }
    }, {
        key: "multiplyScalar",
        value: function(e) {
            return this.x *= e,
            this.y *= e,
            this.z *= e,
            this.w *= e,
            this
        }
    }, {
        key: "applyMatrix4",
        value: function(e) {
            var t = this.x
              , r = this.y
              , i = this.z
              , n = this.w
              , a = e.elements;
            return this.x = a[0] * t + a[4] * r + a[8] * i + a[12] * n,
            this.y = a[1] * t + a[5] * r + a[9] * i + a[13] * n,
            this.z = a[2] * t + a[6] * r + a[10] * i + a[14] * n,
            this.w = a[3] * t + a[7] * r + a[11] * i + a[15] * n,
            this
        }
    }, {
        key: "divideScalar",
        value: function(e) {
            return this.multiplyScalar(1 / e)
        }
    }, {
        key: "setAxisAngleFromQuaternion",
        value: function(e) {
            this.w = 2 * Math.acos(e.w);
            var t = Math.sqrt(1 - e.w * e.w);
            return t < 1e-4 ? (this.x = 1,
            this.y = 0,
            this.z = 0) : (this.x = e.x / t,
            this.y = e.y / t,
            this.z = e.z / t),
            this
        }
    }, {
        key: "setAxisAngleFromRotationMatrix",
        value: function(e) {
            var t, r, i, n, a = .01, o = .1, s = e.elements, l = s[0], u = s[4], c = s[8], h = s[1], d = s[5], p = s[9], f = s[2], m = s[6], v = s[10];
            if (Math.abs(u - h) < a && Math.abs(c - f) < a && Math.abs(p - m) < a) {
                if (Math.abs(u + h) < o && Math.abs(c + f) < o && Math.abs(p + m) < o && Math.abs(l + d + v - 3) < o)
                    return this.set(1, 0, 0, 0),
                    this;
                t = Math.PI;
                var g = (l + 1) / 2
                  , _ = (d + 1) / 2
                  , y = (v + 1) / 2
                  , x = (u + h) / 4
                  , b = (c + f) / 4
                  , S = (p + m) / 4;
                return g > _ && g > y ? g < a ? (r = 0,
                i = .707106781,
                n = .707106781) : (i = x / (r = Math.sqrt(g)),
                n = b / r) : _ > y ? _ < a ? (r = .707106781,
                i = 0,
                n = .707106781) : (r = x / (i = Math.sqrt(_)),
                n = S / i) : y < a ? (r = .707106781,
                i = .707106781,
                n = 0) : (r = b / (n = Math.sqrt(y)),
                i = S / n),
                this.set(r, i, n, t),
                this
            }
            var w = Math.sqrt((m - p) * (m - p) + (c - f) * (c - f) + (h - u) * (h - u));
            return Math.abs(w) < .001 && (w = 1),
            this.x = (m - p) / w,
            this.y = (c - f) / w,
            this.z = (h - u) / w,
            this.w = Math.acos((l + d + v - 1) / 2),
            this
        }
    }, {
        key: "min",
        value: function(e) {
            return this.x = Math.min(this.x, e.x),
            this.y = Math.min(this.y, e.y),
            this.z = Math.min(this.z, e.z),
            this.w = Math.min(this.w, e.w),
            this
        }
    }, {
        key: "max",
        value: function(e) {
            return this.x = Math.max(this.x, e.x),
            this.y = Math.max(this.y, e.y),
            this.z = Math.max(this.z, e.z),
            this.w = Math.max(this.w, e.w),
            this
        }
    }, {
        key: "clamp",
        value: function(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)),
            this.y = Math.max(e.y, Math.min(t.y, this.y)),
            this.z = Math.max(e.z, Math.min(t.z, this.z)),
            this.w = Math.max(e.w, Math.min(t.w, this.w)),
            this
        }
    }, {
        key: "clampScalar",
        value: function(e, t) {
            return this.x = Math.max(e, Math.min(t, this.x)),
            this.y = Math.max(e, Math.min(t, this.y)),
            this.z = Math.max(e, Math.min(t, this.z)),
            this.w = Math.max(e, Math.min(t, this.w)),
            this
        }
    }, {
        key: "clampLength",
        value: function(e, t) {
            var r = this.length();
            return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)))
        }
    }, {
        key: "floor",
        value: function() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this.z = Math.floor(this.z),
            this.w = Math.floor(this.w),
            this
        }
    }, {
        key: "ceil",
        value: function() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this.z = Math.ceil(this.z),
            this.w = Math.ceil(this.w),
            this
        }
    }, {
        key: "round",
        value: function() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this.z = Math.round(this.z),
            this.w = Math.round(this.w),
            this
        }
    }, {
        key: "roundToZero",
        value: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
            this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w),
            this
        }
    }, {
        key: "negate",
        value: function() {
            return this.x = -this.x,
            this.y = -this.y,
            this.z = -this.z,
            this.w = -this.w,
            this
        }
    }, {
        key: "dot",
        value: function(e) {
            return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
        }
    }, {
        key: "lengthSq",
        value: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        }
    }, {
        key: "length",
        value: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        }
    }, {
        key: "manhattanLength",
        value: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        }
    }, {
        key: "normalize",
        value: function() {
            return this.divideScalar(this.length() || 1)
        }
    }, {
        key: "setLength",
        value: function(e) {
            return this.normalize().multiplyScalar(e)
        }
    }, {
        key: "lerp",
        value: function(e, t) {
            return this.x += (e.x - this.x) * t,
            this.y += (e.y - this.y) * t,
            this.z += (e.z - this.z) * t,
            this.w += (e.w - this.w) * t,
            this
        }
    }, {
        key: "lerpVectors",
        value: function(e, t, r) {
            return this.x = e.x + (t.x - e.x) * r,
            this.y = e.y + (t.y - e.y) * r,
            this.z = e.z + (t.z - e.z) * r,
            this.w = e.w + (t.w - e.w) * r,
            this
        }
    }, {
        key: "equals",
        value: function(e) {
            return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
        }
    }, {
        key: "fromArray",
        value: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
            return this.x = e[t],
            this.y = e[t + 1],
            this.z = e[t + 2],
            this.w = e[t + 3],
            this
        }
    }, {
        key: "toArray",
        value: function() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
              , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
            return e[t] = this.x,
            e[t + 1] = this.y,
            e[t + 2] = this.z,
            e[t + 3] = this.w,
            e
        }
    }, {
        key: "fromBufferAttribute",
        value: function(e, t, r) {
            return void 0 !== r && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),
            this.x = e.getX(t),
            this.y = e.getY(t),
            this.z = e.getZ(t),
            this.w = e.getW(t),
            this
        }
    }, {
        key: "random",
        value: function() {
            return this.x = Math.random(),
            this.y = Math.random(),
            this.z = Math.random(),
            this.w = Math.random(),
            this
        }
    }, {
        key: Symbol.iterator,
        value: _regeneratorRuntime().mark((function e() {
            return _regeneratorRuntime().wrap((function(e) {
                for (; ; )
                    switch (e.prev = e.next) {
                    case 0:
                        return e.next = 2,
                        this.x;
                    case 2:
                        return e.next = 4,
                        this.y;
                    case 4:
                        return e.next = 6,
                        this.z;
                    case 6:
                        return e.next = 8,
                        this.w;
                    case 8:
                    case "end":
                        return e.stop()
                    }
            }
            ), e, this)
        }
        ))
    }]),
    t
}();
Vector4.prototype.isVector4 = !0;
var WebGLRenderTarget = function(e) {
    _inherits(r, EventDispatcher);
    var t = _createSuper(r);
    function r(e, i) {
        var n, a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        _classCallCheck(this, r),
        (n = t.call(this)).width = e,
        n.height = i,
        n.depth = 1,
        n.scissor = new Vector4(0,0,e,i),
        n.scissorTest = !1,
        n.viewport = new Vector4(0,0,e,i);
        var o = {
            width: e,
            height: i,
            depth: 1
        };
        return n.texture = new Texture(o,a.mapping,a.wrapS,a.wrapT,a.magFilter,a.minFilter,a.format,a.type,a.anisotropy,a.encoding),
        n.texture.isRenderTargetTexture = !0,
        n.texture.flipY = !1,
        n.texture.generateMipmaps = void 0 !== a.generateMipmaps && a.generateMipmaps,
        n.texture.internalFormat = void 0 !== a.internalFormat ? a.internalFormat : null,
        n.texture.minFilter = void 0 !== a.minFilter ? a.minFilter : LinearFilter,
        n.depthBuffer = void 0 === a.depthBuffer || a.depthBuffer,
        n.stencilBuffer = void 0 !== a.stencilBuffer && a.stencilBuffer,
        n.depthTexture = void 0 !== a.depthTexture ? a.depthTexture : null,
        n.samples = void 0 !== a.samples ? a.samples : 0,
        n
    }
    return _createClass(r, [{
        key: "setSize",
        value: function(e, t) {
            var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
            this.width === e && this.height === t && this.depth === r || (this.width = e,
            this.height = t,
            this.depth = r,
            this.texture.image.width = e,
            this.texture.image.height = t,
            this.texture.image.depth = r,
            this.dispose()),
            this.viewport.set(0, 0, e, t),
            this.scissor.set(0, 0, e, t)
        }
    }, {
        key: "clone",
        value: function() {
            return (new this.constructor).copy(this)
        }
    }, {
        key: "copy",
        value: function(e) {
            return this.width = e.width,
            this.height = e.height,
            this.depth = e.depth,
            this.viewport.copy(e.viewport),
            this.texture = e.texture.clone(),
            this.texture.isRenderTargetTexture = !0,
            this.texture.image = Object.assign({}, e.texture.image),
            this.depthBuffer = e.depthBuffer,
            this.stencilBuffer = e.stencilBuffer,
            null !== e.depthTexture && (this.depthTexture = e.depthTexture.clone()),
            this.samples = e.samples,
            this
        }
    }, {
        key: "dispose",
        value: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }]),
    r
}();
WebGLRenderTarget.prototype.isWebGLRenderTarget = !0;
var DataArrayTexture = function(e) {
    _inherits(r, Texture);
    var t = _createSuper(r);
    function r() {
        var e, i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
        return _classCallCheck(this, r),
        (e = t.call(this, null)).image = {
            data: i,
            width: n,
            height: a,
            depth: o
        },
        e.magFilter = NearestFilter,
        e.minFilter = NearestFilter,
        e.wrapR = ClampToEdgeWrapping,
        e.generateMipmaps = !1,
        e.flipY = !1,
        e.unpackAlignment = 1,
        e
    }
    return _createClass(r)
}();
DataArrayTexture.prototype.isDataArrayTexture = !0;
var WebGLArrayRenderTarget = function(e) {
    _inherits(r, WebGLRenderTarget);
    var t = _createSuper(r);
    function r(e, i, n) {
        var a;
        return _classCallCheck(this, r),
        (a = t.call(this, e, i)).depth = n,
        a.texture = new DataArrayTexture(null,e,i,n),
        a.texture.isRenderTargetTexture = !0,
        a
    }
    return _createClass(r)
}();
WebGLArrayRenderTarget.prototype.isWebGLArrayRenderTarget = !0;
var Data3DTexture = function(e) {
    _inherits(r, Texture);
    var t = _createSuper(r);
    function r() {
        var e, i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
        return _classCallCheck(this, r),
        (e = t.call(this, null)).image = {
            data: i,
            width: n,
            height: a,
            depth: o
        },
        e.magFilter = NearestFilter,
        e.minFilter = NearestFilter,
        e.wrapR = ClampToEdgeWrapping,
        e.generateMipmaps = !1,
        e.flipY = !1,
        e.unpackAlignment = 1,
        e
    }
    return _createClass(r)
}();
Data3DTexture.prototype.isData3DTexture = !0;
var WebGL3DRenderTarget = function(e) {
    _inherits(r, WebGLRenderTarget);
    var t = _createSuper(r);
    function r(e, i, n) {
        var a;
        return _classCallCheck(this, r),
        (a = t.call(this, e, i)).depth = n,
        a.texture = new Data3DTexture(null,e,i,n),
        a.texture.isRenderTargetTexture = !0,
        a
    }
    return _createClass(r)
}();
WebGL3DRenderTarget.prototype.isWebGL3DRenderTarget = !0;
var WebGLMultipleRenderTargets = function(e) {
    _inherits(r, WebGLRenderTarget);
    var t = _createSuper(r);
    function r(e, i, n) {
        var a, o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
        _classCallCheck(this, r);
        var s = (a = t.call(this, e, i, o)).texture;
        a.texture = [];
        for (var l = 0; l < n; l++)
            a.texture[l] = s.clone(),
            a.texture[l].isRenderTargetTexture = !0;
        return a
    }
    return _createClass(r, [{
        key: "setSize",
        value: function(e, t) {
            var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
            if (this.width !== e || this.height !== t || this.depth !== r) {
                this.width = e,
                this.height = t,
                this.depth = r;
                for (var i = 0, n = this.texture.length; i < n; i++)
                    this.texture[i].image.width = e,
                    this.texture[i].image.height = t,
                    this.texture[i].image.depth = r;
                this.dispose()
            }
            return this.viewport.set(0, 0, e, t),
            this.scissor.set(0, 0, e, t),
            this
        }
    }, {
        key: "copy",
        value: function(e) {
            this.dispose(),
            this.width = e.width,
            this.height = e.height,
            this.depth = e.depth,
            this.viewport.set(0, 0, this.width, this.height),
            this.scissor.set(0, 0, this.width, this.height),
            this.depthBuffer = e.depthBuffer,
            this.stencilBuffer = e.stencilBuffer,
            this.depthTexture = e.depthTexture,
            this.texture.length = 0;
            for (var t = 0, r = e.texture.length; t < r; t++)
                this.texture[t] = e.texture[t].clone();
            return this
        }
    }]),
    r
}();
WebGLMultipleRenderTargets.prototype.isWebGLMultipleRenderTargets = !0;
var Quaternion = function() {
    function e() {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
          , r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
          , i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0
          , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
        _classCallCheck(this, e),
        this._x = t,
        this._y = r,
        this._z = i,
        this._w = n
    }
    return _createClass(e, [{
        key: "x",
        get: function() {
            return this._x
        },
        set: function(e) {
            this._x = e,
            this._onChangeCallback()
        }
    }, {
        key: "y",
        get: function() {
            return this._y
        },
        set: function(e) {
            this._y = e,
            this._onChangeCallback()
        }
    }, {
        key: "z",
        get: function() {
            return this._z
        },
        set: function(e) {
            this._z = e,
            this._onChangeCallback()
        }
    }, {
        key: "w",
        get: function() {
            return this._w
        },
        set: function(e) {
            this._w = e,
            this._onChangeCallback()
        }
    }, {
        key: "set",
        value: function(e, t, r, i) {
            return this._x = e,
            this._y = t,
            this._z = r,
            this._w = i,
            this._onChangeCallback(),
            this
        }
    }, {
        key: "clone",
        value: function() {
            return new this.constructor(this._x,this._y,this._z,this._w)
        }
    }, {
        key: "copy",
        value: function(e) {
            return this._x = e.x,
            this._y = e.y,
            this._z = e.z,
            this._w = e.w,
            this._onChangeCallback(),
            this
        }
    }, {
        key: "setFromEuler",
        value: function(e, t) {
            if (!e || !e.isEuler)
                throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
            var r = e._x
              , i = e._y
              , n = e._z
              , a = e._order
              , o = Math.cos
              , s = Math.sin
              , l = o(r / 2)
              , u = o(i / 2)
              , c = o(n / 2)
              , h = s(r / 2)
              , d = s(i / 2)
              , p = s(n / 2);
            switch (a) {
            case "XYZ":
                this._x = h * u * c + l * d * p,
                this._y = l * d * c - h * u * p,
                this._z = l * u * p + h * d * c,
                this._w = l * u * c - h * d * p;
                break;
            case "YXZ":
                this._x = h * u * c + l * d * p,
                this._y = l * d * c - h * u * p,
                this._z = l * u * p - h * d * c,
                this._w = l * u * c + h * d * p;
                break;
            case "ZXY":
                this._x = h * u * c - l * d * p,
                this._y = l * d * c + h * u * p,
                this._z = l * u * p + h * d * c,
                this._w = l * u * c - h * d * p;
                break;
            case "ZYX":
                this._x = h * u * c - l * d * p,
                this._y = l * d * c + h * u * p,
                this._z = l * u * p - h * d * c,
                this._w = l * u * c + h * d * p;
                break;
            case "YZX":
                this._x = h * u * c + l * d * p,
                this._y = l * d * c + h * u * p,
                this._z = l * u * p - h * d * c,
                this._w = l * u * c - h * d * p;
                break;
            case "XZY":
                this._x = h * u * c - l * d * p,
                this._y = l * d * c - h * u * p,
                this._z = l * u * p + h * d * c,
                this._w = l * u * c + h * d * p;
                break;
            default:
                console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a)
            }
            return !1 !== t && this._onChangeCallback(),
            this
        }
    }, {
        key: "setFromAxisAngle",
        value: function(e, t) {
            var r = t / 2
              , i = Math.sin(r);
            return this._x = e.x * i,
            this._y = e.y * i,
            this._z = e.z * i,
            this._w = Math.cos(r),
            this._onChangeCallback(),
            this
        }
    }, {
        key: "setFromRotationMatrix",
        value: function(e) {
            var t = e.elements
              , r = t[0]
              , i = t[4]
              , n = t[8]
              , a = t[1]
              , o = t[5]
              , s = t[9]
              , l = t[2]
              , u = t[6]
              , c = t[10]
              , h = r + o + c;
            if (h > 0) {
                var d = .5 / Math.sqrt(h + 1);
                this._w = .25 / d,
                this._x = (u - s) * d,
                this._y = (n - l) * d,
                this._z = (a - i) * d
            } else if (r > o && r > c) {
                var p = 2 * Math.sqrt(1 + r - o - c);
                this._w = (u - s) / p,
                this._x = .25 * p,
                this._y = (i + a) / p,
                this._z = (n + l) / p
            } else if (o > c) {
                var f = 2 * Math.sqrt(1 + o - r - c);
                this._w = (n - l) / f,
                this._x = (i + a) / f,
                this._y = .25 * f,
                this._z = (s + u) / f
            } else {
                var m = 2 * Math.sqrt(1 + c - r - o);
                this._w = (a - i) / m,
                this._x = (n + l) / m,
                this._y = (s + u) / m,
                this._z = .25 * m
            }
            return this._onChangeCallback(),
            this
        }
    }, {
        key: "setFromUnitVectors",
        value: function(e, t) {
            var r = e.dot(t) + 1;
            return r < Number.EPSILON ? (r = 0,
            Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
            this._y = e.x,
            this._z = 0,
            this._w = r) : (this._x = 0,
            this._y = -e.z,
            this._z = e.y,
            this._w = r)) : (this._x = e.y * t.z - e.z * t.y,
            this._y = e.z * t.x - e.x * t.z,
            this._z = e.x * t.y - e.y * t.x,
            this._w = r),
            this.normalize()
        }
    }, {
        key: "angleTo",
        value: function(e) {
            return 2 * Math.acos(Math.abs(clamp(this.dot(e), -1, 1)))
        }
    }, {
        key: "rotateTowards",
        value: function(e, t) {
            var r = this.angleTo(e);
            if (0 === r)
                return this;
            var i = Math.min(1, t / r);
            return this.slerp(e, i),
            this
        }
    }, {
        key: "identity",
        value: function() {
            return this.set(0, 0, 0, 1)
        }
    }, {
        key: "invert",
        value: function() {
            return this.conjugate()
        }
    }, {
        key: "conjugate",
        value: function() {
            return this._x *= -1,
            this._y *= -1,
            this._z *= -1,
            this._onChangeCallback(),
            this
        }
    }, {
        key: "dot",
        value: function(e) {
            return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
        }
    }, {
        key: "lengthSq",
        value: function() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        }
    }, {
        key: "length",
        value: function() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        }
    }, {
        key: "normalize",
        value: function() {
            var e = this.length();
            return 0 === e ? (this._x = 0,
            this._y = 0,
            this._z = 0,
            this._w = 1) : (e = 1 / e,
            this._x = this._x * e,
            this._y = this._y * e,
            this._z = this._z * e,
            this._w = this._w * e),
            this._onChangeCallback(),
            this
        }
    }, {
        key: "multiply",
        value: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),
            this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e)
        }
    }, {
        key: "premultiply",
        value: function(e) {
            return this.multiplyQuaternions(e, this)
        }
    }, {
        key: "multiplyQuaternions",
        value: function(e, t) {
            var r = e._x
              , i = e._y
              , n = e._z
              , a = e._w
              , o = t._x
              , s = t._y
              , l = t._z
              , u = t._w;
            return this._x = r * u + a * o + i * l - n * s,
            this._y = i * u + a * s + n * o - r * l,
            this._z = n * u + a * l + r * s - i * o,
            this._w = a * u - r * o - i * s - n * l,
            this._onChangeCallback(),
            this
        }
    }, {
        key: "slerp",
        value: function(e, t) {
            if (0 === t)
                return this;
            if (1 === t)
                return this.copy(e);
            var r = this._x
              , i = this._y
              , n = this._z
              , a = this._w
              , o = a * e._w + r * e._x + i * e._y + n * e._z;
            if (o < 0 ? (this._w = -e._w,
            this._x = -e._x,
            this._y = -e._y,
            this._z = -e._z,
            o = -o) : this.copy(e),
            o >= 1)
                return this._w = a,
                this._x = r,
                this._y = i,
                this._z = n,
                this;
            var s = 1 - o * o;
            if (s <= Number.EPSILON) {
                var l = 1 - t;
                return this._w = l * a + t * this._w,
                this._x = l * r + t * this._x,
                this._y = l * i + t * this._y,
                this._z = l * n + t * this._z,
                this.normalize(),
                this._onChangeCallback(),
                this
            }
            var u = Math.sqrt(s)
              , c = Math.atan2(u, o)
              , h = Math.sin((1 - t) * c) / u
              , d = Math.sin(t * c) / u;
            return this._w = a * h + this._w * d,
            this._x = r * h + this._x * d,
            this._y = i * h + this._y * d,
            this._z = n * h + this._z * d,
            this._onChangeCallback(),
            this
        }
    }, {
        key: "slerpQuaternions",
        value: function(e, t, r) {
            return this.copy(e).slerp(t, r)
        }
    }, {
        key: "random",
        value: function() {
            var e = Math.random()
              , t = Math.sqrt(1 - e)
              , r = Math.sqrt(e)
              , i = 2 * Math.PI * Math.random()
              , n = 2 * Math.PI * Math.random();
            return this.set(t * Math.cos(i), r * Math.sin(n), r * Math.cos(n), t * Math.sin(i))
        }
    }, {
        key: "equals",
        value: function(e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
        }
    }, {
        key: "fromArray",
        value: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
            return this._x = e[t],
            this._y = e[t + 1],
            this._z = e[t + 2],
            this._w = e[t + 3],
            this._onChangeCallback(),
            this
        }
    }, {
        key: "toArray",
        value: function() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
              , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
            return e[t] = this._x,
            e[t + 1] = this._y,
            e[t + 2] = this._z,
            e[t + 3] = this._w,
            e
        }
    }, {
        key: "fromBufferAttribute",
        value: function(e, t) {
            return this._x = e.getX(t),
            this._y = e.getY(t),
            this._z = e.getZ(t),
            this._w = e.getW(t),
            this
        }
    }, {
        key: "_onChange",
        value: function(e) {
            return this._onChangeCallback = e,
            this
        }
    }, {
        key: "_onChangeCallback",
        value: function() {}
    }], [{
        key: "slerp",
        value: function(e, t, r, i) {
            return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),
            r.slerpQuaternions(e, t, i)
        }
    }, {
        key: "slerpFlat",
        value: function(e, t, r, i, n, a, o) {
            var s = r[i + 0]
              , l = r[i + 1]
              , u = r[i + 2]
              , c = r[i + 3]
              , h = n[a + 0]
              , d = n[a + 1]
              , p = n[a + 2]
              , f = n[a + 3];
            if (0 === o)
                return e[t + 0] = s,
                e[t + 1] = l,
                e[t + 2] = u,
                void (e[t + 3] = c);
            if (1 === o)
                return e[t + 0] = h,
                e[t + 1] = d,
                e[t + 2] = p,
                void (e[t + 3] = f);
            if (c !== f || s !== h || l !== d || u !== p) {
                var m = 1 - o
                  , v = s * h + l * d + u * p + c * f
                  , g = v >= 0 ? 1 : -1
                  , _ = 1 - v * v;
                if (_ > Number.EPSILON) {
                    var y = Math.sqrt(_)
                      , x = Math.atan2(y, v * g);
                    m = Math.sin(m * x) / y,
                    o = Math.sin(o * x) / y
                }
                var b = o * g;
                if (s = s * m + h * b,
                l = l * m + d * b,
                u = u * m + p * b,
                c = c * m + f * b,
                m === 1 - o) {
                    var S = 1 / Math.sqrt(s * s + l * l + u * u + c * c);
                    s *= S,
                    l *= S,
                    u *= S,
                    c *= S
                }
            }
            e[t] = s,
            e[t + 1] = l,
            e[t + 2] = u,
            e[t + 3] = c
        }
    }, {
        key: "multiplyQuaternionsFlat",
        value: function(e, t, r, i, n, a) {
            var o = r[i]
              , s = r[i + 1]
              , l = r[i + 2]
              , u = r[i + 3]
              , c = n[a]
              , h = n[a + 1]
              , d = n[a + 2]
              , p = n[a + 3];
            return e[t] = o * p + u * c + s * d - l * h,
            e[t + 1] = s * p + u * h + l * c - o * d,
            e[t + 2] = l * p + u * d + o * h - s * c,
            e[t + 3] = u * p - o * c - s * h - l * d,
            e
        }
    }]),
    e
}();
Quaternion.prototype.isQuaternion = !0;
var Vector3 = function(e) {
    function t() {
        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
          , r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
          , i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        _classCallCheck(this, t),
        this.x = e,
        this.y = r,
        this.z = i
    }
    return _createClass(t, [{
        key: "set",
        value: function(e, t, r) {
            return void 0 === r && (r = this.z),
            this.x = e,
            this.y = t,
            this.z = r,
            this
        }
    }, {
        key: "setScalar",
        value: function(e) {
            return this.x = e,
            this.y = e,
            this.z = e,
            this
        }
    }, {
        key: "setX",
        value: function(e) {
            return this.x = e,
            this
        }
    }, {
        key: "setY",
        value: function(e) {
            return this.y = e,
            this
        }
    }, {
        key: "setZ",
        value: function(e) {
            return this.z = e,
            this
        }
    }, {
        key: "setComponent",
        value: function(e, t) {
            switch (e) {
            case 0:
                this.x = t;
                break;
            case 1:
                this.y = t;
                break;
            case 2:
                this.z = t;
                break;
            default:
                throw new Error("index is out of range: " + e)
            }
            return this
        }
    }, {
        key: "getComponent",
        value: function(e) {
            switch (e) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw new Error("index is out of range: " + e)
            }
        }
    }, {
        key: "clone",
        value: function() {
            return new this.constructor(this.x,this.y,this.z)
        }
    }, {
        key: "copy",
        value: function(e) {
            return this.x = e.x,
            this.y = e.y,
            this.z = e.z,
            this
        }
    }, {
        key: "add",
        value: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
            this.addVectors(e, t)) : (this.x += e.x,
            this.y += e.y,
            this.z += e.z,
            this)
        }
    }, {
        key: "addScalar",
        value: function(e) {
            return this.x += e,
            this.y += e,
            this.z += e,
            this
        }
    }, {
        key: "addVectors",
        value: function(e, t) {
            return this.x = e.x + t.x,
            this.y = e.y + t.y,
            this.z = e.z + t.z,
            this
        }
    }, {
        key: "addScaledVector",
        value: function(e, t) {
            return this.x += e.x * t,
            this.y += e.y * t,
            this.z += e.z * t,
            this
        }
    }, {
        key: "sub",
        value: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
            this.subVectors(e, t)) : (this.x -= e.x,
            this.y -= e.y,
            this.z -= e.z,
            this)
        }
    }, {
        key: "subScalar",
        value: function(e) {
            return this.x -= e,
            this.y -= e,
            this.z -= e,
            this
        }
    }, {
        key: "subVectors",
        value: function(e, t) {
            return this.x = e.x - t.x,
            this.y = e.y - t.y,
            this.z = e.z - t.z,
            this
        }
    }, {
        key: "multiply",
        value: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),
            this.multiplyVectors(e, t)) : (this.x *= e.x,
            this.y *= e.y,
            this.z *= e.z,
            this)
        }
    }, {
        key: "multiplyScalar",
        value: function(e) {
            return this.x *= e,
            this.y *= e,
            this.z *= e,
            this
        }
    }, {
        key: "multiplyVectors",
        value: function(e, t) {
            return this.x = e.x * t.x,
            this.y = e.y * t.y,
            this.z = e.z * t.z,
            this
        }
    }, {
        key: "applyEuler",
        value: function(e) {
            return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),
            this.applyQuaternion(_quaternion$4.setFromEuler(e))
        }
    }, {
        key: "applyAxisAngle",
        value: function(e, t) {
            return this.applyQuaternion(_quaternion$4.setFromAxisAngle(e, t))
        }
    }, {
        key: "applyMatrix3",
        value: function(e) {
            var t = this.x
              , r = this.y
              , i = this.z
              , n = e.elements;
            return this.x = n[0] * t + n[3] * r + n[6] * i,
            this.y = n[1] * t + n[4] * r + n[7] * i,
            this.z = n[2] * t + n[5] * r + n[8] * i,
            this
        }
    }, {
        key: "applyNormalMatrix",
        value: function(e) {
            return this.applyMatrix3(e).normalize()
        }
    }, {
        key: "applyMatrix4",
        value: function(e) {
            var t = this.x
              , r = this.y
              , i = this.z
              , n = e.elements
              , a = 1 / (n[3] * t + n[7] * r + n[11] * i + n[15]);
            return this.x = (n[0] * t + n[4] * r + n[8] * i + n[12]) * a,
            this.y = (n[1] * t + n[5] * r + n[9] * i + n[13]) * a,
            this.z = (n[2] * t + n[6] * r + n[10] * i + n[14]) * a,
            this
        }
    }, {
        key: "applyQuaternion",
        value: function(e) {
            var t = this.x
              , r = this.y
              , i = this.z
              , n = e.x
              , a = e.y
              , o = e.z
              , s = e.w
              , l = s * t + a * i - o * r
              , u = s * r + o * t - n * i
              , c = s * i + n * r - a * t
              , h = -n * t - a * r - o * i;
            return this.x = l * s + h * -n + u * -o - c * -a,
            this.y = u * s + h * -a + c * -n - l * -o,
            this.z = c * s + h * -o + l * -a - u * -n,
            this
        }
    }, {
        key: "project",
        value: function(e) {
            return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
        }
    }, {
        key: "unproject",
        value: function(e) {
            return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
        }
    }, {
        key: "transformDirection",
        value: function(e) {
            var t = this.x
              , r = this.y
              , i = this.z
              , n = e.elements;
            return this.x = n[0] * t + n[4] * r + n[8] * i,
            this.y = n[1] * t + n[5] * r + n[9] * i,
            this.z = n[2] * t + n[6] * r + n[10] * i,
            this.normalize()
        }
    }, {
        key: "divide",
        value: function(e) {
            return this.x /= e.x,
            this.y /= e.y,
            this.z /= e.z,
            this
        }
    }, {
        key: "divideScalar",
        value: function(e) {
            return this.multiplyScalar(1 / e)
        }
    }, {
        key: "min",
        value: function(e) {
            return this.x = Math.min(this.x, e.x),
            this.y = Math.min(this.y, e.y),
            this.z = Math.min(this.z, e.z),
            this
        }
    }, {
        key: "max",
        value: function(e) {
            return this.x = Math.max(this.x, e.x),
            this.y = Math.max(this.y, e.y),
            this.z = Math.max(this.z, e.z),
            this
        }
    }, {
        key: "clamp",
        value: function(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)),
            this.y = Math.max(e.y, Math.min(t.y, this.y)),
            this.z = Math.max(e.z, Math.min(t.z, this.z)),
            this
        }
    }, {
        key: "clampScalar",
        value: function(e, t) {
            return this.x = Math.max(e, Math.min(t, this.x)),
            this.y = Math.max(e, Math.min(t, this.y)),
            this.z = Math.max(e, Math.min(t, this.z)),
            this
        }
    }, {
        key: "clampLength",
        value: function(e, t) {
            var r = this.length();
            return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)))
        }
    }, {
        key: "floor",
        value: function() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this.z = Math.floor(this.z),
            this
        }
    }, {
        key: "ceil",
        value: function() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this.z = Math.ceil(this.z),
            this
        }
    }, {
        key: "round",
        value: function() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this.z = Math.round(this.z),
            this
        }
    }, {
        key: "roundToZero",
        value: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
            this
        }
    }, {
        key: "negate",
        value: function() {
            return this.x = -this.x,
            this.y = -this.y,
            this.z = -this.z,
            this
        }
    }, {
        key: "dot",
        value: function(e) {
            return this.x * e.x + this.y * e.y + this.z * e.z
        }
    }, {
        key: "lengthSq",
        value: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z
        }
    }, {
        key: "length",
        value: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        }
    }, {
        key: "manhattanLength",
        value: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        }
    }, {
        key: "normalize",
        value: function() {
            return this.divideScalar(this.length() || 1)
        }
    }, {
        key: "setLength",
        value: function(e) {
            return this.normalize().multiplyScalar(e)
        }
    }, {
        key: "lerp",
        value: function(e, t) {
            return this.x += (e.x - this.x) * t,
            this.y += (e.y - this.y) * t,
            this.z += (e.z - this.z) * t,
            this
        }
    }, {
        key: "lerpVectors",
        value: function(e, t, r) {
            return this.x = e.x + (t.x - e.x) * r,
            this.y = e.y + (t.y - e.y) * r,
            this.z = e.z + (t.z - e.z) * r,
            this
        }
    }, {
        key: "cross",
        value: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),
            this.crossVectors(e, t)) : this.crossVectors(this, e)
        }
    }, {
        key: "crossVectors",
        value: function(e, t) {
            var r = e.x
              , i = e.y
              , n = e.z
              , a = t.x
              , o = t.y
              , s = t.z;
            return this.x = i * s - n * o,
            this.y = n * a - r * s,
            this.z = r * o - i * a,
            this
        }
    }, {
        key: "projectOnVector",
        value: function(e) {
            var t = e.lengthSq();
            if (0 === t)
                return this.set(0, 0, 0);
            var r = e.dot(this) / t;
            return this.copy(e).multiplyScalar(r)
        }
    }, {
        key: "projectOnPlane",
        value: function(e) {
            return _vector$c.copy(this).projectOnVector(e),
            this.sub(_vector$c)
        }
    }, {
        key: "reflect",
        value: function(e) {
            return this.sub(_vector$c.copy(e).multiplyScalar(2 * this.dot(e)))
        }
    }, {
        key: "angleTo",
        value: function(e) {
            var t = Math.sqrt(this.lengthSq() * e.lengthSq());
            if (0 === t)
                return Math.PI / 2;
            var r = this.dot(e) / t;
            return Math.acos(clamp(r, -1, 1))
        }
    }, {
        key: "distanceTo",
        value: function(e) {
            return Math.sqrt(this.distanceToSquared(e))
        }
    }, {
        key: "distanceToSquared",
        value: function(e) {
            var t = this.x - e.x
              , r = this.y - e.y
              , i = this.z - e.z;
            return t * t + r * r + i * i
        }
    }, {
        key: "manhattanDistanceTo",
        value: function(e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
        }
    }, {
        key: "setFromSpherical",
        value: function(e) {
            return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
        }
    }, {
        key: "setFromSphericalCoords",
        value: function(e, t, r) {
            var i = Math.sin(t) * e;
            return this.x = i * Math.sin(r),
            this.y = Math.cos(t) * e,
            this.z = i * Math.cos(r),
            this
        }
    }, {
        key: "setFromCylindrical",
        value: function(e) {
            return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
        }
    }, {
        key: "setFromCylindricalCoords",
        value: function(e, t, r) {
            return this.x = e * Math.sin(t),
            this.y = r,
            this.z = e * Math.cos(t),
            this
        }
    }, {
        key: "setFromMatrixPosition",
        value: function(e) {
            var t = e.elements;
            return this.x = t[12],
            this.y = t[13],
            this.z = t[14],
            this
        }
    }, {
        key: "setFromMatrixScale",
        value: function(e) {
            var t = this.setFromMatrixColumn(e, 0).length()
              , r = this.setFromMatrixColumn(e, 1).length()
              , i = this.setFromMatrixColumn(e, 2).length();
            return this.x = t,
            this.y = r,
            this.z = i,
            this
        }
    }, {
        key: "setFromMatrixColumn",
        value: function(e, t) {
            return this.fromArray(e.elements, 4 * t)
        }
    }, {
        key: "setFromMatrix3Column",
        value: function(e, t) {
            return this.fromArray(e.elements, 3 * t)
        }
    }, {
        key: "setFromEuler",
        value: function(e) {
            return this.x = e._x,
            this.y = e._y,
            this.z = e._z,
            this
        }
    }, {
        key: "equals",
        value: function(e) {
            return e.x === this.x && e.y === this.y && e.z === this.z
        }
    }, {
        key: "fromArray",
        value: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
            return this.x = e[t],
            this.y = e[t + 1],
            this.z = e[t + 2],
            this
        }
    }, {
        key: "toArray",
        value: function() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
              , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
            return e[t] = this.x,
            e[t + 1] = this.y,
            e[t + 2] = this.z,
            e
        }
    }, {
        key: "fromBufferAttribute",
        value: function(e, t, r) {
            return void 0 !== r && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),
            this.x = e.getX(t),
            this.y = e.getY(t),
            this.z = e.getZ(t),
            this
        }
    }, {
        key: "random",
        value: function() {
            return this.x = Math.random(),
            this.y = Math.random(),
            this.z = Math.random(),
            this
        }
    }, {
        key: "randomDirection",
        value: function() {
            var e = 2 * (Math.random() - .5)
              , t = Math.random() * Math.PI * 2
              , r = Math.sqrt(1 - Math.pow(e, 2));
            return this.x = r * Math.cos(t),
            this.y = r * Math.sin(t),
            this.z = e,
            this
        }
    }, {
        key: Symbol.iterator,
        value: _regeneratorRuntime().mark((function e() {
            return _regeneratorRuntime().wrap((function(e) {
                for (; ; )
                    switch (e.prev = e.next) {
                    case 0:
                        return e.next = 2,
                        this.x;
                    case 2:
                        return e.next = 4,
                        this.y;
                    case 4:
                        return e.next = 6,
                        this.z;
                    case 6:
                    case "end":
                        return e.stop()
                    }
            }
            ), e, this)
        }
        ))
    }]),
    t
}();
Vector3.prototype.isVector3 = !0;
var _vector$c = new Vector3
  , _quaternion$4 = new Quaternion
  , Box3 = function() {
    function e() {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Vector3(1 / 0,1 / 0,1 / 0)
          , r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Vector3(-1 / 0,-1 / 0,-1 / 0);
        _classCallCheck(this, e),
        this.min = t,
        this.max = r
    }
    return _createClass(e, [{
        key: "set",
        value: function(e, t) {
            return this.min.copy(e),
            this.max.copy(t),
            this
        }
    }, {
        key: "setFromArray",
        value: function(e) {
            for (var t = 1 / 0, r = 1 / 0, i = 1 / 0, n = -1 / 0, a = -1 / 0, o = -1 / 0, s = 0, l = e.length; s < l; s += 3) {
                var u = e[s]
                  , c = e[s + 1]
                  , h = e[s + 2];
                u < t && (t = u),
                c < r && (r = c),
                h < i && (i = h),
                u > n && (n = u),
                c > a && (a = c),
                h > o && (o = h)
            }
            return this.min.set(t, r, i),
            this.max.set(n, a, o),
            this
        }
    }, {
        key: "setFromBufferAttribute",
        value: function(e) {
            for (var t = 1 / 0, r = 1 / 0, i = 1 / 0, n = -1 / 0, a = -1 / 0, o = -1 / 0, s = 0, l = e.count; s < l; s++) {
                var u = e.getX(s)
                  , c = e.getY(s)
                  , h = e.getZ(s);
                u < t && (t = u),
                c < r && (r = c),
                h < i && (i = h),
                u > n && (n = u),
                c > a && (a = c),
                h > o && (o = h)
            }
            return this.min.set(t, r, i),
            this.max.set(n, a, o),
            this
        }
    }, {
        key: "setFromPoints",
        value: function(e) {
            this.makeEmpty();
            for (var t = 0, r = e.length; t < r; t++)
                this.expandByPoint(e[t]);
            return this
        }
    }, {
        key: "setFromCenterAndSize",
        value: function(e, t) {
            var r = _vector$b.copy(t).multiplyScalar(.5);
            return this.min.copy(e).sub(r),
            this.max.copy(e).add(r),
            this
        }
    }, {
        key: "setFromObject",
        value: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            return this.makeEmpty(),
            this.expandByObject(e, t)
        }
    }, {
        key: "clone",
        value: function() {
            return (new this.constructor).copy(this)
        }
    }, {
        key: "copy",
        value: function(e) {
            return this.min.copy(e.min),
            this.max.copy(e.max),
            this
        }
    }, {
        key: "makeEmpty",
        value: function() {
            return this.min.x = this.min.y = this.min.z = 1 / 0,
            this.max.x = this.max.y = this.max.z = -1 / 0,
            this
        }
    }, {
        key: "isEmpty",
        value: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        }
    }, {
        key: "getCenter",
        value: function(e) {
            return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
        }
    }, {
        key: "getSize",
        value: function(e) {
            return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
        }
    }, {
        key: "expandByPoint",
        value: function(e) {
            return this.min.min(e),
            this.max.max(e),
            this
        }
    }, {
        key: "expandByVector",
        value: function(e) {
            return this.min.sub(e),
            this.max.add(e),
            this
        }
    }, {
        key: "expandByScalar",
        value: function(e) {
            return this.min.addScalar(-e),
            this.max.addScalar(e),
            this
        }
    }, {
        key: "expandByObject",
        value: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            e.updateWorldMatrix(!1, !1);
            var r = e.geometry;
            if (void 0 !== r)
                if (t && null != r.attributes && void 0 !== r.attributes.position)
                    for (var i = r.attributes.position, n = 0, a = i.count; n < a; n++)
                        _vector$b.fromBufferAttribute(i, n).applyMatrix4(e.matrixWorld),
                        this.expandByPoint(_vector$b);
                else
                    null === r.boundingBox && r.computeBoundingBox(),
                    _box$3.copy(r.boundingBox),
                    _box$3.applyMatrix4(e.matrixWorld),
                    this.union(_box$3);
            for (var o = e.children, s = 0, l = o.length; s < l; s++)
                this.expandByObject(o[s], t);
            return this
        }
    }, {
        key: "containsPoint",
        value: function(e) {
            return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
        }
    }, {
        key: "containsBox",
        value: function(e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
        }
    }, {
        key: "getParameter",
        value: function(e, t) {
            return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
        }
    }, {
        key: "intersectsBox",
        value: function(e) {
            return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
        }
    }, {
        key: "intersectsSphere",
        value: function(e) {
            return this.clampPoint(e.center, _vector$b),
            _vector$b.distanceToSquared(e.center) <= e.radius * e.radius
        }
    }, {
        key: "intersectsPlane",
        value: function(e) {
            var t, r;
            return e.normal.x > 0 ? (t = e.normal.x * this.min.x,
            r = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x,
            r = e.normal.x * this.min.x),
            e.normal.y > 0 ? (t += e.normal.y * this.min.y,
            r += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y,
            r += e.normal.y * this.min.y),
            e.normal.z > 0 ? (t += e.normal.z * this.min.z,
            r += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z,
            r += e.normal.z * this.min.z),
            t <= -e.constant && r >= -e.constant
        }
    }, {
        key: "intersectsTriangle",
        value: function(e) {
            if (this.isEmpty())
                return !1;
            this.getCenter(_center),
            _extents.subVectors(this.max, _center),
            _v0$2.subVectors(e.a, _center),
            _v1$7.subVectors(e.b, _center),
            _v2$3.subVectors(e.c, _center),
            _f0.subVectors(_v1$7, _v0$2),
            _f1.subVectors(_v2$3, _v1$7),
            _f2.subVectors(_v0$2, _v2$3);
            var t = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];
            return !!satForAxes(t, _v0$2, _v1$7, _v2$3, _extents) && !!satForAxes(t = [1, 0, 0, 0, 1, 0, 0, 0, 1], _v0$2, _v1$7, _v2$3, _extents) && (_triangleNormal.crossVectors(_f0, _f1),
            satForAxes(t = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z], _v0$2, _v1$7, _v2$3, _extents))
        }
    }, {
        key: "clampPoint",
        value: function(e, t) {
            return t.copy(e).clamp(this.min, this.max)
        }
    }, {
        key: "distanceToPoint",
        value: function(e) {
            return _vector$b.copy(e).clamp(this.min, this.max).sub(e).length()
        }
    }, {
        key: "getBoundingSphere",
        value: function(e) {
            return this.getCenter(e.center),
            e.radius = .5 * this.getSize(_vector$b).length(),
            e
        }
    }, {
        key: "intersect",
        value: function(e) {
            return this.min.max(e.min),
            this.max.min(e.max),
            this.isEmpty() && this.makeEmpty(),
            this
        }
    }, {
        key: "union",
        value: function(e) {
            return this.min.min(e.min),
            this.max.max(e.max),
            this
        }
    }, {
        key: "applyMatrix4",
        value: function(e) {
            return this.isEmpty() || (_points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
            _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
            _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
            _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
            _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
            _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
            _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
            _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
            this.setFromPoints(_points)),
            this
        }
    }, {
        key: "translate",
        value: function(e) {
            return this.min.add(e),
            this.max.add(e),
            this
        }
    }, {
        key: "equals",
        value: function(e) {
            return e.min.equals(this.min) && e.max.equals(this.max)
        }
    }]),
    e
}();
Box3.prototype.isBox3 = !0;
var _points = [new Vector3, new Vector3, new Vector3, new Vector3, new Vector3, new Vector3, new Vector3, new Vector3]
  , _vector$b = new Vector3
  , _box$3 = new Box3
  , _v0$2 = new Vector3
  , _v1$7 = new Vector3
  , _v2$3 = new Vector3
  , _f0 = new Vector3
  , _f1 = new Vector3
  , _f2 = new Vector3
  , _center = new Vector3
  , _extents = new Vector3
  , _triangleNormal = new Vector3
  , _testAxis = new Vector3;
function satForAxes(e, t, r, i, n) {
    for (var a = 0, o = e.length - 3; a <= o; a += 3) {
        _testAxis.fromArray(e, a);
        var s = n.x * Math.abs(_testAxis.x) + n.y * Math.abs(_testAxis.y) + n.z * Math.abs(_testAxis.z)
          , l = t.dot(_testAxis)
          , u = r.dot(_testAxis)
          , c = i.dot(_testAxis);
        if (Math.max(-Math.max(l, u, c), Math.min(l, u, c)) > s)
            return !1
    }
    return !0
}
var _box$2 = new Box3
  , _v1$6 = new Vector3
  , _toFarthestPoint = new Vector3
  , _toPoint = new Vector3
  , Sphere = function() {
    function e() {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Vector3
          , r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1;
        _classCallCheck(this, e),
        this.center = t,
        this.radius = r
    }
    return _createClass(e, [{
        key: "set",
        value: function(e, t) {
            return this.center.copy(e),
            this.radius = t,
            this
        }
    }, {
        key: "setFromPoints",
        value: function(e, t) {
            var r = this.center;
            void 0 !== t ? r.copy(t) : _box$2.setFromPoints(e).getCenter(r);
            for (var i = 0, n = 0, a = e.length; n < a; n++)
                i = Math.max(i, r.distanceToSquared(e[n]));
            return this.radius = Math.sqrt(i),
            this
        }
    }, {
        key: "copy",
        value: function(e) {
            return this.center.copy(e.center),
            this.radius = e.radius,
            this
        }
    }, {
        key: "isEmpty",
        value: function() {
            return this.radius < 0
        }
    }, {
        key: "makeEmpty",
        value: function() {
            return this.center.set(0, 0, 0),
            this.radius = -1,
            this
        }
    }, {
        key: "containsPoint",
        value: function(e) {
            return e.distanceToSquared(this.center) <= this.radius * this.radius
        }
    }, {
        key: "distanceToPoint",
        value: function(e) {
            return e.distanceTo(this.center) - this.radius
        }
    }, {
        key: "intersectsSphere",
        value: function(e) {
            var t = this.radius + e.radius;
            return e.center.distanceToSquared(this.center) <= t * t
        }
    }, {
        key: "intersectsBox",
        value: function(e) {
            return e.intersectsSphere(this)
        }
    }, {
        key: "intersectsPlane",
        value: function(e) {
            return Math.abs(e.distanceToPoint(this.center)) <= this.radius
        }
    }, {
        key: "clampPoint",
        value: function(e, t) {
            var r = this.center.distanceToSquared(e);
            return t.copy(e),
            r > this.radius * this.radius && (t.sub(this.center).normalize(),
            t.multiplyScalar(this.radius).add(this.center)),
            t
        }
    }, {
        key: "getBoundingBox",
        value: function(e) {
            return this.isEmpty() ? (e.makeEmpty(),
            e) : (e.set(this.center, this.center),
            e.expandByScalar(this.radius),
            e)
        }
    }, {
        key: "applyMatrix4",
        value: function(e) {
            return this.center.applyMatrix4(e),
            this.radius = this.radius * e.getMaxScaleOnAxis(),
            this
        }
    }, {
        key: "translate",
        value: function(e) {
            return this.center.add(e),
            this
        }
    }, {
        key: "expandByPoint",
        value: function(e) {
            _toPoint.subVectors(e, this.center);
            var t = _toPoint.lengthSq();
            if (t > this.radius * this.radius) {
                var r = Math.sqrt(t)
                  , i = .5 * (r - this.radius);
                this.center.add(_toPoint.multiplyScalar(i / r)),
                this.radius += i
            }
            return this
        }
    }, {
        key: "union",
        value: function(e) {
            return !0 === this.center.equals(e.center) ? _toFarthestPoint.set(0, 0, 1).multiplyScalar(e.radius) : _toFarthestPoint.subVectors(e.center, this.center).normalize().multiplyScalar(e.radius),
            this.expandByPoint(_v1$6.copy(e.center).add(_toFarthestPoint)),
            this.expandByPoint(_v1$6.copy(e.center).sub(_toFarthestPoint)),
            this
        }
    }, {
        key: "equals",
        value: function(e) {
            return e.center.equals(this.center) && e.radius === this.radius
        }
    }, {
        key: "clone",
        value: function() {
            return (new this.constructor).copy(this)
        }
    }]),
    e
}()
  , _vector$a = new Vector3
  , _segCenter = new Vector3
  , _segDir = new Vector3
  , _diff = new Vector3
  , _edge1 = new Vector3
  , _edge2 = new Vector3
  , _normal$1 = new Vector3
  , Ray = function() {
    function e() {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Vector3
          , r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Vector3(0,0,-1);
        _classCallCheck(this, e),
        this.origin = t,
        this.direction = r
    }
    return _createClass(e, [{
        key: "set",
        value: function(e, t) {
            return this.origin.copy(e),
            this.direction.copy(t),
            this
        }
    }, {
        key: "copy",
        value: function(e) {
            return this.origin.copy(e.origin),
            this.direction.copy(e.direction),
            this
        }
    }, {
        key: "at",
        value: function(e, t) {
            return t.copy(this.direction).multiplyScalar(e).add(this.origin)
        }
    }, {
        key: "lookAt",
        value: function(e) {
            return this.direction.copy(e).sub(this.origin).normalize(),
            this
        }
    }, {
        key: "recast",
        value: function(e) {
            return this.origin.copy(this.at(e, _vector$a)),
            this
        }
    }, {
        key: "closestPointToPoint",
        value: function(e, t) {
            t.subVectors(e, this.origin);
            var r = t.dot(this.direction);
            return r < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(r).add(this.origin)
        }
    }, {
        key: "distanceToPoint",
        value: function(e) {
            return Math.sqrt(this.distanceSqToPoint(e))
        }
    }, {
        key: "distanceSqToPoint",
        value: function(e) {
            var t = _vector$a.subVectors(e, this.origin).dot(this.direction);
            return t < 0 ? this.origin.distanceToSquared(e) : (_vector$a.copy(this.direction).multiplyScalar(t).add(this.origin),
            _vector$a.distanceToSquared(e))
        }
    }, {
        key: "distanceSqToSegment",
        value: function(e, t, r, i) {
            _segCenter.copy(e).add(t).multiplyScalar(.5),
            _segDir.copy(t).sub(e).normalize(),
            _diff.copy(this.origin).sub(_segCenter);
            var n, a, o, s, l = .5 * e.distanceTo(t), u = -this.direction.dot(_segDir), c = _diff.dot(this.direction), h = -_diff.dot(_segDir), d = _diff.lengthSq(), p = Math.abs(1 - u * u);
            if (p > 0)
                if (a = u * c - h,
                s = l * p,
                (n = u * h - c) >= 0)
                    if (a >= -s)
                        if (a <= s) {
                            var f = 1 / p;
                            o = (n *= f) * (n + u * (a *= f) + 2 * c) + a * (u * n + a + 2 * h) + d
                        } else
                            a = l,
                            o = -(n = Math.max(0, -(u * a + c))) * n + a * (a + 2 * h) + d;
                    else
                        a = -l,
                        o = -(n = Math.max(0, -(u * a + c))) * n + a * (a + 2 * h) + d;
                else
                    a <= -s ? o = -(n = Math.max(0, -(-u * l + c))) * n + (a = n > 0 ? -l : Math.min(Math.max(-l, -h), l)) * (a + 2 * h) + d : a <= s ? (n = 0,
                    o = (a = Math.min(Math.max(-l, -h), l)) * (a + 2 * h) + d) : o = -(n = Math.max(0, -(u * l + c))) * n + (a = n > 0 ? l : Math.min(Math.max(-l, -h), l)) * (a + 2 * h) + d;
            else
                a = u > 0 ? -l : l,
                o = -(n = Math.max(0, -(u * a + c))) * n + a * (a + 2 * h) + d;
            return r && r.copy(this.direction).multiplyScalar(n).add(this.origin),
            i && i.copy(_segDir).multiplyScalar(a).add(_segCenter),
            o
        }
    }, {
        key: "intersectSphere",
        value: function(e, t) {
            _vector$a.subVectors(e.center, this.origin);
            var r = _vector$a.dot(this.direction)
              , i = _vector$a.dot(_vector$a) - r * r
              , n = e.radius * e.radius;
            if (i > n)
                return null;
            var a = Math.sqrt(n - i)
              , o = r - a
              , s = r + a;
            return o < 0 && s < 0 ? null : o < 0 ? this.at(s, t) : this.at(o, t)
        }
    }, {
        key: "intersectsSphere",
        value: function(e) {
            return this.distanceSqToPoint(e.center) <= e.radius * e.radius
        }
    }, {
        key: "distanceToPlane",
        value: function(e) {
            var t = e.normal.dot(this.direction);
            if (0 === t)
                return 0 === e.distanceToPoint(this.origin) ? 0 : null;
            var r = -(this.origin.dot(e.normal) + e.constant) / t;
            return r >= 0 ? r : null
        }
    }, {
        key: "intersectPlane",
        value: function(e, t) {
            var r = this.distanceToPlane(e);
            return null === r ? null : this.at(r, t)
        }
    }, {
        key: "intersectsPlane",
        value: function(e) {
            var t = e.distanceToPoint(this.origin);
            return 0 === t || e.normal.dot(this.direction) * t < 0
        }
    }, {
        key: "intersectBox",
        value: function(e, t) {
            var r, i, n, a, o, s, l = 1 / this.direction.x, u = 1 / this.direction.y, c = 1 / this.direction.z, h = this.origin;
            return l >= 0 ? (r = (e.min.x - h.x) * l,
            i = (e.max.x - h.x) * l) : (r = (e.max.x - h.x) * l,
            i = (e.min.x - h.x) * l),
            u >= 0 ? (n = (e.min.y - h.y) * u,
            a = (e.max.y - h.y) * u) : (n = (e.max.y - h.y) * u,
            a = (e.min.y - h.y) * u),
            r > a || n > i ? null : ((n > r || r != r) && (r = n),
            (a < i || i != i) && (i = a),
            c >= 0 ? (o = (e.min.z - h.z) * c,
            s = (e.max.z - h.z) * c) : (o = (e.max.z - h.z) * c,
            s = (e.min.z - h.z) * c),
            r > s || o > i ? null : ((o > r || r != r) && (r = o),
            (s < i || i != i) && (i = s),
            i < 0 ? null : this.at(r >= 0 ? r : i, t)))
        }
    }, {
        key: "intersectsBox",
        value: function(e) {
            return null !== this.intersectBox(e, _vector$a)
        }
    }, {
        key: "intersectTriangle",
        value: function(e, t, r, i, n) {
            _edge1.subVectors(t, e),
            _edge2.subVectors(r, e),
            _normal$1.crossVectors(_edge1, _edge2);
            var a, o = this.direction.dot(_normal$1);
            if (o > 0) {
                if (i)
                    return null;
                a = 1
            } else {
                if (!(o < 0))
                    return null;
                a = -1,
                o = -o
            }
            _diff.subVectors(this.origin, e);
            var s = a * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
            if (s < 0)
                return null;
            var l = a * this.direction.dot(_edge1.cross(_diff));
            if (l < 0)
                return null;
            if (s + l > o)
                return null;
            var u = -a * _diff.dot(_normal$1);
            return u < 0 ? null : this.at(u / o, n)
        }
    }, {
        key: "applyMatrix4",
        value: function(e) {
            return this.origin.applyMatrix4(e),
            this.direction.transformDirection(e),
            this
        }
    }, {
        key: "equals",
        value: function(e) {
            return e.origin.equals(this.origin) && e.direction.equals(this.direction)
        }
    }, {
        key: "clone",
        value: function() {
            return (new this.constructor).copy(this)
        }
    }]),
    e
}()
  , Matrix4 = function() {
    function e() {
        _classCallCheck(this, e),
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
    }
    return _createClass(e, [{
        key: "set",
        value: function(e, t, r, i, n, a, o, s, l, u, c, h, d, p, f, m) {
            var v = this.elements;
            return v[0] = e,
            v[4] = t,
            v[8] = r,
            v[12] = i,
            v[1] = n,
            v[5] = a,
            v[9] = o,
            v[13] = s,
            v[2] = l,
            v[6] = u,
            v[10] = c,
            v[14] = h,
            v[3] = d,
            v[7] = p,
            v[11] = f,
            v[15] = m,
            this
        }
    }, {
        key: "identity",
        value: function() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
            this
        }
    }, {
        key: "clone",
        value: function() {
            return (new e).fromArray(this.elements)
        }
    }, {
        key: "copy",
        value: function(e) {
            var t = this.elements
              , r = e.elements;
            return t[0] = r[0],
            t[1] = r[1],
            t[2] = r[2],
            t[3] = r[3],
            t[4] = r[4],
            t[5] = r[5],
            t[6] = r[6],
            t[7] = r[7],
            t[8] = r[8],
            t[9] = r[9],
            t[10] = r[10],
            t[11] = r[11],
            t[12] = r[12],
            t[13] = r[13],
            t[14] = r[14],
            t[15] = r[15],
            this
        }
    }, {
        key: "copyPosition",
        value: function(e) {
            var t = this.elements
              , r = e.elements;
            return t[12] = r[12],
            t[13] = r[13],
            t[14] = r[14],
            this
        }
    }, {
        key: "setFromMatrix3",
        value: function(e) {
            var t = e.elements;
            return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1),
            this
        }
    }, {
        key: "extractBasis",
        value: function(e, t, r) {
            return e.setFromMatrixColumn(this, 0),
            t.setFromMatrixColumn(this, 1),
            r.setFromMatrixColumn(this, 2),
            this
        }
    }, {
        key: "makeBasis",
        value: function(e, t, r) {
            return this.set(e.x, t.x, r.x, 0, e.y, t.y, r.y, 0, e.z, t.z, r.z, 0, 0, 0, 0, 1),
            this
        }
    }, {
        key: "extractRotation",
        value: function(e) {
            var t = this.elements
              , r = e.elements
              , i = 1 / _v1$5.setFromMatrixColumn(e, 0).length()
              , n = 1 / _v1$5.setFromMatrixColumn(e, 1).length()
              , a = 1 / _v1$5.setFromMatrixColumn(e, 2).length();
            return t[0] = r[0] * i,
            t[1] = r[1] * i,
            t[2] = r[2] * i,
            t[3] = 0,
            t[4] = r[4] * n,
            t[5] = r[5] * n,
            t[6] = r[6] * n,
            t[7] = 0,
            t[8] = r[8] * a,
            t[9] = r[9] * a,
            t[10] = r[10] * a,
            t[11] = 0,
            t[12] = 0,
            t[13] = 0,
            t[14] = 0,
            t[15] = 1,
            this
        }
    }, {
        key: "makeRotationFromEuler",
        value: function(e) {
            e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            var t = this.elements
              , r = e.x
              , i = e.y
              , n = e.z
              , a = Math.cos(r)
              , o = Math.sin(r)
              , s = Math.cos(i)
              , l = Math.sin(i)
              , u = Math.cos(n)
              , c = Math.sin(n);
            if ("XYZ" === e.order) {
                var h = a * u
                  , d = a * c
                  , p = o * u
                  , f = o * c;
                t[0] = s * u,
                t[4] = -s * c,
                t[8] = l,
                t[1] = d + p * l,
                t[5] = h - f * l,
                t[9] = -o * s,
                t[2] = f - h * l,
                t[6] = p + d * l,
                t[10] = a * s
            } else if ("YXZ" === e.order) {
                var m = s * u
                  , v = s * c
                  , g = l * u
                  , _ = l * c;
                t[0] = m + _ * o,
                t[4] = g * o - v,
                t[8] = a * l,
                t[1] = a * c,
                t[5] = a * u,
                t[9] = -o,
                t[2] = v * o - g,
                t[6] = _ + m * o,
                t[10] = a * s
            } else if ("ZXY" === e.order) {
                var y = s * u
                  , x = s * c
                  , b = l * u
                  , S = l * c;
                t[0] = y - S * o,
                t[4] = -a * c,
                t[8] = b + x * o,
                t[1] = x + b * o,
                t[5] = a * u,
                t[9] = S - y * o,
                t[2] = -a * l,
                t[6] = o,
                t[10] = a * s
            } else if ("ZYX" === e.order) {
                var w = a * u
                  , M = a * c
                  , T = o * u
                  , C = o * c;
                t[0] = s * u,
                t[4] = T * l - M,
                t[8] = w * l + C,
                t[1] = s * c,
                t[5] = C * l + w,
                t[9] = M * l - T,
                t[2] = -l,
                t[6] = o * s,
                t[10] = a * s
            } else if ("YZX" === e.order) {
                var E = a * s
                  , P = a * l
                  , A = o * s
                  , k = o * l;
                t[0] = s * u,
                t[4] = k - E * c,
                t[8] = A * c + P,
                t[1] = c,
                t[5] = a * u,
                t[9] = -o * u,
                t[2] = -l * u,
                t[6] = P * c + A,
                t[10] = E - k * c
            } else if ("XZY" === e.order) {
                var L = a * s
                  , R = a * l
                  , D = o * s
                  , I = o * l;
                t[0] = s * u,
                t[4] = -c,
                t[8] = l * u,
                t[1] = L * c + I,
                t[5] = a * u,
                t[9] = R * c - D,
                t[2] = D * c - R,
                t[6] = o * u,
                t[10] = I * c + L
            }
            return t[3] = 0,
            t[7] = 0,
            t[11] = 0,
            t[12] = 0,
            t[13] = 0,
            t[14] = 0,
            t[15] = 1,
            this
        }
    }, {
        key: "makeRotationFromQuaternion",
        value: function(e) {
            return this.compose(_zero, e, _one)
        }
    }, {
        key: "lookAt",
        value: function(e, t, r) {
            var i = this.elements;
            return _z.subVectors(e, t),
            0 === _z.lengthSq() && (_z.z = 1),
            _z.normalize(),
            _x.crossVectors(r, _z),
            0 === _x.lengthSq() && (1 === Math.abs(r.z) ? _z.x += 1e-4 : _z.z += 1e-4,
            _z.normalize(),
            _x.crossVectors(r, _z)),
            _x.normalize(),
            _y.crossVectors(_z, _x),
            i[0] = _x.x,
            i[4] = _y.x,
            i[8] = _z.x,
            i[1] = _x.y,
            i[5] = _y.y,
            i[9] = _z.y,
            i[2] = _x.z,
            i[6] = _y.z,
            i[10] = _z.z,
            this
        }
    }, {
        key: "multiply",
        value: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),
            this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e)
        }
    }, {
        key: "premultiply",
        value: function(e) {
            return this.multiplyMatrices(e, this)
        }
    }, {
        key: "multiplyMatrices",
        value: function(e, t) {
            var r = e.elements
              , i = t.elements
              , n = this.elements
              , a = r[0]
              , o = r[4]
              , s = r[8]
              , l = r[12]
              , u = r[1]
              , c = r[5]
              , h = r[9]
              , d = r[13]
              , p = r[2]
              , f = r[6]
              , m = r[10]
              , v = r[14]
              , g = r[3]
              , _ = r[7]
              , y = r[11]
              , x = r[15]
              , b = i[0]
              , S = i[4]
              , w = i[8]
              , M = i[12]
              , T = i[1]
              , C = i[5]
              , E = i[9]
              , P = i[13]
              , A = i[2]
              , k = i[6]
              , L = i[10]
              , R = i[14]
              , D = i[3]
              , I = i[7]
              , O = i[11]
              , N = i[15];
            return n[0] = a * b + o * T + s * A + l * D,
            n[4] = a * S + o * C + s * k + l * I,
            n[8] = a * w + o * E + s * L + l * O,
            n[12] = a * M + o * P + s * R + l * N,
            n[1] = u * b + c * T + h * A + d * D,
            n[5] = u * S + c * C + h * k + d * I,
            n[9] = u * w + c * E + h * L + d * O,
            n[13] = u * M + c * P + h * R + d * N,
            n[2] = p * b + f * T + m * A + v * D,
            n[6] = p * S + f * C + m * k + v * I,
            n[10] = p * w + f * E + m * L + v * O,
            n[14] = p * M + f * P + m * R + v * N,
            n[3] = g * b + _ * T + y * A + x * D,
            n[7] = g * S + _ * C + y * k + x * I,
            n[11] = g * w + _ * E + y * L + x * O,
            n[15] = g * M + _ * P + y * R + x * N,
            this
        }
    }, {
        key: "multiplyScalar",
        value: function(e) {
            var t = this.elements;
            return t[0] *= e,
            t[4] *= e,
            t[8] *= e,
            t[12] *= e,
            t[1] *= e,
            t[5] *= e,
            t[9] *= e,
            t[13] *= e,
            t[2] *= e,
            t[6] *= e,
            t[10] *= e,
            t[14] *= e,
            t[3] *= e,
            t[7] *= e,
            t[11] *= e,
            t[15] *= e,
            this
        }
    }, {
        key: "determinant",
        value: function() {
            var e = this.elements
              , t = e[0]
              , r = e[4]
              , i = e[8]
              , n = e[12]
              , a = e[1]
              , o = e[5]
              , s = e[9]
              , l = e[13]
              , u = e[2]
              , c = e[6]
              , h = e[10]
              , d = e[14];
            return e[3] * (+n * s * c - i * l * c - n * o * h + r * l * h + i * o * d - r * s * d) + e[7] * (+t * s * d - t * l * h + n * a * h - i * a * d + i * l * u - n * s * u) + e[11] * (+t * l * c - t * o * d - n * a * c + r * a * d + n * o * u - r * l * u) + e[15] * (-i * o * u - t * s * c + t * o * h + i * a * c - r * a * h + r * s * u)
        }
    }, {
        key: "transpose",
        value: function() {
            var e, t = this.elements;
            return e = t[1],
            t[1] = t[4],
            t[4] = e,
            e = t[2],
            t[2] = t[8],
            t[8] = e,
            e = t[6],
            t[6] = t[9],
            t[9] = e,
            e = t[3],
            t[3] = t[12],
            t[12] = e,
            e = t[7],
            t[7] = t[13],
            t[13] = e,
            e = t[11],
            t[11] = t[14],
            t[14] = e,
            this
        }
    }, {
        key: "setPosition",
        value: function(e, t, r) {
            var i = this.elements;
            return e.isVector3 ? (i[12] = e.x,
            i[13] = e.y,
            i[14] = e.z) : (i[12] = e,
            i[13] = t,
            i[14] = r),
            this
        }
    }, {
        key: "invert",
        value: function() {
            var e = this.elements
              , t = e[0]
              , r = e[1]
              , i = e[2]
              , n = e[3]
              , a = e[4]
              , o = e[5]
              , s = e[6]
              , l = e[7]
              , u = e[8]
              , c = e[9]
              , h = e[10]
              , d = e[11]
              , p = e[12]
              , f = e[13]
              , m = e[14]
              , v = e[15]
              , g = c * m * l - f * h * l + f * s * d - o * m * d - c * s * v + o * h * v
              , _ = p * h * l - u * m * l - p * s * d + a * m * d + u * s * v - a * h * v
              , y = u * f * l - p * c * l + p * o * d - a * f * d - u * o * v + a * c * v
              , x = p * c * s - u * f * s - p * o * h + a * f * h + u * o * m - a * c * m
              , b = t * g + r * _ + i * y + n * x;
            if (0 === b)
                return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            var S = 1 / b;
            return e[0] = g * S,
            e[1] = (f * h * n - c * m * n - f * i * d + r * m * d + c * i * v - r * h * v) * S,
            e[2] = (o * m * n - f * s * n + f * i * l - r * m * l - o * i * v + r * s * v) * S,
            e[3] = (c * s * n - o * h * n - c * i * l + r * h * l + o * i * d - r * s * d) * S,
            e[4] = _ * S,
            e[5] = (u * m * n - p * h * n + p * i * d - t * m * d - u * i * v + t * h * v) * S,
            e[6] = (p * s * n - a * m * n - p * i * l + t * m * l + a * i * v - t * s * v) * S,
            e[7] = (a * h * n - u * s * n + u * i * l - t * h * l - a * i * d + t * s * d) * S,
            e[8] = y * S,
            e[9] = (p * c * n - u * f * n - p * r * d + t * f * d + u * r * v - t * c * v) * S,
            e[10] = (a * f * n - p * o * n + p * r * l - t * f * l - a * r * v + t * o * v) * S,
            e[11] = (u * o * n - a * c * n - u * r * l + t * c * l + a * r * d - t * o * d) * S,
            e[12] = x * S,
            e[13] = (u * f * i - p * c * i + p * r * h - t * f * h - u * r * m + t * c * m) * S,
            e[14] = (p * o * i - a * f * i - p * r * s + t * f * s + a * r * m - t * o * m) * S,
            e[15] = (a * c * i - u * o * i + u * r * s - t * c * s - a * r * h + t * o * h) * S,
            this
        }
    }, {
        key: "scale",
        value: function(e) {
            var t = this.elements
              , r = e.x
              , i = e.y
              , n = e.z;
            return t[0] *= r,
            t[4] *= i,
            t[8] *= n,
            t[1] *= r,
            t[5] *= i,
            t[9] *= n,
            t[2] *= r,
            t[6] *= i,
            t[10] *= n,
            t[3] *= r,
            t[7] *= i,
            t[11] *= n,
            this
        }
    }, {
        key: "getMaxScaleOnAxis",
        value: function() {
            var e = this.elements
              , t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]
              , r = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]
              , i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
            return Math.sqrt(Math.max(t, r, i))
        }
    }, {
        key: "makeTranslation",
        value: function(e, t, r) {
            return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, r, 0, 0, 0, 1),
            this
        }
    }, {
        key: "makeRotationX",
        value: function(e) {
            var t = Math.cos(e)
              , r = Math.sin(e);
            return this.set(1, 0, 0, 0, 0, t, -r, 0, 0, r, t, 0, 0, 0, 0, 1),
            this
        }
    }, {
        key: "makeRotationY",
        value: function(e) {
            var t = Math.cos(e)
              , r = Math.sin(e);
            return this.set(t, 0, r, 0, 0, 1, 0, 0, -r, 0, t, 0, 0, 0, 0, 1),
            this
        }
    }, {
        key: "makeRotationZ",
        value: function(e) {
            var t = Math.cos(e)
              , r = Math.sin(e);
            return this.set(t, -r, 0, 0, r, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
            this
        }
    }, {
        key: "makeRotationAxis",
        value: function(e, t) {
            var r = Math.cos(t)
              , i = Math.sin(t)
              , n = 1 - r
              , a = e.x
              , o = e.y
              , s = e.z
              , l = n * a
              , u = n * o;
            return this.set(l * a + r, l * o - i * s, l * s + i * o, 0, l * o + i * s, u * o + r, u * s - i * a, 0, l * s - i * o, u * s + i * a, n * s * s + r, 0, 0, 0, 0, 1),
            this
        }
    }, {
        key: "makeScale",
        value: function(e, t, r) {
            return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, r, 0, 0, 0, 0, 1),
            this
        }
    }, {
        key: "makeShear",
        value: function(e, t, r, i, n, a) {
            return this.set(1, r, n, 0, e, 1, a, 0, t, i, 1, 0, 0, 0, 0, 1),
            this
        }
    }, {
        key: "compose",
        value: function(e, t, r) {
            var i = this.elements
              , n = t._x
              , a = t._y
              , o = t._z
              , s = t._w
              , l = n + n
              , u = a + a
              , c = o + o
              , h = n * l
              , d = n * u
              , p = n * c
              , f = a * u
              , m = a * c
              , v = o * c
              , g = s * l
              , _ = s * u
              , y = s * c
              , x = r.x
              , b = r.y
              , S = r.z;
            return i[0] = (1 - (f + v)) * x,
            i[1] = (d + y) * x,
            i[2] = (p - _) * x,
            i[3] = 0,
            i[4] = (d - y) * b,
            i[5] = (1 - (h + v)) * b,
            i[6] = (m + g) * b,
            i[7] = 0,
            i[8] = (p + _) * S,
            i[9] = (m - g) * S,
            i[10] = (1 - (h + f)) * S,
            i[11] = 0,
            i[12] = e.x,
            i[13] = e.y,
            i[14] = e.z,
            i[15] = 1,
            this
        }
    }, {
        key: "decompose",
        value: function(e, t, r) {
            var i = this.elements
              , n = _v1$5.set(i[0], i[1], i[2]).length()
              , a = _v1$5.set(i[4], i[5], i[6]).length()
              , o = _v1$5.set(i[8], i[9], i[10]).length();
            this.determinant() < 0 && (n = -n),
            e.x = i[12],
            e.y = i[13],
            e.z = i[14],
            _m1$2.copy(this);
            var s = 1 / n
              , l = 1 / a
              , u = 1 / o;
            return _m1$2.elements[0] *= s,
            _m1$2.elements[1] *= s,
            _m1$2.elements[2] *= s,
            _m1$2.elements[4] *= l,
            _m1$2.elements[5] *= l,
            _m1$2.elements[6] *= l,
            _m1$2.elements[8] *= u,
            _m1$2.elements[9] *= u,
            _m1$2.elements[10] *= u,
            t.setFromRotationMatrix(_m1$2),
            r.x = n,
            r.y = a,
            r.z = o,
            this
        }
    }, {
        key: "makePerspective",
        value: function(e, t, r, i, n, a) {
            void 0 === a && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
            var o = this.elements
              , s = 2 * n / (t - e)
              , l = 2 * n / (r - i)
              , u = (t + e) / (t - e)
              , c = (r + i) / (r - i)
              , h = -(a + n) / (a - n)
              , d = -2 * a * n / (a - n);
            return o[0] = s,
            o[4] = 0,
            o[8] = u,
            o[12] = 0,
            o[1] = 0,
            o[5] = l,
            o[9] = c,
            o[13] = 0,
            o[2] = 0,
            o[6] = 0,
            o[10] = h,
            o[14] = d,
            o[3] = 0,
            o[7] = 0,
            o[11] = -1,
            o[15] = 0,
            this
        }
    }, {
        key: "makeOrthographic",
        value: function(e, t, r, i, n, a) {
            var o = this.elements
              , s = 1 / (t - e)
              , l = 1 / (r - i)
              , u = 1 / (a - n)
              , c = (t + e) * s
              , h = (r + i) * l
              , d = (a + n) * u;
            return o[0] = 2 * s,
            o[4] = 0,
            o[8] = 0,
            o[12] = -c,
            o[1] = 0,
            o[5] = 2 * l,
            o[9] = 0,
            o[13] = -h,
            o[2] = 0,
            o[6] = 0,
            o[10] = -2 * u,
            o[14] = -d,
            o[3] = 0,
            o[7] = 0,
            o[11] = 0,
            o[15] = 1,
            this
        }
    }, {
        key: "equals",
        value: function(e) {
            for (var t = this.elements, r = e.elements, i = 0; i < 16; i++)
                if (t[i] !== r[i])
                    return !1;
            return !0
        }
    }, {
        key: "fromArray",
        value: function(e) {
            for (var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, r = 0; r < 16; r++)
                this.elements[r] = e[r + t];
            return this
        }
    }, {
        key: "toArray",
        value: function() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
              , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
              , r = this.elements;
            return e[t] = r[0],
            e[t + 1] = r[1],
            e[t + 2] = r[2],
            e[t + 3] = r[3],
            e[t + 4] = r[4],
            e[t + 5] = r[5],
            e[t + 6] = r[6],
            e[t + 7] = r[7],
            e[t + 8] = r[8],
            e[t + 9] = r[9],
            e[t + 10] = r[10],
            e[t + 11] = r[11],
            e[t + 12] = r[12],
            e[t + 13] = r[13],
            e[t + 14] = r[14],
            e[t + 15] = r[15],
            e
        }
    }]),
    e
}();
Matrix4.prototype.isMatrix4 = !0;
var _v1$5 = new Vector3
  , _m1$2 = new Matrix4
  , _zero = new Vector3(0,0,0)
  , _one = new Vector3(1,1,1)
  , _x = new Vector3
  , _y = new Vector3
  , _z = new Vector3
  , _matrix$1 = new Matrix4
  , _quaternion$3 = new Quaternion
  , Euler = function() {
    function e() {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
          , r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
          , i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0
          , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : e.DefaultOrder;
        _classCallCheck(this, e),
        this._x = t,
        this._y = r,
        this._z = i,
        this._order = n
    }
    return _createClass(e, [{
        key: "x",
        get: function() {
            return this._x
        },
        set: function(e) {
            this._x = e,
            this._onChangeCallback()
        }
    }, {
        key: "y",
        get: function() {
            return this._y
        },
        set: function(e) {
            this._y = e,
            this._onChangeCallback()
        }
    }, {
        key: "z",
        get: function() {
            return this._z
        },
        set: function(e) {
            this._z = e,
            this._onChangeCallback()
        }
    }, {
        key: "order",
        get: function() {
            return this._order
        },
        set: function(e) {
            this._order = e,
            this._onChangeCallback()
        }
    }, {
        key: "set",
        value: function(e, t, r) {
            var i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : this._order;
            return this._x = e,
            this._y = t,
            this._z = r,
            this._order = i,
            this._onChangeCallback(),
            this
        }
    }, {
        key: "clone",
        value: function() {
            return new this.constructor(this._x,this._y,this._z,this._order)
        }
    }, {
        key: "copy",
        value: function(e) {
            return this._x = e._x,
            this._y = e._y,
            this._z = e._z,
            this._order = e._order,
            this._onChangeCallback(),
            this
        }
    }, {
        key: "setFromRotationMatrix",
        value: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._order
              , r = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]
              , i = e.elements
              , n = i[0]
              , a = i[4]
              , o = i[8]
              , s = i[1]
              , l = i[5]
              , u = i[9]
              , c = i[2]
              , h = i[6]
              , d = i[10];
            switch (t) {
            case "XYZ":
                this._y = Math.asin(clamp(o, -1, 1)),
                Math.abs(o) < .9999999 ? (this._x = Math.atan2(-u, d),
                this._z = Math.atan2(-a, n)) : (this._x = Math.atan2(h, l),
                this._z = 0);
                break;
            case "YXZ":
                this._x = Math.asin(-clamp(u, -1, 1)),
                Math.abs(u) < .9999999 ? (this._y = Math.atan2(o, d),
                this._z = Math.atan2(s, l)) : (this._y = Math.atan2(-c, n),
                this._z = 0);
                break;
            case "ZXY":
                this._x = Math.asin(clamp(h, -1, 1)),
                Math.abs(h) < .9999999 ? (this._y = Math.atan2(-c, d),
                this._z = Math.atan2(-a, l)) : (this._y = 0,
                this._z = Math.atan2(s, n));
                break;
            case "ZYX":
                this._y = Math.asin(-clamp(c, -1, 1)),
                Math.abs(c) < .9999999 ? (this._x = Math.atan2(h, d),
                this._z = Math.atan2(s, n)) : (this._x = 0,
                this._z = Math.atan2(-a, l));
                break;
            case "YZX":
                this._z = Math.asin(clamp(s, -1, 1)),
                Math.abs(s) < .9999999 ? (this._x = Math.atan2(-u, l),
                this._y = Math.atan2(-c, n)) : (this._x = 0,
                this._y = Math.atan2(o, d));
                break;
            case "XZY":
                this._z = Math.asin(-clamp(a, -1, 1)),
                Math.abs(a) < .9999999 ? (this._x = Math.atan2(h, l),
                this._y = Math.atan2(o, n)) : (this._x = Math.atan2(-u, d),
                this._y = 0);
                break;
            default:
                console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
            }
            return this._order = t,
            !0 === r && this._onChangeCallback(),
            this
        }
    }, {
        key: "setFromQuaternion",
        value: function(e, t, r) {
            return _matrix$1.makeRotationFromQuaternion(e),
            this.setFromRotationMatrix(_matrix$1, t, r)
        }
    }, {
        key: "setFromVector3",
        value: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._order;
            return this.set(e.x, e.y, e.z, t)
        }
    }, {
        key: "reorder",
        value: function(e) {
            return _quaternion$3.setFromEuler(this),
            this.setFromQuaternion(_quaternion$3, e)
        }
    }, {
        key: "equals",
        value: function(e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
        }
    }, {
        key: "fromArray",
        value: function(e) {
            return this._x = e[0],
            this._y = e[1],
            this._z = e[2],
            void 0 !== e[3] && (this._order = e[3]),
            this._onChangeCallback(),
            this
        }
    }, {
        key: "toArray",
        value: function() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
              , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
            return e[t] = this._x,
            e[t + 1] = this._y,
            e[t + 2] = this._z,
            e[t + 3] = this._order,
            e
        }
    }, {
        key: "_onChange",
        value: function(e) {
            return this._onChangeCallback = e,
            this
        }
    }, {
        key: "_onChangeCallback",
        value: function() {}
    }]),
    e
}();
Euler.prototype.isEuler = !0,
Euler.DefaultOrder = "XYZ",
Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
var Layers = function() {
    function e() {
        _classCallCheck(this, e),
        this.mask = 1
    }
    return _createClass(e, [{
        key: "set",
        value: function(e) {
            this.mask = (1 << e | 0) >>> 0
        }
    }, {
        key: "enable",
        value: function(e) {
            this.mask |= 1 << e | 0
        }
    }, {
        key: "enableAll",
        value: function() {
            this.mask = -1
        }
    }, {
        key: "toggle",
        value: function(e) {
            this.mask ^= 1 << e | 0
        }
    }, {
        key: "disable",
        value: function(e) {
            this.mask &= ~(1 << e | 0)
        }
    }, {
        key: "disableAll",
        value: function() {
            this.mask = 0
        }
    }, {
        key: "test",
        value: function(e) {
            return 0 != (this.mask & e.mask)
        }
    }, {
        key: "isEnabled",
        value: function(e) {
            return 0 != (this.mask & (1 << e | 0))
        }
    }]),
    e
}()
  , _object3DId = 0
  , _v1$4 = new Vector3
  , _q1$1 = new Quaternion
  , _m1$1 = new Matrix4
  , _target = new Vector3
  , _position$3 = new Vector3
  , _scale$2 = new Vector3
  , _quaternion$2 = new Quaternion
  , _xAxis = new Vector3(1,0,0)
  , _yAxis = new Vector3(0,1,0)
  , _zAxis = new Vector3(0,0,1)
  , _addedEvent = {
    type: "added"
}
  , _removedEvent = {
    type: "removed"
}
  , Object3D = function(e) {
    _inherits(r, EventDispatcher);
    var t = _createSuper(r);
    function r() {
        var e;
        _classCallCheck(this, r),
        e = t.call(this),
        Object.defineProperty(_assertThisInitialized(e), "id", {
            value: _object3DId++
        }),
        e.uuid = generateUUID(),
        e.name = "",
        e.type = "Object3D",
        e.parent = null,
        e.children = [],
        e.up = r.DefaultUp.clone();
        var i = new Vector3
          , n = new Euler
          , a = new Quaternion
          , o = new Vector3(1,1,1);
        return n._onChange((function() {
            a.setFromEuler(n, !1)
        }
        )),
        a._onChange((function() {
            n.setFromQuaternion(a, void 0, !1)
        }
        )),
        Object.defineProperties(_assertThisInitialized(e), {
            position: {
                configurable: !0,
                enumerable: !0,
                value: i
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: n
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: a
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: o
            },
            modelViewMatrix: {
                value: new Matrix4
            },
            normalMatrix: {
                value: new Matrix3
            }
        }),
        e.matrix = new Matrix4,
        e.matrixWorld = new Matrix4,
        e.matrixAutoUpdate = r.DefaultMatrixAutoUpdate,
        e.matrixWorldNeedsUpdate = !1,
        e.layers = new Layers,
        e.visible = !0,
        e.castShadow = !1,
        e.receiveShadow = !1,
        e.frustumCulled = !0,
        e.renderOrder = 0,
        e.animations = [],
        e.userData = {},
        e
    }
    return _createClass(r, [{
        key: "onBeforeRender",
        value: function() {}
    }, {
        key: "onAfterRender",
        value: function() {}
    }, {
        key: "applyMatrix4",
        value: function(e) {
            this.matrixAutoUpdate && this.updateMatrix(),
            this.matrix.premultiply(e),
            this.matrix.decompose(this.position, this.quaternion, this.scale)
        }
    }, {
        key: "applyQuaternion",
        value: function(e) {
            return this.quaternion.premultiply(e),
            this
        }
    }, {
        key: "setRotationFromAxisAngle",
        value: function(e, t) {
            this.quaternion.setFromAxisAngle(e, t)
        }
    }, {
        key: "setRotationFromEuler",
        value: function(e) {
            this.quaternion.setFromEuler(e, !0)
        }
    }, {
        key: "setRotationFromMatrix",
        value: function(e) {
            this.quaternion.setFromRotationMatrix(e)
        }
    }, {
        key: "setRotationFromQuaternion",
        value: function(e) {
            this.quaternion.copy(e)
        }
    }, {
        key: "rotateOnAxis",
        value: function(e, t) {
            return _q1$1.setFromAxisAngle(e, t),
            this.quaternion.multiply(_q1$1),
            this
        }
    }, {
        key: "rotateOnWorldAxis",
        value: function(e, t) {
            return _q1$1.setFromAxisAngle(e, t),
            this.quaternion.premultiply(_q1$1),
            this
        }
    }, {
        key: "rotateX",
        value: function(e) {
            return this.rotateOnAxis(_xAxis, e)
        }
    }, {
        key: "rotateY",
        value: function(e) {
            return this.rotateOnAxis(_yAxis, e)
        }
    }, {
        key: "rotateZ",
        value: function(e) {
            return this.rotateOnAxis(_zAxis, e)
        }
    }, {
        key: "translateOnAxis",
        value: function(e, t) {
            return _v1$4.copy(e).applyQuaternion(this.quaternion),
            this.position.add(_v1$4.multiplyScalar(t)),
            this
        }
    }, {
        key: "translateX",
        value: function(e) {
            return this.translateOnAxis(_xAxis, e)
        }
    }, {
        key: "translateY",
        value: function(e) {
            return this.translateOnAxis(_yAxis, e)
        }
    }, {
        key: "translateZ",
        value: function(e) {
            return this.translateOnAxis(_zAxis, e)
        }
    }, {
        key: "localToWorld",
        value: function(e) {
            return e.applyMatrix4(this.matrixWorld)
        }
    }, {
        key: "worldToLocal",
        value: function(e) {
            return e.applyMatrix4(_m1$1.copy(this.matrixWorld).invert())
        }
    }, {
        key: "lookAt",
        value: function(e, t, r) {
            e.isVector3 ? _target.copy(e) : _target.set(e, t, r);
            var i = this.parent;
            this.updateWorldMatrix(!0, !1),
            _position$3.setFromMatrixPosition(this.matrixWorld),
            this.isCamera || this.isLight ? _m1$1.lookAt(_position$3, _target, this.up) : _m1$1.lookAt(_target, _position$3, this.up),
            this.quaternion.setFromRotationMatrix(_m1$1),
            i && (_m1$1.extractRotation(i.matrixWorld),
            _q1$1.setFromRotationMatrix(_m1$1),
            this.quaternion.premultiply(_q1$1.invert()))
        }
    }, {
        key: "add",
        value: function(e) {
            if (arguments.length > 1) {
                for (var t = 0; t < arguments.length; t++)
                    this.add(arguments[t]);
                return this
            }
            return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e),
            this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e),
            e.parent = this,
            this.children.push(e),
            e.dispatchEvent(_addedEvent)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e),
            this)
        }
    }, {
        key: "remove",
        value: function(e) {
            if (arguments.length > 1) {
                for (var t = 0; t < arguments.length; t++)
                    this.remove(arguments[t]);
                return this
            }
            var r = this.children.indexOf(e);
            return -1 !== r && (e.parent = null,
            this.children.splice(r, 1),
            e.dispatchEvent(_removedEvent)),
            this
        }
    }, {
        key: "removeFromParent",
        value: function() {
            var e = this.parent;
            return null !== e && e.remove(this),
            this
        }
    }, {
        key: "clear",
        value: function() {
            for (var e = 0; e < this.children.length; e++) {
                var t = this.children[e];
                t.parent = null,
                t.dispatchEvent(_removedEvent)
            }
            return this.children.length = 0,
            this
        }
    }, {
        key: "attach",
        value: function(e) {
            return this.updateWorldMatrix(!0, !1),
            _m1$1.copy(this.matrixWorld).invert(),
            null !== e.parent && (e.parent.updateWorldMatrix(!0, !1),
            _m1$1.multiply(e.parent.matrixWorld)),
            e.applyMatrix4(_m1$1),
            this.add(e),
            e.updateWorldMatrix(!1, !0),
            this
        }
    }, {
        key: "getObjectById",
        value: function(e) {
            return this.getObjectByProperty("id", e)
        }
    }, {
        key: "getObjectByName",
        value: function(e) {
            return this.getObjectByProperty("name", e)
        }
    }, {
        key: "getObjectByProperty",
        value: function(e, t) {
            if (this[e] === t)
                return this;
            for (var r = 0, i = this.children.length; r < i; r++) {
                var n = this.children[r].getObjectByProperty(e, t);
                if (void 0 !== n)
                    return n
            }
        }
    }, {
        key: "getWorldPosition",
        value: function(e) {
            return this.updateWorldMatrix(!0, !1),
            e.setFromMatrixPosition(this.matrixWorld)
        }
    }, {
        key: "getWorldQuaternion",
        value: function(e) {
            return this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(_position$3, e, _scale$2),
            e
        }
    }, {
        key: "getWorldScale",
        value: function(e) {
            return this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(_position$3, _quaternion$2, e),
            e
        }
    }, {
        key: "getWorldDirection",
        value: function(e) {
            this.updateWorldMatrix(!0, !1);
            var t = this.matrixWorld.elements;
            return e.set(t[8], t[9], t[10]).normalize()
        }
    }, {
        key: "raycast",
        value: function() {}
    }, {
        key: "traverse",
        value: function(e) {
            e(this);
            for (var t = this.children, r = 0, i = t.length; r < i; r++)
                t[r].traverse(e)
        }
    }, {
        key: "traverseVisible",
        value: function(e) {
            if (!1 !== this.visible) {
                e(this);
                for (var t = this.children, r = 0, i = t.length; r < i; r++)
                    t[r].traverseVisible(e)
            }
        }
    }, {
        key: "traverseAncestors",
        value: function(e) {
            var t = this.parent;
            null !== t && (e(t),
            t.traverseAncestors(e))
        }
    }, {
        key: "updateMatrix",
        value: function() {
            this.matrix.compose(this.position, this.quaternion, this.scale),
            this.matrixWorldNeedsUpdate = !0
        }
    }, {
        key: "updateMatrixWorld",
        value: function(e) {
            this.matrixAutoUpdate && this.updateMatrix(),
            (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
            this.matrixWorldNeedsUpdate = !1,
            e = !0);
            for (var t = this.children, r = 0, i = t.length; r < i; r++)
                t[r].updateMatrixWorld(e)
        }
    }, {
        key: "updateWorldMatrix",
        value: function(e, t) {
            var r = this.parent;
            if (!0 === e && null !== r && r.updateWorldMatrix(!0, !1),
            this.matrixAutoUpdate && this.updateMatrix(),
            null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
            !0 === t)
                for (var i = this.children, n = 0, a = i.length; n < a; n++)
                    i[n].updateWorldMatrix(!1, !0)
        }
    }, {
        key: "toJSON",
        value: function(e) {
            var t = void 0 === e || "string" == typeof e
              , r = {};
            t && (e = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {},
                skeletons: {},
                animations: {},
                nodes: {}
            },
            r.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            var i = {};
            function n(t, r) {
                return void 0 === t[r.uuid] && (t[r.uuid] = r.toJSON(e)),
                r.uuid
            }
            if (i.uuid = this.uuid,
            i.type = this.type,
            "" !== this.name && (i.name = this.name),
            !0 === this.castShadow && (i.castShadow = !0),
            !0 === this.receiveShadow && (i.receiveShadow = !0),
            !1 === this.visible && (i.visible = !1),
            !1 === this.frustumCulled && (i.frustumCulled = !1),
            0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
            "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData),
            i.layers = this.layers.mask,
            i.matrix = this.matrix.toArray(),
            !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
            this.isInstancedMesh && (i.type = "InstancedMesh",
            i.count = this.count,
            i.instanceMatrix = this.instanceMatrix.toJSON(),
            null !== this.instanceColor && (i.instanceColor = this.instanceColor.toJSON())),
            this.isScene)
                this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)),
                this.environment && this.environment.isTexture && (i.environment = this.environment.toJSON(e).uuid);
            else if (this.isMesh || this.isLine || this.isPoints) {
                i.geometry = n(e.geometries, this.geometry);
                var a = this.geometry.parameters;
                if (void 0 !== a && void 0 !== a.shapes) {
                    var o = a.shapes;
                    if (Array.isArray(o))
                        for (var s = 0, l = o.length; s < l; s++) {
                            var u = o[s];
                            n(e.shapes, u)
                        }
                    else
                        n(e.shapes, o)
                }
            }
            if (this.isSkinnedMesh && (i.bindMode = this.bindMode,
            i.bindMatrix = this.bindMatrix.toArray(),
            void 0 !== this.skeleton && (n(e.skeletons, this.skeleton),
            i.skeleton = this.skeleton.uuid)),
            void 0 !== this.material)
                if (Array.isArray(this.material)) {
                    for (var c = [], h = 0, d = this.material.length; h < d; h++)
                        c.push(n(e.materials, this.material[h]));
                    i.material = c
                } else
                    i.material = n(e.materials, this.material);
            if (this.children.length > 0) {
                i.children = [];
                for (var p = 0; p < this.children.length; p++)
                    i.children.push(this.children[p].toJSON(e).object)
            }
            if (this.animations.length > 0) {
                i.animations = [];
                for (var f = 0; f < this.animations.length; f++) {
                    var m = this.animations[f];
                    i.animations.push(n(e.animations, m))
                }
            }
            if (t) {
                var v = M(e.geometries)
                  , g = M(e.materials)
                  , _ = M(e.textures)
                  , y = M(e.images)
                  , x = M(e.shapes)
                  , b = M(e.skeletons)
                  , S = M(e.animations)
                  , w = M(e.nodes);
                v.length > 0 && (r.geometries = v),
                g.length > 0 && (r.materials = g),
                _.length > 0 && (r.textures = _),
                y.length > 0 && (r.images = y),
                x.length > 0 && (r.shapes = x),
                b.length > 0 && (r.skeletons = b),
                S.length > 0 && (r.animations = S),
                w.length > 0 && (r.nodes = w)
            }
            return r.object = i,
            r;
            function M(e) {
                var t = [];
                for (var r in e) {
                    var i = e[r];
                    delete i.metadata,
                    t.push(i)
                }
                return t
            }
        }
    }, {
        key: "clone",
        value: function(e) {
            return (new this.constructor).copy(this, e)
        }
    }, {
        key: "copy",
        value: function(e) {
            var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            if (this.name = e.name,
            this.up.copy(e.up),
            this.position.copy(e.position),
            this.rotation.order = e.rotation.order,
            this.quaternion.copy(e.quaternion),
            this.scale.copy(e.scale),
            this.matrix.copy(e.matrix),
            this.matrixWorld.copy(e.matrixWorld),
            this.matrixAutoUpdate = e.matrixAutoUpdate,
            this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
            this.layers.mask = e.layers.mask,
            this.visible = e.visible,
            this.castShadow = e.castShadow,
            this.receiveShadow = e.receiveShadow,
            this.frustumCulled = e.frustumCulled,
            this.renderOrder = e.renderOrder,
            this.userData = JSON.parse(JSON.stringify(e.userData)),
            !0 === t)
                for (var r = 0; r < e.children.length; r++) {
                    var i = e.children[r];
                    this.add(i.clone())
                }
            return this
        }
    }]),
    r
}();
Object3D.DefaultUp = new Vector3(0,1,0),
Object3D.DefaultMatrixAutoUpdate = !0,
Object3D.prototype.isObject3D = !0;
var _v0$1 = new Vector3
  , _v1$3 = new Vector3
  , _v2$2 = new Vector3
  , _v3$1 = new Vector3
  , _vab = new Vector3
  , _vac = new Vector3
  , _vbc = new Vector3
  , _vap = new Vector3
  , _vbp = new Vector3
  , _vcp = new Vector3
  , Triangle = function() {
    function e() {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Vector3
          , r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Vector3
          , i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : new Vector3;
        _classCallCheck(this, e),
        this.a = t,
        this.b = r,
        this.c = i
    }
    return _createClass(e, [{
        key: "set",
        value: function(e, t, r) {
            return this.a.copy(e),
            this.b.copy(t),
            this.c.copy(r),
            this
        }
    }, {
        key: "setFromPointsAndIndices",
        value: function(e, t, r, i) {
            return this.a.copy(e[t]),
            this.b.copy(e[r]),
            this.c.copy(e[i]),
            this
        }
    }, {
        key: "setFromAttributeAndIndices",
        value: function(e, t, r, i) {
            return this.a.fromBufferAttribute(e, t),
            this.b.fromBufferAttribute(e, r),
            this.c.fromBufferAttribute(e, i),
            this
        }
    }, {
        key: "clone",
        value: function() {
            return (new this.constructor).copy(this)
        }
    }, {
        key: "copy",
        value: function(e) {
            return this.a.copy(e.a),
            this.b.copy(e.b),
            this.c.copy(e.c),
            this
        }
    }, {
        key: "getArea",
        value: function() {
            return _v0$1.subVectors(this.c, this.b),
            _v1$3.subVectors(this.a, this.b),
            .5 * _v0$1.cross(_v1$3).length()
        }
    }, {
        key: "getMidpoint",
        value: function(e) {
            return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        }
    }, {
        key: "getNormal",
        value: function(t) {
            return e.getNormal(this.a, this.b, this.c, t)
        }
    }, {
        key: "getPlane",
        value: function(e) {
            return e.setFromCoplanarPoints(this.a, this.b, this.c)
        }
    }, {
        key: "getBarycoord",
        value: function(t, r) {
            return e.getBarycoord(t, this.a, this.b, this.c, r)
        }
    }, {
        key: "getUV",
        value: function(t, r, i, n, a) {
            return e.getUV(t, this.a, this.b, this.c, r, i, n, a)
        }
    }, {
        key: "containsPoint",
        value: function(t) {
            return e.containsPoint(t, this.a, this.b, this.c)
        }
    }, {
        key: "isFrontFacing",
        value: function(t) {
            return e.isFrontFacing(this.a, this.b, this.c, t)
        }
    }, {
        key: "intersectsBox",
        value: function(e) {
            return e.intersectsTriangle(this)
        }
    }, {
        key: "closestPointToPoint",
        value: function(e, t) {
            var r, i, n = this.a, a = this.b, o = this.c;
            _vab.subVectors(a, n),
            _vac.subVectors(o, n),
            _vap.subVectors(e, n);
            var s = _vab.dot(_vap)
              , l = _vac.dot(_vap);
            if (s <= 0 && l <= 0)
                return t.copy(n);
            _vbp.subVectors(e, a);
            var u = _vab.dot(_vbp)
              , c = _vac.dot(_vbp);
            if (u >= 0 && c <= u)
                return t.copy(a);
            var h = s * c - u * l;
            if (h <= 0 && s >= 0 && u <= 0)
                return r = s / (s - u),
                t.copy(n).addScaledVector(_vab, r);
            _vcp.subVectors(e, o);
            var d = _vab.dot(_vcp)
              , p = _vac.dot(_vcp);
            if (p >= 0 && d <= p)
                return t.copy(o);
            var f = d * l - s * p;
            if (f <= 0 && l >= 0 && p <= 0)
                return i = l / (l - p),
                t.copy(n).addScaledVector(_vac, i);
            var m = u * p - d * c;
            if (m <= 0 && c - u >= 0 && d - p >= 0)
                return _vbc.subVectors(o, a),
                i = (c - u) / (c - u + (d - p)),
                t.copy(a).addScaledVector(_vbc, i);
            var v = 1 / (m + f + h);
            return r = f * v,
            i = h * v,
            t.copy(n).addScaledVector(_vab, r).addScaledVector(_vac, i)
        }
    }, {
        key: "equals",
        value: function(e) {
            return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
        }
    }], [{
        key: "getNormal",
        value: function(e, t, r, i) {
            i.subVectors(r, t),
            _v0$1.subVectors(e, t),
            i.cross(_v0$1);
            var n = i.lengthSq();
            return n > 0 ? i.multiplyScalar(1 / Math.sqrt(n)) : i.set(0, 0, 0)
        }
    }, {
        key: "getBarycoord",
        value: function(e, t, r, i, n) {
            _v0$1.subVectors(i, t),
            _v1$3.subVectors(r, t),
            _v2$2.subVectors(e, t);
            var a = _v0$1.dot(_v0$1)
              , o = _v0$1.dot(_v1$3)
              , s = _v0$1.dot(_v2$2)
              , l = _v1$3.dot(_v1$3)
              , u = _v1$3.dot(_v2$2)
              , c = a * l - o * o;
            if (0 === c)
                return n.set(-2, -1, -1);
            var h = 1 / c
              , d = (l * s - o * u) * h
              , p = (a * u - o * s) * h;
            return n.set(1 - d - p, p, d)
        }
    }, {
        key: "containsPoint",
        value: function(e, t, r, i) {
            return this.getBarycoord(e, t, r, i, _v3$1),
            _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1
        }
    }, {
        key: "getUV",
        value: function(e, t, r, i, n, a, o, s) {
            return this.getBarycoord(e, t, r, i, _v3$1),
            s.set(0, 0),
            s.addScaledVector(n, _v3$1.x),
            s.addScaledVector(a, _v3$1.y),
            s.addScaledVector(o, _v3$1.z),
            s
        }
    }, {
        key: "isFrontFacing",
        value: function(e, t, r, i) {
            return _v0$1.subVectors(r, t),
            _v1$3.subVectors(e, t),
            _v0$1.cross(_v1$3).dot(i) < 0
        }
    }]),
    e
}()
  , materialId = 0
  , Material = function(e) {
    _inherits(r, EventDispatcher);
    var t = _createSuper(r);
    function r() {
        var e;
        return _classCallCheck(this, r),
        e = t.call(this),
        Object.defineProperty(_assertThisInitialized(e), "id", {
            value: materialId++
        }),
        e.uuid = generateUUID(),
        e.name = "",
        e.type = "Material",
        e.fog = !0,
        e.blending = NormalBlending,
        e.side = FrontSide,
        e.vertexColors = !1,
        e.opacity = 1,
        e.transparent = !1,
        e.blendSrc = SrcAlphaFactor,
        e.blendDst = OneMinusSrcAlphaFactor,
        e.blendEquation = AddEquation,
        e.blendSrcAlpha = null,
        e.blendDstAlpha = null,
        e.blendEquationAlpha = null,
        e.depthFunc = LessEqualDepth,
        e.depthTest = !0,
        e.depthWrite = !0,
        e.stencilWriteMask = 255,
        e.stencilFunc = AlwaysStencilFunc,
        e.stencilRef = 0,
        e.stencilFuncMask = 255,
        e.stencilFail = KeepStencilOp,
        e.stencilZFail = KeepStencilOp,
        e.stencilZPass = KeepStencilOp,
        e.stencilWrite = !1,
        e.clippingPlanes = null,
        e.clipIntersection = !1,
        e.clipShadows = !1,
        e.shadowSide = null,
        e.colorWrite = !0,
        e.precision = null,
        e.polygonOffset = !1,
        e.polygonOffsetFactor = 0,
        e.polygonOffsetUnits = 0,
        e.dithering = !1,
        e.alphaToCoverage = !1,
        e.premultipliedAlpha = !1,
        e.visible = !0,
        e.toneMapped = !0,
        e.userData = {},
        e.version = 0,
        e._alphaTest = 0,
        e
    }
    return _createClass(r, [{
        key: "alphaTest",
        get: function() {
            return this._alphaTest
        },
        set: function(e) {
            this._alphaTest > 0 != e > 0 && this.version++,
            this._alphaTest = e
        }
    }, {
        key: "onBuild",
        value: function() {}
    }, {
        key: "onBeforeRender",
        value: function() {}
    }, {
        key: "onBeforeCompile",
        value: function() {}
    }, {
        key: "customProgramCacheKey",
        value: function() {
            return this.onBeforeCompile.toString()
        }
    }, {
        key: "setValues",
        value: function(e) {
            if (void 0 !== e)
                for (var t in e) {
                    var r = e[t];
                    if (void 0 !== r)
                        if ("shading" !== t) {
                            var i = this[t];
                            void 0 !== i ? i && i.isColor ? i.set(r) : i && i.isVector3 && r && r.isVector3 ? i.copy(r) : this[t] = r : console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.")
                        } else
                            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
                            this.flatShading = r === FlatShading;
                    else
                        console.warn("THREE.Material: '" + t + "' parameter is undefined.")
                }
        }
    }, {
        key: "toJSON",
        value: function(e) {
            var t = void 0 === e || "string" == typeof e;
            t && (e = {
                textures: {},
                images: {}
            });
            var r = {
                metadata: {
                    version: 4.5,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };
            function i(e) {
                var t = [];
                for (var r in e) {
                    var i = e[r];
                    delete i.metadata,
                    t.push(i)
                }
                return t
            }
            if (r.uuid = this.uuid,
            r.type = this.type,
            "" !== this.name && (r.name = this.name),
            this.color && this.color.isColor && (r.color = this.color.getHex()),
            void 0 !== this.roughness && (r.roughness = this.roughness),
            void 0 !== this.metalness && (r.metalness = this.metalness),
            void 0 !== this.sheen && (r.sheen = this.sheen),
            this.sheenColor && this.sheenColor.isColor && (r.sheenColor = this.sheenColor.getHex()),
            void 0 !== this.sheenRoughness && (r.sheenRoughness = this.sheenRoughness),
            this.emissive && this.emissive.isColor && (r.emissive = this.emissive.getHex()),
            this.emissiveIntensity && 1 !== this.emissiveIntensity && (r.emissiveIntensity = this.emissiveIntensity),
            this.specular && this.specular.isColor && (r.specular = this.specular.getHex()),
            void 0 !== this.specularIntensity && (r.specularIntensity = this.specularIntensity),
            this.specularColor && this.specularColor.isColor && (r.specularColor = this.specularColor.getHex()),
            void 0 !== this.shininess && (r.shininess = this.shininess),
            void 0 !== this.clearcoat && (r.clearcoat = this.clearcoat),
            void 0 !== this.clearcoatRoughness && (r.clearcoatRoughness = this.clearcoatRoughness),
            this.clearcoatMap && this.clearcoatMap.isTexture && (r.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
            this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (r.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
            this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (r.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid,
            r.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
            this.map && this.map.isTexture && (r.map = this.map.toJSON(e).uuid),
            this.matcap && this.matcap.isTexture && (r.matcap = this.matcap.toJSON(e).uuid),
            this.alphaMap && this.alphaMap.isTexture && (r.alphaMap = this.alphaMap.toJSON(e).uuid),
            this.lightMap && this.lightMap.isTexture && (r.lightMap = this.lightMap.toJSON(e).uuid,
            r.lightMapIntensity = this.lightMapIntensity),
            this.aoMap && this.aoMap.isTexture && (r.aoMap = this.aoMap.toJSON(e).uuid,
            r.aoMapIntensity = this.aoMapIntensity),
            this.bumpMap && this.bumpMap.isTexture && (r.bumpMap = this.bumpMap.toJSON(e).uuid,
            r.bumpScale = this.bumpScale),
            this.normalMap && this.normalMap.isTexture && (r.normalMap = this.normalMap.toJSON(e).uuid,
            r.normalMapType = this.normalMapType,
            r.normalScale = this.normalScale.toArray()),
            this.displacementMap && this.displacementMap.isTexture && (r.displacementMap = this.displacementMap.toJSON(e).uuid,
            r.displacementScale = this.displacementScale,
            r.displacementBias = this.displacementBias),
            this.roughnessMap && this.roughnessMap.isTexture && (r.roughnessMap = this.roughnessMap.toJSON(e).uuid),
            this.metalnessMap && this.metalnessMap.isTexture && (r.metalnessMap = this.metalnessMap.toJSON(e).uuid),
            this.emissiveMap && this.emissiveMap.isTexture && (r.emissiveMap = this.emissiveMap.toJSON(e).uuid),
            this.specularMap && this.specularMap.isTexture && (r.specularMap = this.specularMap.toJSON(e).uuid),
            this.specularIntensityMap && this.specularIntensityMap.isTexture && (r.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
            this.specularColorMap && this.specularColorMap.isTexture && (r.specularColorMap = this.specularColorMap.toJSON(e).uuid),
            this.envMap && this.envMap.isTexture && (r.envMap = this.envMap.toJSON(e).uuid,
            void 0 !== this.combine && (r.combine = this.combine)),
            void 0 !== this.envMapIntensity && (r.envMapIntensity = this.envMapIntensity),
            void 0 !== this.reflectivity && (r.reflectivity = this.reflectivity),
            void 0 !== this.refractionRatio && (r.refractionRatio = this.refractionRatio),
            this.gradientMap && this.gradientMap.isTexture && (r.gradientMap = this.gradientMap.toJSON(e).uuid),
            void 0 !== this.transmission && (r.transmission = this.transmission),
            this.transmissionMap && this.transmissionMap.isTexture && (r.transmissionMap = this.transmissionMap.toJSON(e).uuid),
            void 0 !== this.thickness && (r.thickness = this.thickness),
            this.thicknessMap && this.thicknessMap.isTexture && (r.thicknessMap = this.thicknessMap.toJSON(e).uuid),
            void 0 !== this.attenuationDistance && (r.attenuationDistance = this.attenuationDistance),
            void 0 !== this.attenuationColor && (r.attenuationColor = this.attenuationColor.getHex()),
            void 0 !== this.size && (r.size = this.size),
            null !== this.shadowSide && (r.shadowSide = this.shadowSide),
            void 0 !== this.sizeAttenuation && (r.sizeAttenuation = this.sizeAttenuation),
            this.blending !== NormalBlending && (r.blending = this.blending),
            this.side !== FrontSide && (r.side = this.side),
            this.vertexColors && (r.vertexColors = !0),
            this.opacity < 1 && (r.opacity = this.opacity),
            !0 === this.transparent && (r.transparent = this.transparent),
            r.depthFunc = this.depthFunc,
            r.depthTest = this.depthTest,
            r.depthWrite = this.depthWrite,
            r.colorWrite = this.colorWrite,
            r.stencilWrite = this.stencilWrite,
            r.stencilWriteMask = this.stencilWriteMask,
            r.stencilFunc = this.stencilFunc,
            r.stencilRef = this.stencilRef,
            r.stencilFuncMask = this.stencilFuncMask,
            r.stencilFail = this.stencilFail,
            r.stencilZFail = this.stencilZFail,
            r.stencilZPass = this.stencilZPass,
            void 0 !== this.rotation && 0 !== this.rotation && (r.rotation = this.rotation),
            !0 === this.polygonOffset && (r.polygonOffset = !0),
            0 !== this.polygonOffsetFactor && (r.polygonOffsetFactor = this.polygonOffsetFactor),
            0 !== this.polygonOffsetUnits && (r.polygonOffsetUnits = this.polygonOffsetUnits),
            void 0 !== this.linewidth && 1 !== this.linewidth && (r.linewidth = this.linewidth),
            void 0 !== this.dashSize && (r.dashSize = this.dashSize),
            void 0 !== this.gapSize && (r.gapSize = this.gapSize),
            void 0 !== this.scale && (r.scale = this.scale),
            !0 === this.dithering && (r.dithering = !0),
            this.alphaTest > 0 && (r.alphaTest = this.alphaTest),
            !0 === this.alphaToCoverage && (r.alphaToCoverage = this.alphaToCoverage),
            !0 === this.premultipliedAlpha && (r.premultipliedAlpha = this.premultipliedAlpha),
            !0 === this.wireframe && (r.wireframe = this.wireframe),
            this.wireframeLinewidth > 1 && (r.wireframeLinewidth = this.wireframeLinewidth),
            "round" !== this.wireframeLinecap && (r.wireframeLinecap = this.wireframeLinecap),
            "round" !== this.wireframeLinejoin && (r.wireframeLinejoin = this.wireframeLinejoin),
            !0 === this.flatShading && (r.flatShading = this.flatShading),
            !1 === this.visible && (r.visible = !1),
            !1 === this.toneMapped && (r.toneMapped = !1),
            "{}" !== JSON.stringify(this.userData) && (r.userData = this.userData),
            t) {
                var n = i(e.textures)
                  , a = i(e.images);
                n.length > 0 && (r.textures = n),
                a.length > 0 && (r.images = a)
            }
            return r
        }
    }, {
        key: "clone",
        value: function() {
            return (new this.constructor).copy(this)
        }
    }, {
        key: "copy",
        value: function(e) {
            this.name = e.name,
            this.fog = e.fog,
            this.blending = e.blending,
            this.side = e.side,
            this.vertexColors = e.vertexColors,
            this.opacity = e.opacity,
            this.transparent = e.transparent,
            this.blendSrc = e.blendSrc,
            this.blendDst = e.blendDst,
            this.blendEquation = e.blendEquation,
            this.blendSrcAlpha = e.blendSrcAlpha,
            this.blendDstAlpha = e.blendDstAlpha,
            this.blendEquationAlpha = e.blendEquationAlpha,
            this.depthFunc = e.depthFunc,
            this.depthTest = e.depthTest,
            this.depthWrite = e.depthWrite,
            this.stencilWriteMask = e.stencilWriteMask,
            this.stencilFunc = e.stencilFunc,
            this.stencilRef = e.stencilRef,
            this.stencilFuncMask = e.stencilFuncMask,
            this.stencilFail = e.stencilFail,
            this.stencilZFail = e.stencilZFail,
            this.stencilZPass = e.stencilZPass,
            this.stencilWrite = e.stencilWrite;
            var t = e.clippingPlanes
              , r = null;
            if (null !== t) {
                var i = t.length;
                r = new Array(i);
                for (var n = 0; n !== i; ++n)
                    r[n] = t[n].clone()
            }
            return this.clippingPlanes = r,
            this.clipIntersection = e.clipIntersection,
            this.clipShadows = e.clipShadows,
            this.shadowSide = e.shadowSide,
            this.colorWrite = e.colorWrite,
            this.precision = e.precision,
            this.polygonOffset = e.polygonOffset,
            this.polygonOffsetFactor = e.polygonOffsetFactor,
            this.polygonOffsetUnits = e.polygonOffsetUnits,
            this.dithering = e.dithering,
            this.alphaTest = e.alphaTest,
            this.alphaToCoverage = e.alphaToCoverage,
            this.premultipliedAlpha = e.premultipliedAlpha,
            this.visible = e.visible,
            this.toneMapped = e.toneMapped,
            this.userData = JSON.parse(JSON.stringify(e.userData)),
            this
        }
    }, {
        key: "dispose",
        value: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }, {
        key: "needsUpdate",
        set: function(e) {
            !0 === e && this.version++
        }
    }]),
    r
}();
Material.prototype.isMaterial = !0,
Material.fromType = function() {
    return null
}
;
var MeshBasicMaterial = function(e) {
    _inherits(r, Material);
    var t = _createSuper(r);
    function r(e) {
        var i;
        return _classCallCheck(this, r),
        (i = t.call(this)).type = "MeshBasicMaterial",
        i.color = new Color(16777215),
        i.map = null,
        i.lightMap = null,
        i.lightMapIntensity = 1,
        i.aoMap = null,
        i.aoMapIntensity = 1,
        i.specularMap = null,
        i.alphaMap = null,
        i.envMap = null,
        i.combine = MultiplyOperation,
        i.reflectivity = 1,
        i.refractionRatio = .98,
        i.wireframe = !1,
        i.wireframeLinewidth = 1,
        i.wireframeLinecap = "round",
        i.wireframeLinejoin = "round",
        i.setValues(e),
        i
    }
    return _createClass(r, [{
        key: "copy",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e),
            this.color.copy(e.color),
            this.map = e.map,
            this.lightMap = e.lightMap,
            this.lightMapIntensity = e.lightMapIntensity,
            this.aoMap = e.aoMap,
            this.aoMapIntensity = e.aoMapIntensity,
            this.specularMap = e.specularMap,
            this.alphaMap = e.alphaMap,
            this.envMap = e.envMap,
            this.combine = e.combine,
            this.reflectivity = e.reflectivity,
            this.refractionRatio = e.refractionRatio,
            this.wireframe = e.wireframe,
            this.wireframeLinewidth = e.wireframeLinewidth,
            this.wireframeLinecap = e.wireframeLinecap,
            this.wireframeLinejoin = e.wireframeLinejoin,
            this
        }
    }]),
    r
}();
MeshBasicMaterial.prototype.isMeshBasicMaterial = !0;
var _vector$9 = new Vector3
  , _vector2$1 = new Vector2
  , BufferAttribute = function() {
    function e(t, r, i) {
        if (_classCallCheck(this, e),
        Array.isArray(t))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.name = "",
        this.array = t,
        this.itemSize = r,
        this.count = void 0 !== t ? t.length / r : 0,
        this.normalized = !0 === i,
        this.usage = StaticDrawUsage,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.version = 0
    }
    return _createClass(e, [{
        key: "onUploadCallback",
        value: function() {}
    }, {
        key: "needsUpdate",
        set: function(e) {
            !0 === e && this.version++
        }
    }, {
        key: "setUsage",
        value: function(e) {
            return this.usage = e,
            this
        }
    }, {
        key: "copy",
        value: function(e) {
            return this.name = e.name,
            this.array = new e.array.constructor(e.array),
            this.itemSize = e.itemSize,
            this.count = e.count,
            this.normalized = e.normalized,
            this.usage = e.usage,
            this
        }
    }, {
        key: "copyAt",
        value: function(e, t, r) {
            e *= this.itemSize,
            r *= t.itemSize;
            for (var i = 0, n = this.itemSize; i < n; i++)
                this.array[e + i] = t.array[r + i];
            return this
        }
    }, {
        key: "copyArray",
        value: function(e) {
            return this.array.set(e),
            this
        }
    }, {
        key: "copyColorsArray",
        value: function(e) {
            for (var t = this.array, r = 0, i = 0, n = e.length; i < n; i++) {
                var a = e[i];
                void 0 === a && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i),
                a = new Color),
                t[r++] = a.r,
                t[r++] = a.g,
                t[r++] = a.b
            }
            return this
        }
    }, {
        key: "copyVector2sArray",
        value: function(e) {
            for (var t = this.array, r = 0, i = 0, n = e.length; i < n; i++) {
                var a = e[i];
                void 0 === a && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i),
                a = new Vector2),
                t[r++] = a.x,
                t[r++] = a.y
            }
            return this
        }
    }, {
        key: "copyVector3sArray",
        value: function(e) {
            for (var t = this.array, r = 0, i = 0, n = e.length; i < n; i++) {
                var a = e[i];
                void 0 === a && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i),
                a = new Vector3),
                t[r++] = a.x,
                t[r++] = a.y,
                t[r++] = a.z
            }
            return this
        }
    }, {
        key: "copyVector4sArray",
        value: function(e) {
            for (var t = this.array, r = 0, i = 0, n = e.length; i < n; i++) {
                var a = e[i];
                void 0 === a && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i),
                a = new Vector4),
                t[r++] = a.x,
                t[r++] = a.y,
                t[r++] = a.z,
                t[r++] = a.w
            }
            return this
        }
    }, {
        key: "applyMatrix3",
        value: function(e) {
            if (2 === this.itemSize)
                for (var t = 0, r = this.count; t < r; t++)
                    _vector2$1.fromBufferAttribute(this, t),
                    _vector2$1.applyMatrix3(e),
                    this.setXY(t, _vector2$1.x, _vector2$1.y);
            else if (3 === this.itemSize)
                for (var i = 0, n = this.count; i < n; i++)
                    _vector$9.fromBufferAttribute(this, i),
                    _vector$9.applyMatrix3(e),
                    this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
            return this
        }
    }, {
        key: "applyMatrix4",
        value: function(e) {
            for (var t = 0, r = this.count; t < r; t++)
                _vector$9.fromBufferAttribute(this, t),
                _vector$9.applyMatrix4(e),
                this.setXYZ(t, _vector$9.x, _vector$9.y, _vector$9.z);
            return this
        }
    }, {
        key: "applyNormalMatrix",
        value: function(e) {
            for (var t = 0, r = this.count; t < r; t++)
                _vector$9.fromBufferAttribute(this, t),
                _vector$9.applyNormalMatrix(e),
                this.setXYZ(t, _vector$9.x, _vector$9.y, _vector$9.z);
            return this
        }
    }, {
        key: "transformDirection",
        value: function(e) {
            for (var t = 0, r = this.count; t < r; t++)
                _vector$9.fromBufferAttribute(this, t),
                _vector$9.transformDirection(e),
                this.setXYZ(t, _vector$9.x, _vector$9.y, _vector$9.z);
            return this
        }
    }, {
        key: "set",
        value: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
            return this.array.set(e, t),
            this
        }
    }, {
        key: "getX",
        value: function(e) {
            return this.array[e * this.itemSize]
        }
    }, {
        key: "setX",
        value: function(e, t) {
            return this.array[e * this.itemSize] = t,
            this
        }
    }, {
        key: "getY",
        value: function(e) {
            return this.array[e * this.itemSize + 1]
        }
    }, {
        key: "setY",
        value: function(e, t) {
            return this.array[e * this.itemSize + 1] = t,
            this
        }
    }, {
        key: "getZ",
        value: function(e) {
            return this.array[e * this.itemSize + 2]
        }
    }, {
        key: "setZ",
        value: function(e, t) {
            return this.array[e * this.itemSize + 2] = t,
            this
        }
    }, {
        key: "getW",
        value: function(e) {
            return this.array[e * this.itemSize + 3]
        }
    }, {
        key: "setW",
        value: function(e, t) {
            return this.array[e * this.itemSize + 3] = t,
            this
        }
    }, {
        key: "setXY",
        value: function(e, t, r) {
            return e *= this.itemSize,
            this.array[e + 0] = t,
            this.array[e + 1] = r,
            this
        }
    }, {
        key: "setXYZ",
        value: function(e, t, r, i) {
            return e *= this.itemSize,
            this.array[e + 0] = t,
            this.array[e + 1] = r,
            this.array[e + 2] = i,
            this
        }
    }, {
        key: "setXYZW",
        value: function(e, t, r, i, n) {
            return e *= this.itemSize,
            this.array[e + 0] = t,
            this.array[e + 1] = r,
            this.array[e + 2] = i,
            this.array[e + 3] = n,
            this
        }
    }, {
        key: "onUpload",
        value: function(e) {
            return this.onUploadCallback = e,
            this
        }
    }, {
        key: "clone",
        value: function() {
            return new this.constructor(this.array,this.itemSize).copy(this)
        }
    }, {
        key: "toJSON",
        value: function() {
            var e = {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: Array.prototype.slice.call(this.array),
                normalized: this.normalized
            };
            return "" !== this.name && (e.name = this.name),
            this.usage !== StaticDrawUsage && (e.usage = this.usage),
            0 === this.updateRange.offset && -1 === this.updateRange.count || (e.updateRange = this.updateRange),
            e
        }
    }]),
    e
}();
BufferAttribute.prototype.isBufferAttribute = !0;
var Uint16BufferAttribute = function(e) {
    _inherits(r, BufferAttribute);
    var t = _createSuper(r);
    function r(e, i, n) {
        return _classCallCheck(this, r),
        t.call(this, new Uint16Array(e), i, n)
    }
    return _createClass(r)
}()
  , Uint32BufferAttribute = function(e) {
    _inherits(r, BufferAttribute);
    var t = _createSuper(r);
    function r(e, i, n) {
        return _classCallCheck(this, r),
        t.call(this, new Uint32Array(e), i, n)
    }
    return _createClass(r)
}()
  , Float16BufferAttribute = function(e) {
    _inherits(r, BufferAttribute);
    var t = _createSuper(r);
    function r(e, i, n) {
        return _classCallCheck(this, r),
        t.call(this, new Uint16Array(e), i, n)
    }
    return _createClass(r)
}();
Float16BufferAttribute.prototype.isFloat16BufferAttribute = !0;
var Float32BufferAttribute = function(e) {
    _inherits(r, BufferAttribute);
    var t = _createSuper(r);
    function r(e, i, n) {
        return _classCallCheck(this, r),
        t.call(this, new Float32Array(e), i, n)
    }
    return _createClass(r)
}()
  , _id$1 = 0
  , _m1 = new Matrix4
  , _obj = new Object3D
  , _offset = new Vector3
  , _box$1 = new Box3
  , _boxMorphTargets = new Box3
  , _vector$8 = new Vector3
  , BufferGeometry = function(e) {
    _inherits(r, EventDispatcher);
    var t = _createSuper(r);
    function r() {
        var e;
        return _classCallCheck(this, r),
        e = t.call(this),
        Object.defineProperty(_assertThisInitialized(e), "id", {
            value: _id$1++
        }),
        e.uuid = generateUUID(),
        e.name = "",
        e.type = "BufferGeometry",
        e.index = null,
        e.attributes = {},
        e.morphAttributes = {},
        e.morphTargetsRelative = !1,
        e.groups = [],
        e.boundingBox = null,
        e.boundingSphere = null,
        e.drawRange = {
            start: 0,
            count: 1 / 0
        },
        e.userData = {},
        e
    }
    return _createClass(r, [{
        key: "getIndex",
        value: function() {
            return this.index
        }
    }, {
        key: "setIndex",
        value: function(e) {
            return Array.isArray(e) ? this.index = new (arrayNeedsUint32(e) ? Uint32BufferAttribute : Uint16BufferAttribute)(e,1) : this.index = e,
            this
        }
    }, {
        key: "getAttribute",
        value: function(e) {
            return this.attributes[e]
        }
    }, {
        key: "setAttribute",
        value: function(e, t) {
            return this.attributes[e] = t,
            this
        }
    }, {
        key: "deleteAttribute",
        value: function(e) {
            return delete this.attributes[e],
            this
        }
    }, {
        key: "hasAttribute",
        value: function(e) {
            return void 0 !== this.attributes[e]
        }
    }, {
        key: "addGroup",
        value: function(e, t) {
            var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
            this.groups.push({
                start: e,
                count: t,
                materialIndex: r
            })
        }
    }, {
        key: "clearGroups",
        value: function() {
            this.groups = []
        }
    }, {
        key: "setDrawRange",
        value: function(e, t) {
            this.drawRange.start = e,
            this.drawRange.count = t
        }
    }, {
        key: "applyMatrix4",
        value: function(e) {
            var t = this.attributes.position;
            void 0 !== t && (t.applyMatrix4(e),
            t.needsUpdate = !0);
            var r = this.attributes.normal;
            if (void 0 !== r) {
                var i = (new Matrix3).getNormalMatrix(e);
                r.applyNormalMatrix(i),
                r.needsUpdate = !0
            }
            var n = this.attributes.tangent;
            return void 0 !== n && (n.transformDirection(e),
            n.needsUpdate = !0),
            null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
            this
        }
    }, {
        key: "applyQuaternion",
        value: function(e) {
            return _m1.makeRotationFromQuaternion(e),
            this.applyMatrix4(_m1),
            this
        }
    }, {
        key: "rotateX",
        value: function(e) {
            return _m1.makeRotationX(e),
            this.applyMatrix4(_m1),
            this
        }
    }, {
        key: "rotateY",
        value: function(e) {
            return _m1.makeRotationY(e),
            this.applyMatrix4(_m1),
            this
        }
    }, {
        key: "rotateZ",
        value: function(e) {
            return _m1.makeRotationZ(e),
            this.applyMatrix4(_m1),
            this
        }
    }, {
        key: "translate",
        value: function(e, t, r) {
            return _m1.makeTranslation(e, t, r),
            this.applyMatrix4(_m1),
            this
        }
    }, {
        key: "scale",
        value: function(e, t, r) {
            return _m1.makeScale(e, t, r),
            this.applyMatrix4(_m1),
            this
        }
    }, {
        key: "lookAt",
        value: function(e) {
            return _obj.lookAt(e),
            _obj.updateMatrix(),
            this.applyMatrix4(_obj.matrix),
            this
        }
    }, {
        key: "center",
        value: function() {
            return this.computeBoundingBox(),
            this.boundingBox.getCenter(_offset).negate(),
            this.translate(_offset.x, _offset.y, _offset.z),
            this
        }
    }, {
        key: "setFromPoints",
        value: function(e) {
            for (var t = [], r = 0, i = e.length; r < i; r++) {
                var n = e[r];
                t.push(n.x, n.y, n.z || 0)
            }
            return this.setAttribute("position", new Float32BufferAttribute(t,3)),
            this
        }
    }, {
        key: "computeBoundingBox",
        value: function() {
            null === this.boundingBox && (this.boundingBox = new Box3);
            var e = this.attributes.position
              , t = this.morphAttributes.position;
            if (e && e.isGLBufferAttribute)
                return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this),
                void this.boundingBox.set(new Vector3(-1 / 0,-1 / 0,-1 / 0), new Vector3(1 / 0,1 / 0,1 / 0));
            if (void 0 !== e) {
                if (this.boundingBox.setFromBufferAttribute(e),
                t)
                    for (var r = 0, i = t.length; r < i; r++) {
                        var n = t[r];
                        _box$1.setFromBufferAttribute(n),
                        this.morphTargetsRelative ? (_vector$8.addVectors(this.boundingBox.min, _box$1.min),
                        this.boundingBox.expandByPoint(_vector$8),
                        _vector$8.addVectors(this.boundingBox.max, _box$1.max),
                        this.boundingBox.expandByPoint(_vector$8)) : (this.boundingBox.expandByPoint(_box$1.min),
                        this.boundingBox.expandByPoint(_box$1.max))
                    }
            } else
                this.boundingBox.makeEmpty();
            (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
        }
    }, {
        key: "computeBoundingSphere",
        value: function() {
            null === this.boundingSphere && (this.boundingSphere = new Sphere);
            var e = this.attributes.position
              , t = this.morphAttributes.position;
            if (e && e.isGLBufferAttribute)
                return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this),
                void this.boundingSphere.set(new Vector3, 1 / 0);
            if (e) {
                var r = this.boundingSphere.center;
                if (_box$1.setFromBufferAttribute(e),
                t)
                    for (var i = 0, n = t.length; i < n; i++) {
                        var a = t[i];
                        _boxMorphTargets.setFromBufferAttribute(a),
                        this.morphTargetsRelative ? (_vector$8.addVectors(_box$1.min, _boxMorphTargets.min),
                        _box$1.expandByPoint(_vector$8),
                        _vector$8.addVectors(_box$1.max, _boxMorphTargets.max),
                        _box$1.expandByPoint(_vector$8)) : (_box$1.expandByPoint(_boxMorphTargets.min),
                        _box$1.expandByPoint(_boxMorphTargets.max))
                    }
                _box$1.getCenter(r);
                for (var o = 0, s = 0, l = e.count; s < l; s++)
                    _vector$8.fromBufferAttribute(e, s),
                    o = Math.max(o, r.distanceToSquared(_vector$8));
                if (t)
                    for (var u = 0, c = t.length; u < c; u++)
                        for (var h = t[u], d = this.morphTargetsRelative, p = 0, f = h.count; p < f; p++)
                            _vector$8.fromBufferAttribute(h, p),
                            d && (_offset.fromBufferAttribute(e, p),
                            _vector$8.add(_offset)),
                            o = Math.max(o, r.distanceToSquared(_vector$8));
                this.boundingSphere.radius = Math.sqrt(o),
                isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
            }
        }
    }, {
        key: "computeTangents",
        value: function() {
            var e = this.index
              , t = this.attributes;
            if (null !== e && void 0 !== t.position && void 0 !== t.normal && void 0 !== t.uv) {
                var r = e.array
                  , i = t.position.array
                  , n = t.normal.array
                  , a = t.uv.array
                  , o = i.length / 3;
                !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * o),4));
                for (var s = this.getAttribute("tangent").array, l = [], u = [], c = 0; c < o; c++)
                    l[c] = new Vector3,
                    u[c] = new Vector3;
                var h = new Vector3
                  , d = new Vector3
                  , p = new Vector3
                  , f = new Vector2
                  , m = new Vector2
                  , v = new Vector2
                  , g = new Vector3
                  , _ = new Vector3
                  , y = this.groups;
                0 === y.length && (y = [{
                    start: 0,
                    count: r.length
                }]);
                for (var x = 0, b = y.length; x < b; ++x)
                    for (var S = y[x], w = S.start, M = w, T = w + S.count; M < T; M += 3)
                        N(r[M + 0], r[M + 1], r[M + 2]);
                for (var C = new Vector3, E = new Vector3, P = new Vector3, A = new Vector3, k = 0, L = y.length; k < L; ++k)
                    for (var R = y[k], D = R.start, I = D, O = D + R.count; I < O; I += 3)
                        F(r[I + 0]),
                        F(r[I + 1]),
                        F(r[I + 2])
            } else
                console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            function N(e, t, r) {
                h.fromArray(i, 3 * e),
                d.fromArray(i, 3 * t),
                p.fromArray(i, 3 * r),
                f.fromArray(a, 2 * e),
                m.fromArray(a, 2 * t),
                v.fromArray(a, 2 * r),
                d.sub(h),
                p.sub(h),
                m.sub(f),
                v.sub(f);
                var n = 1 / (m.x * v.y - v.x * m.y);
                isFinite(n) && (g.copy(d).multiplyScalar(v.y).addScaledVector(p, -m.y).multiplyScalar(n),
                _.copy(p).multiplyScalar(m.x).addScaledVector(d, -v.x).multiplyScalar(n),
                l[e].add(g),
                l[t].add(g),
                l[r].add(g),
                u[e].add(_),
                u[t].add(_),
                u[r].add(_))
            }
            function F(e) {
                P.fromArray(n, 3 * e),
                A.copy(P);
                var t = l[e];
                C.copy(t),
                C.sub(P.multiplyScalar(P.dot(t))).normalize(),
                E.crossVectors(A, t);
                var r = E.dot(u[e]) < 0 ? -1 : 1;
                s[4 * e] = C.x,
                s[4 * e + 1] = C.y,
                s[4 * e + 2] = C.z,
                s[4 * e + 3] = r
            }
        }
    }, {
        key: "computeVertexNormals",
        value: function() {
            var e = this.index
              , t = this.getAttribute("position");
            if (void 0 !== t) {
                var r = this.getAttribute("normal");
                if (void 0 === r)
                    r = new BufferAttribute(new Float32Array(3 * t.count),3),
                    this.setAttribute("normal", r);
                else
                    for (var i = 0, n = r.count; i < n; i++)
                        r.setXYZ(i, 0, 0, 0);
                var a = new Vector3
                  , o = new Vector3
                  , s = new Vector3
                  , l = new Vector3
                  , u = new Vector3
                  , c = new Vector3
                  , h = new Vector3
                  , d = new Vector3;
                if (e)
                    for (var p = 0, f = e.count; p < f; p += 3) {
                        var m = e.getX(p + 0)
                          , v = e.getX(p + 1)
                          , g = e.getX(p + 2);
                        a.fromBufferAttribute(t, m),
                        o.fromBufferAttribute(t, v),
                        s.fromBufferAttribute(t, g),
                        h.subVectors(s, o),
                        d.subVectors(a, o),
                        h.cross(d),
                        l.fromBufferAttribute(r, m),
                        u.fromBufferAttribute(r, v),
                        c.fromBufferAttribute(r, g),
                        l.add(h),
                        u.add(h),
                        c.add(h),
                        r.setXYZ(m, l.x, l.y, l.z),
                        r.setXYZ(v, u.x, u.y, u.z),
                        r.setXYZ(g, c.x, c.y, c.z)
                    }
                else
                    for (var _ = 0, y = t.count; _ < y; _ += 3)
                        a.fromBufferAttribute(t, _ + 0),
                        o.fromBufferAttribute(t, _ + 1),
                        s.fromBufferAttribute(t, _ + 2),
                        h.subVectors(s, o),
                        d.subVectors(a, o),
                        h.cross(d),
                        r.setXYZ(_ + 0, h.x, h.y, h.z),
                        r.setXYZ(_ + 1, h.x, h.y, h.z),
                        r.setXYZ(_ + 2, h.x, h.y, h.z);
                this.normalizeNormals(),
                r.needsUpdate = !0
            }
        }
    }, {
        key: "merge",
        value: function(e, t) {
            if (e && e.isBufferGeometry) {
                void 0 === t && (t = 0,
                console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                var r = this.attributes;
                for (var i in r)
                    if (void 0 !== e.attributes[i])
                        for (var n = r[i].array, a = e.attributes[i], o = a.array, s = a.itemSize * t, l = Math.min(o.length, n.length - s), u = 0, c = s; u < l; u++,
                        c++)
                            n[c] = o[u];
                return this
            }
            console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e)
        }
    }, {
        key: "normalizeNormals",
        value: function() {
            for (var e = this.attributes.normal, t = 0, r = e.count; t < r; t++)
                _vector$8.fromBufferAttribute(e, t),
                _vector$8.normalize(),
                e.setXYZ(t, _vector$8.x, _vector$8.y, _vector$8.z)
        }
    }, {
        key: "toNonIndexed",
        value: function() {
            function e(e, t) {
                for (var r = e.array, i = e.itemSize, n = e.normalized, a = new r.constructor(t.length * i), o = 0, s = 0, l = 0, u = t.length; l < u; l++) {
                    o = e.isInterleavedBufferAttribute ? t[l] * e.data.stride + e.offset : t[l] * i;
                    for (var c = 0; c < i; c++)
                        a[s++] = r[o++]
                }
                return new BufferAttribute(a,i,n)
            }
            if (null === this.index)
                return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
                this;
            var t = new r
              , i = this.index.array
              , n = this.attributes;
            for (var a in n) {
                var o = e(n[a], i);
                t.setAttribute(a, o)
            }
            var s = this.morphAttributes;
            for (var l in s) {
                for (var u = [], c = s[l], h = 0, d = c.length; h < d; h++) {
                    var p = e(c[h], i);
                    u.push(p)
                }
                t.morphAttributes[l] = u
            }
            t.morphTargetsRelative = this.morphTargetsRelative;
            for (var f = this.groups, m = 0, v = f.length; m < v; m++) {
                var g = f[m];
                t.addGroup(g.start, g.count, g.materialIndex)
            }
            return t
        }
    }, {
        key: "toJSON",
        value: function() {
            var e = {
                metadata: {
                    version: 4.5,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            if (e.uuid = this.uuid,
            e.type = this.type,
            "" !== this.name && (e.name = this.name),
            Object.keys(this.userData).length > 0 && (e.userData = this.userData),
            void 0 !== this.parameters) {
                var t = this.parameters;
                for (var r in t)
                    void 0 !== t[r] && (e[r] = t[r]);
                return e
            }
            e.data = {
                attributes: {}
            };
            var i = this.index;
            null !== i && (e.data.index = {
                type: i.array.constructor.name,
                array: Array.prototype.slice.call(i.array)
            });
            var n = this.attributes;
            for (var a in n) {
                var o = n[a];
                e.data.attributes[a] = o.toJSON(e.data)
            }
            var s = {}
              , l = !1;
            for (var u in this.morphAttributes) {
                for (var c = this.morphAttributes[u], h = [], d = 0, p = c.length; d < p; d++) {
                    var f = c[d];
                    h.push(f.toJSON(e.data))
                }
                h.length > 0 && (s[u] = h,
                l = !0)
            }
            l && (e.data.morphAttributes = s,
            e.data.morphTargetsRelative = this.morphTargetsRelative);
            var m = this.groups;
            m.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(m)));
            var v = this.boundingSphere;
            return null !== v && (e.data.boundingSphere = {
                center: v.center.toArray(),
                radius: v.radius
            }),
            e
        }
    }, {
        key: "clone",
        value: function() {
            return (new this.constructor).copy(this)
        }
    }, {
        key: "copy",
        value: function(e) {
            this.index = null,
            this.attributes = {},
            this.morphAttributes = {},
            this.groups = [],
            this.boundingBox = null,
            this.boundingSphere = null;
            var t = {};
            this.name = e.name;
            var r = e.index;
            null !== r && this.setIndex(r.clone(t));
            var i = e.attributes;
            for (var n in i) {
                var a = i[n];
                this.setAttribute(n, a.clone(t))
            }
            var o = e.morphAttributes;
            for (var s in o) {
                for (var l = [], u = o[s], c = 0, h = u.length; c < h; c++)
                    l.push(u[c].clone(t));
                this.morphAttributes[s] = l
            }
            this.morphTargetsRelative = e.morphTargetsRelative;
            for (var d = e.groups, p = 0, f = d.length; p < f; p++) {
                var m = d[p];
                this.addGroup(m.start, m.count, m.materialIndex)
            }
            var v = e.boundingBox;
            null !== v && (this.boundingBox = v.clone());
            var g = e.boundingSphere;
            return null !== g && (this.boundingSphere = g.clone()),
            this.drawRange.start = e.drawRange.start,
            this.drawRange.count = e.drawRange.count,
            this.userData = e.userData,
            void 0 !== e.parameters && (this.parameters = Object.assign({}, e.parameters)),
            this
        }
    }, {
        key: "dispose",
        value: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }]),
    r
}();
BufferGeometry.prototype.isBufferGeometry = !0;
var _inverseMatrix$2 = new Matrix4
  , _ray$2 = new Ray
  , _sphere$3 = new Sphere
  , _vA$1 = new Vector3
  , _vB$1 = new Vector3
  , _vC$1 = new Vector3
  , _tempA = new Vector3
  , _tempB = new Vector3
  , _tempC = new Vector3
  , _morphA = new Vector3
  , _morphB = new Vector3
  , _morphC = new Vector3
  , _uvA$1 = new Vector2
  , _uvB$1 = new Vector2
  , _uvC$1 = new Vector2
  , _intersectionPoint = new Vector3
  , _intersectionPointWorld = new Vector3
  , Mesh = function(e) {
    _inherits(r, Object3D);
    var t = _createSuper(r);
    function r() {
        var e, i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new BufferGeometry, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new MeshBasicMaterial;
        return _classCallCheck(this, r),
        (e = t.call(this)).type = "Mesh",
        e.geometry = i,
        e.material = n,
        e.updateMorphTargets(),
        e
    }
    return _createClass(r, [{
        key: "copy",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e),
            void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
            void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
            this.material = e.material,
            this.geometry = e.geometry,
            this
        }
    }, {
        key: "updateMorphTargets",
        value: function() {
            var e = this.geometry;
            if (e.isBufferGeometry) {
                var t = e.morphAttributes
                  , r = Object.keys(t);
                if (r.length > 0) {
                    var i = t[r[0]];
                    if (void 0 !== i) {
                        this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {};
                        for (var n = 0, a = i.length; n < a; n++) {
                            var o = i[n].name || String(n);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[o] = n
                        }
                    }
                }
            } else {
                var s = e.morphTargets;
                void 0 !== s && s.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        }
    }, {
        key: "raycast",
        value: function(e, t) {
            var r, i = this.geometry, n = this.material, a = this.matrixWorld;
            if (void 0 !== n && (null === i.boundingSphere && i.computeBoundingSphere(),
            _sphere$3.copy(i.boundingSphere),
            _sphere$3.applyMatrix4(a),
            !1 !== e.ray.intersectsSphere(_sphere$3) && (_inverseMatrix$2.copy(a).invert(),
            _ray$2.copy(e.ray).applyMatrix4(_inverseMatrix$2),
            null === i.boundingBox || !1 !== _ray$2.intersectsBox(i.boundingBox))))
                if (i.isBufferGeometry) {
                    var o = i.index
                      , s = i.attributes.position
                      , l = i.morphAttributes.position
                      , u = i.morphTargetsRelative
                      , c = i.attributes.uv
                      , h = i.attributes.uv2
                      , d = i.groups
                      , p = i.drawRange;
                    if (null !== o)
                        if (Array.isArray(n))
                            for (var f = 0, m = d.length; f < m; f++)
                                for (var v = d[f], g = n[v.materialIndex], _ = Math.max(v.start, p.start), y = Math.min(o.count, Math.min(v.start + v.count, p.start + p.count)); _ < y; _ += 3) {
                                    var x = o.getX(_)
                                      , b = o.getX(_ + 1)
                                      , S = o.getX(_ + 2);
                                    (r = checkBufferGeometryIntersection(this, g, e, _ray$2, s, l, u, c, h, x, b, S)) && (r.faceIndex = Math.floor(_ / 3),
                                    r.face.materialIndex = v.materialIndex,
                                    t.push(r))
                                }
                        else
                            for (var w = Math.max(0, p.start), M = Math.min(o.count, p.start + p.count); w < M; w += 3) {
                                var T = o.getX(w)
                                  , C = o.getX(w + 1)
                                  , E = o.getX(w + 2);
                                (r = checkBufferGeometryIntersection(this, n, e, _ray$2, s, l, u, c, h, T, C, E)) && (r.faceIndex = Math.floor(w / 3),
                                t.push(r))
                            }
                    else if (void 0 !== s)
                        if (Array.isArray(n))
                            for (var P = 0, A = d.length; P < A; P++)
                                for (var k = d[P], L = n[k.materialIndex], R = Math.max(k.start, p.start), D = Math.min(s.count, Math.min(k.start + k.count, p.start + p.count)); R < D; R += 3)
                                    (r = checkBufferGeometryIntersection(this, L, e, _ray$2, s, l, u, c, h, R, R + 1, R + 2)) && (r.faceIndex = Math.floor(R / 3),
                                    r.face.materialIndex = k.materialIndex,
                                    t.push(r));
                        else
                            for (var I = Math.max(0, p.start), O = Math.min(s.count, p.start + p.count); I < O; I += 3)
                                (r = checkBufferGeometryIntersection(this, n, e, _ray$2, s, l, u, c, h, I, I + 1, I + 2)) && (r.faceIndex = Math.floor(I / 3),
                                t.push(r))
                } else
                    i.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
        }
    }]),
    r
}();
function checkIntersection(e, t, r, i, n, a, o, s) {
    if (null === (t.side === BackSide ? i.intersectTriangle(o, a, n, !0, s) : i.intersectTriangle(n, a, o, t.side !== DoubleSide, s)))
        return null;
    _intersectionPointWorld.copy(s),
    _intersectionPointWorld.applyMatrix4(e.matrixWorld);
    var l = r.ray.origin.distanceTo(_intersectionPointWorld);
    return l < r.near || l > r.far ? null : {
        distance: l,
        point: _intersectionPointWorld.clone(),
        object: e
    }
}
function checkBufferGeometryIntersection(e, t, r, i, n, a, o, s, l, u, c, h) {
    _vA$1.fromBufferAttribute(n, u),
    _vB$1.fromBufferAttribute(n, c),
    _vC$1.fromBufferAttribute(n, h);
    var d = e.morphTargetInfluences;
    if (a && d) {
        _morphA.set(0, 0, 0),
        _morphB.set(0, 0, 0),
        _morphC.set(0, 0, 0);
        for (var p = 0, f = a.length; p < f; p++) {
            var m = d[p]
              , v = a[p];
            0 !== m && (_tempA.fromBufferAttribute(v, u),
            _tempB.fromBufferAttribute(v, c),
            _tempC.fromBufferAttribute(v, h),
            o ? (_morphA.addScaledVector(_tempA, m),
            _morphB.addScaledVector(_tempB, m),
            _morphC.addScaledVector(_tempC, m)) : (_morphA.addScaledVector(_tempA.sub(_vA$1), m),
            _morphB.addScaledVector(_tempB.sub(_vB$1), m),
            _morphC.addScaledVector(_tempC.sub(_vC$1), m)))
        }
        _vA$1.add(_morphA),
        _vB$1.add(_morphB),
        _vC$1.add(_morphC)
    }
    e.isSkinnedMesh && (e.boneTransform(u, _vA$1),
    e.boneTransform(c, _vB$1),
    e.boneTransform(h, _vC$1));
    var g = checkIntersection(e, t, r, i, _vA$1, _vB$1, _vC$1, _intersectionPoint);
    if (g) {
        s && (_uvA$1.fromBufferAttribute(s, u),
        _uvB$1.fromBufferAttribute(s, c),
        _uvC$1.fromBufferAttribute(s, h),
        g.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2)),
        l && (_uvA$1.fromBufferAttribute(l, u),
        _uvB$1.fromBufferAttribute(l, c),
        _uvC$1.fromBufferAttribute(l, h),
        g.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2));
        var _ = {
            a: u,
            b: c,
            c: h,
            normal: new Vector3,
            materialIndex: 0
        };
        Triangle.getNormal(_vA$1, _vB$1, _vC$1, _.normal),
        g.face = _
    }
    return g
}
Mesh.prototype.isMesh = !0;
var BoxGeometry = function(e) {
    _inherits(r, BufferGeometry);
    var t = _createSuper(r);
    function r() {
        var e, i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1, s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1, l = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1;
        _classCallCheck(this, r),
        (e = t.call(this)).type = "BoxGeometry",
        e.parameters = {
            width: i,
            height: n,
            depth: a,
            widthSegments: o,
            heightSegments: s,
            depthSegments: l
        };
        var u = _assertThisInitialized(e);
        o = Math.floor(o),
        s = Math.floor(s),
        l = Math.floor(l);
        var c = []
          , h = []
          , d = []
          , p = []
          , f = 0
          , m = 0;
        function v(e, t, r, i, n, a, o, s, l, v, g) {
            for (var _ = a / l, y = o / v, x = a / 2, b = o / 2, S = s / 2, w = l + 1, M = v + 1, T = 0, C = 0, E = new Vector3, P = 0; P < M; P++)
                for (var A = P * y - b, k = 0; k < w; k++) {
                    var L = k * _ - x;
                    E[e] = L * i,
                    E[t] = A * n,
                    E[r] = S,
                    h.push(E.x, E.y, E.z),
                    E[e] = 0,
                    E[t] = 0,
                    E[r] = s > 0 ? 1 : -1,
                    d.push(E.x, E.y, E.z),
                    p.push(k / l),
                    p.push(1 - P / v),
                    T += 1
                }
            for (var R = 0; R < v; R++)
                for (var D = 0; D < l; D++) {
                    var I = f + D + w * R
                      , O = f + D + w * (R + 1)
                      , N = f + (D + 1) + w * (R + 1)
                      , F = f + (D + 1) + w * R;
                    c.push(I, O, F),
                    c.push(O, N, F),
                    C += 6
                }
            u.addGroup(m, C, g),
            m += C,
            f += T
        }
        return v("z", "y", "x", -1, -1, a, n, i, l, s, 0),
        v("z", "y", "x", 1, -1, a, n, -i, l, s, 1),
        v("x", "z", "y", 1, 1, i, a, n, o, l, 2),
        v("x", "z", "y", 1, -1, i, a, -n, o, l, 3),
        v("x", "y", "z", 1, -1, i, n, a, o, s, 4),
        v("x", "y", "z", -1, -1, i, n, -a, o, s, 5),
        e.setIndex(c),
        e.setAttribute("position", new Float32BufferAttribute(h,3)),
        e.setAttribute("normal", new Float32BufferAttribute(d,3)),
        e.setAttribute("uv", new Float32BufferAttribute(p,2)),
        e
    }
    return _createClass(r, null, [{
        key: "fromJSON",
        value: function(e) {
            return new r(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)
        }
    }]),
    r
}();
function cloneUniforms(e) {
    var t = {};
    for (var r in e)
        for (var i in t[r] = {},
        e[r]) {
            var n = e[r][i];
            n && (n.isColor || n.isMatrix3 || n.isMatrix4 || n.isVector2 || n.isVector3 || n.isVector4 || n.isTexture || n.isQuaternion) ? t[r][i] = n.clone() : Array.isArray(n) ? t[r][i] = n.slice() : t[r][i] = n
        }
    return t
}
function mergeUniforms(e) {
    for (var t = {}, r = 0; r < e.length; r++) {
        var i = cloneUniforms(e[r]);
        for (var n in i)
            t[n] = i[n]
    }
    return t
}
var UniformsUtils = {
    clone: cloneUniforms,
    merge: mergeUniforms
}
  , default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"
  , default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"
  , ShaderMaterial = function(e) {
    _inherits(r, Material);
    var t = _createSuper(r);
    function r(e) {
        var i;
        return _classCallCheck(this, r),
        (i = t.call(this)).type = "ShaderMaterial",
        i.defines = {},
        i.uniforms = {},
        i.vertexShader = default_vertex,
        i.fragmentShader = default_fragment,
        i.linewidth = 1,
        i.wireframe = !1,
        i.wireframeLinewidth = 1,
        i.fog = !1,
        i.lights = !1,
        i.clipping = !1,
        i.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        },
        i.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        },
        i.index0AttributeName = void 0,
        i.uniformsNeedUpdate = !1,
        i.glslVersion = null,
        void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),
        i.setValues(e)),
        i
    }
    return _createClass(r, [{
        key: "copy",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e),
            this.fragmentShader = e.fragmentShader,
            this.vertexShader = e.vertexShader,
            this.uniforms = cloneUniforms(e.uniforms),
            this.defines = Object.assign({}, e.defines),
            this.wireframe = e.wireframe,
            this.wireframeLinewidth = e.wireframeLinewidth,
            this.lights = e.lights,
            this.clipping = e.clipping,
            this.extensions = Object.assign({}, e.extensions),
            this.glslVersion = e.glslVersion,
            this
        }
    }, {
        key: "toJSON",
        value: function(e) {
            var t = _get(_getPrototypeOf(r.prototype), "toJSON", this).call(this, e);
            for (var i in t.glslVersion = this.glslVersion,
            t.uniforms = {},
            this.uniforms) {
                var n = this.uniforms[i].value;
                n && n.isTexture ? t.uniforms[i] = {
                    type: "t",
                    value: n.toJSON(e).uuid
                } : n && n.isColor ? t.uniforms[i] = {
                    type: "c",
                    value: n.getHex()
                } : n && n.isVector2 ? t.uniforms[i] = {
                    type: "v2",
                    value: n.toArray()
                } : n && n.isVector3 ? t.uniforms[i] = {
                    type: "v3",
                    value: n.toArray()
                } : n && n.isVector4 ? t.uniforms[i] = {
                    type: "v4",
                    value: n.toArray()
                } : n && n.isMatrix3 ? t.uniforms[i] = {
                    type: "m3",
                    value: n.toArray()
                } : n && n.isMatrix4 ? t.uniforms[i] = {
                    type: "m4",
                    value: n.toArray()
                } : t.uniforms[i] = {
                    value: n
                }
            }
            Object.keys(this.defines).length > 0 && (t.defines = this.defines),
            t.vertexShader = this.vertexShader,
            t.fragmentShader = this.fragmentShader;
            var a = {};
            for (var o in this.extensions)
                !0 === this.extensions[o] && (a[o] = !0);
            return Object.keys(a).length > 0 && (t.extensions = a),
            t
        }
    }]),
    r
}();
ShaderMaterial.prototype.isShaderMaterial = !0;
var Camera = function(e) {
    _inherits(r, Object3D);
    var t = _createSuper(r);
    function r() {
        var e;
        return _classCallCheck(this, r),
        (e = t.call(this)).type = "Camera",
        e.matrixWorldInverse = new Matrix4,
        e.projectionMatrix = new Matrix4,
        e.projectionMatrixInverse = new Matrix4,
        e
    }
    return _createClass(r, [{
        key: "copy",
        value: function(e, t) {
            return _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e, t),
            this.matrixWorldInverse.copy(e.matrixWorldInverse),
            this.projectionMatrix.copy(e.projectionMatrix),
            this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
            this
        }
    }, {
        key: "getWorldDirection",
        value: function(e) {
            this.updateWorldMatrix(!0, !1);
            var t = this.matrixWorld.elements;
            return e.set(-t[8], -t[9], -t[10]).normalize()
        }
    }, {
        key: "updateMatrixWorld",
        value: function(e) {
            _get(_getPrototypeOf(r.prototype), "updateMatrixWorld", this).call(this, e),
            this.matrixWorldInverse.copy(this.matrixWorld).invert()
        }
    }, {
        key: "updateWorldMatrix",
        value: function(e, t) {
            _get(_getPrototypeOf(r.prototype), "updateWorldMatrix", this).call(this, e, t),
            this.matrixWorldInverse.copy(this.matrixWorld).invert()
        }
    }, {
        key: "clone",
        value: function() {
            return (new this.constructor).copy(this)
        }
    }]),
    r
}();
Camera.prototype.isCamera = !0;
var PerspectiveCamera = function(e) {
    _inherits(r, Camera);
    var t = _createSuper(r);
    function r() {
        var e, i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 50, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : .1, o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 2e3;
        return _classCallCheck(this, r),
        (e = t.call(this)).type = "PerspectiveCamera",
        e.fov = i,
        e.zoom = 1,
        e.near = a,
        e.far = o,
        e.focus = 10,
        e.aspect = n,
        e.view = null,
        e.filmGauge = 35,
        e.filmOffset = 0,
        e.updateProjectionMatrix(),
        e
    }
    return _createClass(r, [{
        key: "copy",
        value: function(e, t) {
            return _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e, t),
            this.fov = e.fov,
            this.zoom = e.zoom,
            this.near = e.near,
            this.far = e.far,
            this.focus = e.focus,
            this.aspect = e.aspect,
            this.view = null === e.view ? null : Object.assign({}, e.view),
            this.filmGauge = e.filmGauge,
            this.filmOffset = e.filmOffset,
            this
        }
    }, {
        key: "setFocalLength",
        value: function(e) {
            var t = .5 * this.getFilmHeight() / e;
            this.fov = 2 * RAD2DEG * Math.atan(t),
            this.updateProjectionMatrix()
        }
    }, {
        key: "getFocalLength",
        value: function() {
            var e = Math.tan(.5 * DEG2RAD * this.fov);
            return .5 * this.getFilmHeight() / e
        }
    }, {
        key: "getEffectiveFOV",
        value: function() {
            return 2 * RAD2DEG * Math.atan(Math.tan(.5 * DEG2RAD * this.fov) / this.zoom)
        }
    }, {
        key: "getFilmWidth",
        value: function() {
            return this.filmGauge * Math.min(this.aspect, 1)
        }
    }, {
        key: "getFilmHeight",
        value: function() {
            return this.filmGauge / Math.max(this.aspect, 1)
        }
    }, {
        key: "setViewOffset",
        value: function(e, t, r, i, n, a) {
            this.aspect = e / t,
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }),
            this.view.enabled = !0,
            this.view.fullWidth = e,
            this.view.fullHeight = t,
            this.view.offsetX = r,
            this.view.offsetY = i,
            this.view.width = n,
            this.view.height = a,
            this.updateProjectionMatrix()
        }
    }, {
        key: "clearViewOffset",
        value: function() {
            null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix()
        }
    }, {
        key: "updateProjectionMatrix",
        value: function() {
            var e = this.near
              , t = e * Math.tan(.5 * DEG2RAD * this.fov) / this.zoom
              , r = 2 * t
              , i = this.aspect * r
              , n = -.5 * i
              , a = this.view;
            if (null !== this.view && this.view.enabled) {
                var o = a.fullWidth
                  , s = a.fullHeight;
                n += a.offsetX * i / o,
                t -= a.offsetY * r / s,
                i *= a.width / o,
                r *= a.height / s
            }
            var l = this.filmOffset;
            0 !== l && (n += e * l / this.getFilmWidth()),
            this.projectionMatrix.makePerspective(n, n + i, t, t - r, e, this.far),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
        }
    }, {
        key: "toJSON",
        value: function(e) {
            var t = _get(_getPrototypeOf(r.prototype), "toJSON", this).call(this, e);
            return t.object.fov = this.fov,
            t.object.zoom = this.zoom,
            t.object.near = this.near,
            t.object.far = this.far,
            t.object.focus = this.focus,
            t.object.aspect = this.aspect,
            null !== this.view && (t.object.view = Object.assign({}, this.view)),
            t.object.filmGauge = this.filmGauge,
            t.object.filmOffset = this.filmOffset,
            t
        }
    }]),
    r
}();
PerspectiveCamera.prototype.isPerspectiveCamera = !0;
var fov = 90
  , aspect = 1
  , CubeCamera = function(e) {
    _inherits(r, Object3D);
    var t = _createSuper(r);
    function r(e, i, n) {
        var a;
        if (_classCallCheck(this, r),
        (a = t.call(this)).type = "CubeCamera",
        !0 !== n.isWebGLCubeRenderTarget)
            return console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."),
            _possibleConstructorReturn(a);
        a.renderTarget = n;
        var o = new PerspectiveCamera(fov,aspect,e,i);
        o.layers = a.layers,
        o.up.set(0, -1, 0),
        o.lookAt(new Vector3(1,0,0)),
        a.add(o);
        var s = new PerspectiveCamera(fov,aspect,e,i);
        s.layers = a.layers,
        s.up.set(0, -1, 0),
        s.lookAt(new Vector3(-1,0,0)),
        a.add(s);
        var l = new PerspectiveCamera(fov,aspect,e,i);
        l.layers = a.layers,
        l.up.set(0, 0, 1),
        l.lookAt(new Vector3(0,1,0)),
        a.add(l);
        var u = new PerspectiveCamera(fov,aspect,e,i);
        u.layers = a.layers,
        u.up.set(0, 0, -1),
        u.lookAt(new Vector3(0,-1,0)),
        a.add(u);
        var c = new PerspectiveCamera(fov,aspect,e,i);
        c.layers = a.layers,
        c.up.set(0, -1, 0),
        c.lookAt(new Vector3(0,0,1)),
        a.add(c);
        var h = new PerspectiveCamera(fov,aspect,e,i);
        return h.layers = a.layers,
        h.up.set(0, -1, 0),
        h.lookAt(new Vector3(0,0,-1)),
        a.add(h),
        a
    }
    return _createClass(r, [{
        key: "update",
        value: function(e, t) {
            null === this.parent && this.updateMatrixWorld();
            var r = this.renderTarget
              , i = _slicedToArray(this.children, 6)
              , n = i[0]
              , a = i[1]
              , o = i[2]
              , s = i[3]
              , l = i[4]
              , u = i[5]
              , c = e.getRenderTarget()
              , h = e.outputEncoding
              , d = e.toneMapping
              , p = e.xr.enabled;
            e.outputEncoding = LinearEncoding,
            e.toneMapping = NoToneMapping,
            e.xr.enabled = !1;
            var f = r.texture.generateMipmaps;
            r.texture.generateMipmaps = !1,
            e.setRenderTarget(r, 0),
            e.render(t, n),
            e.setRenderTarget(r, 1),
            e.render(t, a),
            e.setRenderTarget(r, 2),
            e.render(t, o),
            e.setRenderTarget(r, 3),
            e.render(t, s),
            e.setRenderTarget(r, 4),
            e.render(t, l),
            r.texture.generateMipmaps = f,
            e.setRenderTarget(r, 5),
            e.render(t, u),
            e.setRenderTarget(c),
            e.outputEncoding = h,
            e.toneMapping = d,
            e.xr.enabled = p,
            r.texture.needsPMREMUpdate = !0
        }
    }]),
    r
}()
  , CubeTexture = function(e) {
    _inherits(r, Texture);
    var t = _createSuper(r);
    function r(e, i, n, a, o, s, l, u, c, h) {
        var d;
        return _classCallCheck(this, r),
        e = void 0 !== e ? e : [],
        i = void 0 !== i ? i : CubeReflectionMapping,
        (d = t.call(this, e, i, n, a, o, s, l, u, c, h)).flipY = !1,
        d
    }
    return _createClass(r, [{
        key: "images",
        get: function() {
            return this.image
        },
        set: function(e) {
            this.image = e
        }
    }]),
    r
}();
CubeTexture.prototype.isCubeTexture = !0;
var WebGLCubeRenderTarget = function(e) {
    _inherits(r, WebGLRenderTarget);
    var t = _createSuper(r);
    function r(e) {
        var i, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        _classCallCheck(this, r);
        var a = {
            width: e,
            height: e,
            depth: 1
        }
          , o = [a, a, a, a, a, a];
        return (i = t.call(this, e, e, n)).texture = new CubeTexture(o,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),
        i.texture.isRenderTargetTexture = !0,
        i.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps,
        i.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : LinearFilter,
        i
    }
    return _createClass(r, [{
        key: "fromEquirectangularTexture",
        value: function(e, t) {
            this.texture.type = t.type,
            this.texture.encoding = t.encoding,
            this.texture.generateMipmaps = t.generateMipmaps,
            this.texture.minFilter = t.minFilter,
            this.texture.magFilter = t.magFilter;
            var r = new BoxGeometry(5,5,5)
              , i = new ShaderMaterial({
                name: "CubemapFromEquirect",
                uniforms: cloneUniforms({
                    tEquirect: {
                        value: null
                    }
                }),
                vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
                side: BackSide,
                blending: NoBlending
            });
            i.uniforms.tEquirect.value = t;
            var n = new Mesh(r,i)
              , a = t.minFilter;
            return t.minFilter === LinearMipmapLinearFilter && (t.minFilter = LinearFilter),
            new CubeCamera(1,10,this).update(e, n),
            t.minFilter = a,
            n.geometry.dispose(),
            n.material.dispose(),
            this
        }
    }, {
        key: "clear",
        value: function(e, t, r, i) {
            for (var n = e.getRenderTarget(), a = 0; a < 6; a++)
                e.setRenderTarget(this, a),
                e.clear(t, r, i);
            e.setRenderTarget(n)
        }
    }]),
    r
}();
WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = !0;
var _vector1 = new Vector3
  , _vector2 = new Vector3
  , _normalMatrix = new Matrix3
  , Plane = function() {
    function e() {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Vector3(1,0,0)
          , r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
        _classCallCheck(this, e),
        this.normal = t,
        this.constant = r
    }
    return _createClass(e, [{
        key: "set",
        value: function(e, t) {
            return this.normal.copy(e),
            this.constant = t,
            this
        }
    }, {
        key: "setComponents",
        value: function(e, t, r, i) {
            return this.normal.set(e, t, r),
            this.constant = i,
            this
        }
    }, {
        key: "setFromNormalAndCoplanarPoint",
        value: function(e, t) {
            return this.normal.copy(e),
            this.constant = -t.dot(this.normal),
            this
        }
    }, {
        key: "setFromCoplanarPoints",
        value: function(e, t, r) {
            var i = _vector1.subVectors(r, t).cross(_vector2.subVectors(e, t)).normalize();
            return this.setFromNormalAndCoplanarPoint(i, e),
            this
        }
    }, {
        key: "copy",
        value: function(e) {
            return this.normal.copy(e.normal),
            this.constant = e.constant,
            this
        }
    }, {
        key: "normalize",
        value: function() {
            var e = 1 / this.normal.length();
            return this.normal.multiplyScalar(e),
            this.constant *= e,
            this
        }
    }, {
        key: "negate",
        value: function() {
            return this.constant *= -1,
            this.normal.negate(),
            this
        }
    }, {
        key: "distanceToPoint",
        value: function(e) {
            return this.normal.dot(e) + this.constant
        }
    }, {
        key: "distanceToSphere",
        value: function(e) {
            return this.distanceToPoint(e.center) - e.radius
        }
    }, {
        key: "projectPoint",
        value: function(e, t) {
            return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
        }
    }, {
        key: "intersectLine",
        value: function(e, t) {
            var r = e.delta(_vector1)
              , i = this.normal.dot(r);
            if (0 === i)
                return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
            var n = -(e.start.dot(this.normal) + this.constant) / i;
            return n < 0 || n > 1 ? null : t.copy(r).multiplyScalar(n).add(e.start)
        }
    }, {
        key: "intersectsLine",
        value: function(e) {
            var t = this.distanceToPoint(e.start)
              , r = this.distanceToPoint(e.end);
            return t < 0 && r > 0 || r < 0 && t > 0
        }
    }, {
        key: "intersectsBox",
        value: function(e) {
            return e.intersectsPlane(this)
        }
    }, {
        key: "intersectsSphere",
        value: function(e) {
            return e.intersectsPlane(this)
        }
    }, {
        key: "coplanarPoint",
        value: function(e) {
            return e.copy(this.normal).multiplyScalar(-this.constant)
        }
    }, {
        key: "applyMatrix4",
        value: function(e, t) {
            var r = t || _normalMatrix.getNormalMatrix(e)
              , i = this.coplanarPoint(_vector1).applyMatrix4(e)
              , n = this.normal.applyMatrix3(r).normalize();
            return this.constant = -i.dot(n),
            this
        }
    }, {
        key: "translate",
        value: function(e) {
            return this.constant -= e.dot(this.normal),
            this
        }
    }, {
        key: "equals",
        value: function(e) {
            return e.normal.equals(this.normal) && e.constant === this.constant
        }
    }, {
        key: "clone",
        value: function() {
            return (new this.constructor).copy(this)
        }
    }]),
    e
}();
Plane.prototype.isPlane = !0;
var _sphere$2 = new Sphere
  , _vector$7 = new Vector3
  , Frustum = function() {
    function e() {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Plane
          , r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Plane
          , i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : new Plane
          , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : new Plane
          , a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : new Plane
          , o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : new Plane;
        _classCallCheck(this, e),
        this.planes = [t, r, i, n, a, o]
    }
    return _createClass(e, [{
        key: "set",
        value: function(e, t, r, i, n, a) {
            var o = this.planes;
            return o[0].copy(e),
            o[1].copy(t),
            o[2].copy(r),
            o[3].copy(i),
            o[4].copy(n),
            o[5].copy(a),
            this
        }
    }, {
        key: "copy",
        value: function(e) {
            for (var t = this.planes, r = 0; r < 6; r++)
                t[r].copy(e.planes[r]);
            return this
        }
    }, {
        key: "setFromProjectionMatrix",
        value: function(e) {
            var t = this.planes
              , r = e.elements
              , i = r[0]
              , n = r[1]
              , a = r[2]
              , o = r[3]
              , s = r[4]
              , l = r[5]
              , u = r[6]
              , c = r[7]
              , h = r[8]
              , d = r[9]
              , p = r[10]
              , f = r[11]
              , m = r[12]
              , v = r[13]
              , g = r[14]
              , _ = r[15];
            return t[0].setComponents(o - i, c - s, f - h, _ - m).normalize(),
            t[1].setComponents(o + i, c + s, f + h, _ + m).normalize(),
            t[2].setComponents(o + n, c + l, f + d, _ + v).normalize(),
            t[3].setComponents(o - n, c - l, f - d, _ - v).normalize(),
            t[4].setComponents(o - a, c - u, f - p, _ - g).normalize(),
            t[5].setComponents(o + a, c + u, f + p, _ + g).normalize(),
            this
        }
    }, {
        key: "intersectsObject",
        value: function(e) {
            var t = e.geometry;
            return null === t.boundingSphere && t.computeBoundingSphere(),
            _sphere$2.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),
            this.intersectsSphere(_sphere$2)
        }
    }, {
        key: "intersectsSprite",
        value: function(e) {
            return _sphere$2.center.set(0, 0, 0),
            _sphere$2.radius = .7071067811865476,
            _sphere$2.applyMatrix4(e.matrixWorld),
            this.intersectsSphere(_sphere$2)
        }
    }, {
        key: "intersectsSphere",
        value: function(e) {
            for (var t = this.planes, r = e.center, i = -e.radius, n = 0; n < 6; n++)
                if (t[n].distanceToPoint(r) < i)
                    return !1;
            return !0
        }
    }, {
        key: "intersectsBox",
        value: function(e) {
            for (var t = this.planes, r = 0; r < 6; r++) {
                var i = t[r];
                if (_vector$7.x = i.normal.x > 0 ? e.max.x : e.min.x,
                _vector$7.y = i.normal.y > 0 ? e.max.y : e.min.y,
                _vector$7.z = i.normal.z > 0 ? e.max.z : e.min.z,
                i.distanceToPoint(_vector$7) < 0)
                    return !1
            }
            return !0
        }
    }, {
        key: "containsPoint",
        value: function(e) {
            for (var t = this.planes, r = 0; r < 6; r++)
                if (t[r].distanceToPoint(e) < 0)
                    return !1;
            return !0
        }
    }, {
        key: "clone",
        value: function() {
            return (new this.constructor).copy(this)
        }
    }]),
    e
}();
function WebGLAnimation() {
    var e = null
      , t = !1
      , r = null
      , i = null;
    function n(t, a) {
        r(t, a),
        i = e.requestAnimationFrame(n)
    }
    return {
        start: function() {
            !0 !== t && null !== r && (i = e.requestAnimationFrame(n),
            t = !0)
        },
        stop: function() {
            e.cancelAnimationFrame(i),
            t = !1
        },
        setAnimationLoop: function(e) {
            r = e
        },
        setContext: function(t) {
            e = t
        }
    }
}
function WebGLAttributes(e, t) {
    var r = t.isWebGL2
      , i = new WeakMap;
    return {
        get: function(e) {
            return e.isInterleavedBufferAttribute && (e = e.data),
            i.get(e)
        },
        remove: function(t) {
            t.isInterleavedBufferAttribute && (t = t.data);
            var r = i.get(t);
            r && (e.deleteBuffer(r.buffer),
            i.delete(t))
        },
        update: function(t, n) {
            if (t.isGLBufferAttribute) {
                var a = i.get(t);
                (!a || a.version < t.version) && i.set(t, {
                    buffer: t.buffer,
                    type: t.type,
                    bytesPerElement: t.elementSize,
                    version: t.version
                })
            } else {
                t.isInterleavedBufferAttribute && (t = t.data);
                var o = i.get(t);
                void 0 === o ? i.set(t, function(t, i) {
                    var n, a = t.array, o = t.usage, s = e.createBuffer();
                    if (e.bindBuffer(i, s),
                    e.bufferData(i, a, o),
                    t.onUploadCallback(),
                    a instanceof Float32Array)
                        n = 5126;
                    else if (a instanceof Uint16Array)
                        if (t.isFloat16BufferAttribute) {
                            if (!r)
                                throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
                            n = 5131
                        } else
                            n = 5123;
                    else if (a instanceof Int16Array)
                        n = 5122;
                    else if (a instanceof Uint32Array)
                        n = 5125;
                    else if (a instanceof Int32Array)
                        n = 5124;
                    else if (a instanceof Int8Array)
                        n = 5120;
                    else if (a instanceof Uint8Array)
                        n = 5121;
                    else {
                        if (!(a instanceof Uint8ClampedArray))
                            throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + a);
                        n = 5121
                    }
                    return {
                        buffer: s,
                        type: n,
                        bytesPerElement: a.BYTES_PER_ELEMENT,
                        version: t.version
                    }
                }(t, n)) : o.version < t.version && (function(t, i, n) {
                    var a = i.array
                      , o = i.updateRange;
                    e.bindBuffer(n, t),
                    -1 === o.count ? e.bufferSubData(n, 0, a) : (r ? e.bufferSubData(n, o.offset * a.BYTES_PER_ELEMENT, a, o.offset, o.count) : e.bufferSubData(n, o.offset * a.BYTES_PER_ELEMENT, a.subarray(o.offset, o.offset + o.count)),
                    o.count = -1)
                }(o.buffer, t, n),
                o.version = t.version)
            }
        }
    }
}
var PlaneGeometry = function(e) {
    _inherits(r, BufferGeometry);
    var t = _createSuper(r);
    function r() {
        var e, i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
        _classCallCheck(this, r),
        (e = t.call(this)).type = "PlaneGeometry",
        e.parameters = {
            width: i,
            height: n,
            widthSegments: a,
            heightSegments: o
        };
        for (var s = i / 2, l = n / 2, u = Math.floor(a), c = Math.floor(o), h = u + 1, d = c + 1, p = i / u, f = n / c, m = [], v = [], g = [], _ = [], y = 0; y < d; y++)
            for (var x = y * f - l, b = 0; b < h; b++) {
                var S = b * p - s;
                v.push(S, -x, 0),
                g.push(0, 0, 1),
                _.push(b / u),
                _.push(1 - y / c)
            }
        for (var w = 0; w < c; w++)
            for (var M = 0; M < u; M++) {
                var T = M + h * w
                  , C = M + h * (w + 1)
                  , E = M + 1 + h * (w + 1)
                  , P = M + 1 + h * w;
                m.push(T, C, P),
                m.push(C, E, P)
            }
        return e.setIndex(m),
        e.setAttribute("position", new Float32BufferAttribute(v,3)),
        e.setAttribute("normal", new Float32BufferAttribute(g,3)),
        e.setAttribute("uv", new Float32BufferAttribute(_,2)),
        e
    }
    return _createClass(r, null, [{
        key: "fromJSON",
        value: function(e) {
            return new r(e.width,e.height,e.widthSegments,e.heightSegments)
        }
    }]),
    r
}()
  , alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif"
  , alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif"
  , alphatest_fragment = "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif"
  , alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif"
  , aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif"
  , aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif"
  , begin_vertex = "vec3 transformed = vec3( position );"
  , beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif"
  , bsdfs = "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif"
  , bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif"
  , clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif"
  , clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif"
  , clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif"
  , clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif"
  , color_fragment = "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif"
  , color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif"
  , color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif"
  , color_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif"
  , common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}"
  , cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif"
  , defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif"
  , displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif"
  , displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif"
  , emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif"
  , emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif"
  , encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );"
  , encodings_pars_fragment = "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}"
  , envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif"
  , envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif"
  , envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif"
  , envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif"
  , envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif"
  , fog_vertex = "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif"
  , fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif"
  , fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif"
  , fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif"
  , gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}"
  , lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif"
  , lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif"
  , lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif"
  , lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif"
  , envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif"
  , lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;"
  , lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)"
  , lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;"
  , lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)"
  , lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif"
  , lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}"
  , lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif"
  , lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif"
  , lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif"
  , logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif"
  , logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif"
  , logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif"
  , logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif"
  , map_fragment = "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif"
  , map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif"
  , map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif"
  , map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif"
  , metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif"
  , metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif"
  , morphcolor_vertex = "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif"
  , morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif"
  , morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif"
  , morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif"
  , normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;"
  , normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif"
  , normal_pars_fragment = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif"
  , normal_pars_vertex = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif"
  , normal_vertex = "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif"
  , normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif"
  , clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif"
  , clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif"
  , clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif"
  , output_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );"
  , packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}"
  , premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif"
  , project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;"
  , dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif"
  , dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif"
  , roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif"
  , roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif"
  , shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif"
  , shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif"
  , shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif"
  , shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}"
  , skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif"
  , skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif"
  , skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif"
  , skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif"
  , specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif"
  , specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif"
  , tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif"
  , tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }"
  , transmission_fragment = "#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif"
  , transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif"
  , uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif"
  , uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif"
  , uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif"
  , uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif"
  , uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif"
  , uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif"
  , worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif"
  , vertex$g = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}"
  , fragment$g = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tgl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n\t#endif\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}"
  , vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}"
  , fragment$f = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}"
  , vertex$e = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}"
  , fragment$e = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}"
  , vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}"
  , fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}"
  , vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}"
  , fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}"
  , vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
  , fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}"
  , vertex$a = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}"
  , fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}"
  , vertex$9 = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}"
  , fragment$9 = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}"
  , vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}"
  , fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}"
  , vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}"
  , fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}"
  , vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}"
  , fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}"
  , vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}"
  , fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}"
  , vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}"
  , fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}"
  , vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}"
  , fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}"
  , vertex$2 = "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}"
  , fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"
  , vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
  , fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"
  , ShaderChunk = {
    alphamap_fragment,
    alphamap_pars_fragment,
    alphatest_fragment,
    alphatest_pars_fragment,
    aomap_fragment,
    aomap_pars_fragment,
    begin_vertex,
    beginnormal_vertex,
    bsdfs,
    bumpmap_pars_fragment,
    clipping_planes_fragment,
    clipping_planes_pars_fragment,
    clipping_planes_pars_vertex,
    clipping_planes_vertex,
    color_fragment,
    color_pars_fragment,
    color_pars_vertex,
    color_vertex,
    common,
    cube_uv_reflection_fragment,
    defaultnormal_vertex,
    displacementmap_pars_vertex,
    displacementmap_vertex,
    emissivemap_fragment,
    emissivemap_pars_fragment,
    encodings_fragment,
    encodings_pars_fragment,
    envmap_fragment,
    envmap_common_pars_fragment,
    envmap_pars_fragment,
    envmap_pars_vertex,
    envmap_physical_pars_fragment,
    envmap_vertex,
    fog_vertex,
    fog_pars_vertex,
    fog_fragment,
    fog_pars_fragment,
    gradientmap_pars_fragment,
    lightmap_fragment,
    lightmap_pars_fragment,
    lights_lambert_vertex,
    lights_pars_begin,
    lights_toon_fragment,
    lights_toon_pars_fragment,
    lights_phong_fragment,
    lights_phong_pars_fragment,
    lights_physical_fragment,
    lights_physical_pars_fragment,
    lights_fragment_begin,
    lights_fragment_maps,
    lights_fragment_end,
    logdepthbuf_fragment,
    logdepthbuf_pars_fragment,
    logdepthbuf_pars_vertex,
    logdepthbuf_vertex,
    map_fragment,
    map_pars_fragment,
    map_particle_fragment,
    map_particle_pars_fragment,
    metalnessmap_fragment,
    metalnessmap_pars_fragment,
    morphcolor_vertex,
    morphnormal_vertex,
    morphtarget_pars_vertex,
    morphtarget_vertex,
    normal_fragment_begin,
    normal_fragment_maps,
    normal_pars_fragment,
    normal_pars_vertex,
    normal_vertex,
    normalmap_pars_fragment,
    clearcoat_normal_fragment_begin,
    clearcoat_normal_fragment_maps,
    clearcoat_pars_fragment,
    output_fragment,
    packing,
    premultiplied_alpha_fragment,
    project_vertex,
    dithering_fragment,
    dithering_pars_fragment,
    roughnessmap_fragment,
    roughnessmap_pars_fragment,
    shadowmap_pars_fragment,
    shadowmap_pars_vertex,
    shadowmap_vertex,
    shadowmask_pars_fragment,
    skinbase_vertex,
    skinning_pars_vertex,
    skinning_vertex,
    skinnormal_vertex,
    specularmap_fragment,
    specularmap_pars_fragment,
    tonemapping_fragment,
    tonemapping_pars_fragment,
    transmission_fragment,
    transmission_pars_fragment,
    uv_pars_fragment,
    uv_pars_vertex,
    uv_vertex,
    uv2_pars_fragment,
    uv2_pars_vertex,
    uv2_vertex,
    worldpos_vertex,
    background_vert: vertex$g,
    background_frag: fragment$g,
    cube_vert: vertex$f,
    cube_frag: fragment$f,
    depth_vert: vertex$e,
    depth_frag: fragment$e,
    distanceRGBA_vert: vertex$d,
    distanceRGBA_frag: fragment$d,
    equirect_vert: vertex$c,
    equirect_frag: fragment$c,
    linedashed_vert: vertex$b,
    linedashed_frag: fragment$b,
    meshbasic_vert: vertex$a,
    meshbasic_frag: fragment$a,
    meshlambert_vert: vertex$9,
    meshlambert_frag: fragment$9,
    meshmatcap_vert: vertex$8,
    meshmatcap_frag: fragment$8,
    meshnormal_vert: vertex$7,
    meshnormal_frag: fragment$7,
    meshphong_vert: vertex$6,
    meshphong_frag: fragment$6,
    meshphysical_vert: vertex$5,
    meshphysical_frag: fragment$5,
    meshtoon_vert: vertex$4,
    meshtoon_frag: fragment$4,
    points_vert: vertex$3,
    points_frag: fragment$3,
    shadow_vert: vertex$2,
    shadow_frag: fragment$2,
    sprite_vert: vertex$1,
    sprite_frag: fragment$1
}
  , UniformsLib = {
    common: {
        diffuse: {
            value: new Color(16777215)
        },
        opacity: {
            value: 1
        },
        map: {
            value: null
        },
        uvTransform: {
            value: new Matrix3
        },
        uv2Transform: {
            value: new Matrix3
        },
        alphaMap: {
            value: null
        },
        alphaTest: {
            value: 0
        }
    },
    specularmap: {
        specularMap: {
            value: null
        }
    },
    envmap: {
        envMap: {
            value: null
        },
        flipEnvMap: {
            value: -1
        },
        reflectivity: {
            value: 1
        },
        ior: {
            value: 1.5
        },
        refractionRatio: {
            value: .98
        }
    },
    aomap: {
        aoMap: {
            value: null
        },
        aoMapIntensity: {
            value: 1
        }
    },
    lightmap: {
        lightMap: {
            value: null
        },
        lightMapIntensity: {
            value: 1
        }
    },
    emissivemap: {
        emissiveMap: {
            value: null
        }
    },
    bumpmap: {
        bumpMap: {
            value: null
        },
        bumpScale: {
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            value: null
        },
        normalScale: {
            value: new Vector2(1,1)
        }
    },
    displacementmap: {
        displacementMap: {
            value: null
        },
        displacementScale: {
            value: 1
        },
        displacementBias: {
            value: 0
        }
    },
    roughnessmap: {
        roughnessMap: {
            value: null
        }
    },
    metalnessmap: {
        metalnessMap: {
            value: null
        }
    },
    gradientmap: {
        gradientMap: {
            value: null
        }
    },
    fog: {
        fogDensity: {
            value: 25e-5
        },
        fogNear: {
            value: 1
        },
        fogFar: {
            value: 2e3
        },
        fogColor: {
            value: new Color(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            value: []
        },
        lightProbe: {
            value: []
        },
        directionalLights: {
            value: [],
            properties: {
                direction: {},
                color: {}
            }
        },
        directionalLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        directionalShadowMap: {
            value: []
        },
        directionalShadowMatrix: {
            value: []
        },
        spotLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {}
            }
        },
        spotLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        spotShadowMap: {
            value: []
        },
        spotShadowMatrix: {
            value: []
        },
        pointLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                decay: {},
                distance: {}
            }
        },
        pointLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {}
            }
        },
        pointShadowMap: {
            value: []
        },
        pointShadowMatrix: {
            value: []
        },
        hemisphereLights: {
            value: [],
            properties: {
                direction: {},
                skyColor: {},
                groundColor: {}
            }
        },
        rectAreaLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                width: {},
                height: {}
            }
        },
        ltc_1: {
            value: null
        },
        ltc_2: {
            value: null
        }
    },
    points: {
        diffuse: {
            value: new Color(16777215)
        },
        opacity: {
            value: 1
        },
        size: {
            value: 1
        },
        scale: {
            value: 1
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        alphaTest: {
            value: 0
        },
        uvTransform: {
            value: new Matrix3
        }
    },
    sprite: {
        diffuse: {
            value: new Color(16777215)
        },
        opacity: {
            value: 1
        },
        center: {
            value: new Vector2(.5,.5)
        },
        rotation: {
            value: 0
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        alphaTest: {
            value: 0
        },
        uvTransform: {
            value: new Matrix3
        }
    }
}
  , ShaderLib = {
    basic: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]),
        vertexShader: ShaderChunk.meshbasic_vert,
        fragmentShader: ShaderChunk.meshbasic_frag
    },
    lambert: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.fog, UniformsLib.lights, {
            emissive: {
                value: new Color(0)
            }
        }]),
        vertexShader: ShaderChunk.meshlambert_vert,
        fragmentShader: ShaderChunk.meshlambert_frag
    },
    phong: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, {
            emissive: {
                value: new Color(0)
            },
            specular: {
                value: new Color(1118481)
            },
            shininess: {
                value: 30
            }
        }]),
        vertexShader: ShaderChunk.meshphong_vert,
        fragmentShader: ShaderChunk.meshphong_frag
    },
    standard: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, {
            emissive: {
                value: new Color(0)
            },
            roughness: {
                value: 1
            },
            metalness: {
                value: 0
            },
            envMapIntensity: {
                value: 1
            }
        }]),
        vertexShader: ShaderChunk.meshphysical_vert,
        fragmentShader: ShaderChunk.meshphysical_frag
    },
    toon: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, {
            emissive: {
                value: new Color(0)
            }
        }]),
        vertexShader: ShaderChunk.meshtoon_vert,
        fragmentShader: ShaderChunk.meshtoon_frag
    },
    matcap: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, {
            matcap: {
                value: null
            }
        }]),
        vertexShader: ShaderChunk.meshmatcap_vert,
        fragmentShader: ShaderChunk.meshmatcap_frag
    },
    points: {
        uniforms: mergeUniforms([UniformsLib.points, UniformsLib.fog]),
        vertexShader: ShaderChunk.points_vert,
        fragmentShader: ShaderChunk.points_frag
    },
    dashed: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.fog, {
            scale: {
                value: 1
            },
            dashSize: {
                value: 1
            },
            totalSize: {
                value: 2
            }
        }]),
        vertexShader: ShaderChunk.linedashed_vert,
        fragmentShader: ShaderChunk.linedashed_frag
    },
    depth: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap]),
        vertexShader: ShaderChunk.depth_vert,
        fragmentShader: ShaderChunk.depth_frag
    },
    normal: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, {
            opacity: {
                value: 1
            }
        }]),
        vertexShader: ShaderChunk.meshnormal_vert,
        fragmentShader: ShaderChunk.meshnormal_frag
    },
    sprite: {
        uniforms: mergeUniforms([UniformsLib.sprite, UniformsLib.fog]),
        vertexShader: ShaderChunk.sprite_vert,
        fragmentShader: ShaderChunk.sprite_frag
    },
    background: {
        uniforms: {
            uvTransform: {
                value: new Matrix3
            },
            t2D: {
                value: null
            }
        },
        vertexShader: ShaderChunk.background_vert,
        fragmentShader: ShaderChunk.background_frag
    },
    cube: {
        uniforms: mergeUniforms([UniformsLib.envmap, {
            opacity: {
                value: 1
            }
        }]),
        vertexShader: ShaderChunk.cube_vert,
        fragmentShader: ShaderChunk.cube_frag
    },
    equirect: {
        uniforms: {
            tEquirect: {
                value: null
            }
        },
        vertexShader: ShaderChunk.equirect_vert,
        fragmentShader: ShaderChunk.equirect_frag
    },
    distanceRGBA: {
        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, {
            referencePosition: {
                value: new Vector3
            },
            nearDistance: {
                value: 1
            },
            farDistance: {
                value: 1e3
            }
        }]),
        vertexShader: ShaderChunk.distanceRGBA_vert,
        fragmentShader: ShaderChunk.distanceRGBA_frag
    },
    shadow: {
        uniforms: mergeUniforms([UniformsLib.lights, UniformsLib.fog, {
            color: {
                value: new Color(0)
            },
            opacity: {
                value: 1
            }
        }]),
        vertexShader: ShaderChunk.shadow_vert,
        fragmentShader: ShaderChunk.shadow_frag
    }
};
function WebGLBackground(e, t, r, i, n, a) {
    var o, s, l = new Color(0), u = !0 === n ? 0 : 1, c = null, h = 0, d = null;
    function p(e, t) {
        r.buffers.color.setClear(e.r, e.g, e.b, t, a)
    }
    return {
        getClearColor: function() {
            return l
        },
        setClearColor: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
            l.set(e),
            p(l, u = t)
        },
        getClearAlpha: function() {
            return u
        },
        setClearAlpha: function(e) {
            p(l, u = e)
        },
        render: function(r, n) {
            var a = !1
              , f = !0 === n.isScene ? n.background : null;
            f && f.isTexture && (f = t.get(f));
            var m = e.xr
              , v = m.getSession && m.getSession();
            v && "additive" === v.environmentBlendMode && (f = null),
            null === f ? p(l, u) : f && f.isColor && (p(f, 1),
            a = !0),
            (e.autoClear || a) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
            f && (f.isCubeTexture || f.mapping === CubeUVReflectionMapping) ? (void 0 === s && ((s = new Mesh(new BoxGeometry(1,1,1),new ShaderMaterial({
                name: "BackgroundCubeMaterial",
                uniforms: cloneUniforms(ShaderLib.cube.uniforms),
                vertexShader: ShaderLib.cube.vertexShader,
                fragmentShader: ShaderLib.cube.fragmentShader,
                side: BackSide,
                depthTest: !1,
                depthWrite: !1,
                fog: !1
            }))).geometry.deleteAttribute("normal"),
            s.geometry.deleteAttribute("uv"),
            s.onBeforeRender = function(e, t, r) {
                this.matrixWorld.copyPosition(r.matrixWorld)
            }
            ,
            Object.defineProperty(s.material, "envMap", {
                get: function() {
                    return this.uniforms.envMap.value
                }
            }),
            i.update(s)),
            s.material.uniforms.envMap.value = f,
            s.material.uniforms.flipEnvMap.value = f.isCubeTexture && !1 === f.isRenderTargetTexture ? -1 : 1,
            c === f && h === f.version && d === e.toneMapping || (s.material.needsUpdate = !0,
            c = f,
            h = f.version,
            d = e.toneMapping),
            r.unshift(s, s.geometry, s.material, 0, 0, null)) : f && f.isTexture && (void 0 === o && ((o = new Mesh(new PlaneGeometry(2,2),new ShaderMaterial({
                name: "BackgroundMaterial",
                uniforms: cloneUniforms(ShaderLib.background.uniforms),
                vertexShader: ShaderLib.background.vertexShader,
                fragmentShader: ShaderLib.background.fragmentShader,
                side: FrontSide,
                depthTest: !1,
                depthWrite: !1,
                fog: !1
            }))).geometry.deleteAttribute("normal"),
            Object.defineProperty(o.material, "map", {
                get: function() {
                    return this.uniforms.t2D.value
                }
            }),
            i.update(o)),
            o.material.uniforms.t2D.value = f,
            !0 === f.matrixAutoUpdate && f.updateMatrix(),
            o.material.uniforms.uvTransform.value.copy(f.matrix),
            c === f && h === f.version && d === e.toneMapping || (o.material.needsUpdate = !0,
            c = f,
            h = f.version,
            d = e.toneMapping),
            r.unshift(o, o.geometry, o.material, 0, 0, null))
        }
    }
}
function WebGLBindingStates(e, t, r, i) {
    var n = e.getParameter(34921)
      , a = i.isWebGL2 ? null : t.get("OES_vertex_array_object")
      , o = i.isWebGL2 || null !== a
      , s = {}
      , l = p(null)
      , u = l
      , c = !1;
    function h(t) {
        return i.isWebGL2 ? e.bindVertexArray(t) : a.bindVertexArrayOES(t)
    }
    function d(t) {
        return i.isWebGL2 ? e.deleteVertexArray(t) : a.deleteVertexArrayOES(t)
    }
    function p(e) {
        for (var t = [], r = [], i = [], a = 0; a < n; a++)
            t[a] = 0,
            r[a] = 0,
            i[a] = 0;
        return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: t,
            enabledAttributes: r,
            attributeDivisors: i,
            object: e,
            attributes: {},
            index: null
        }
    }
    function f() {
        for (var e = u.newAttributes, t = 0, r = e.length; t < r; t++)
            e[t] = 0
    }
    function m(e) {
        v(e, 0)
    }
    function v(r, n) {
        var a = u.newAttributes
          , o = u.enabledAttributes
          , s = u.attributeDivisors;
        a[r] = 1,
        0 === o[r] && (e.enableVertexAttribArray(r),
        o[r] = 1),
        s[r] !== n && ((i.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](r, n),
        s[r] = n)
    }
    function g() {
        for (var t = u.newAttributes, r = u.enabledAttributes, i = 0, n = r.length; i < n; i++)
            r[i] !== t[i] && (e.disableVertexAttribArray(i),
            r[i] = 0)
    }
    function _(t, r, n, a, o, s) {
        !0 !== i.isWebGL2 || 5124 !== n && 5125 !== n ? e.vertexAttribPointer(t, r, n, a, o, s) : e.vertexAttribIPointer(t, r, n, o, s)
    }
    function y() {
        x(),
        c = !0,
        u !== l && h((u = l).object)
    }
    function x() {
        l.geometry = null,
        l.program = null,
        l.wireframe = !1
    }
    return {
        setup: function(n, l, d, y, x) {
            var b = !1;
            if (o) {
                var S = function(t, r, n) {
                    var o = !0 === n.wireframe
                      , l = s[t.id];
                    void 0 === l && (l = {},
                    s[t.id] = l);
                    var u = l[r.id];
                    void 0 === u && (u = {},
                    l[r.id] = u);
                    var c = u[o];
                    return void 0 === c && (c = p(i.isWebGL2 ? e.createVertexArray() : a.createVertexArrayOES()),
                    u[o] = c),
                    c
                }(y, d, l);
                u !== S && h((u = S).object),
                b = function(e, t) {
                    var r = u.attributes
                      , i = e.attributes
                      , n = 0;
                    for (var a in i) {
                        var o = r[a]
                          , s = i[a];
                        if (void 0 === o)
                            return !0;
                        if (o.attribute !== s)
                            return !0;
                        if (o.data !== s.data)
                            return !0;
                        n++
                    }
                    return u.attributesNum !== n || u.index !== t
                }(y, x),
                b && function(e, t) {
                    var r = {}
                      , i = e.attributes
                      , n = 0;
                    for (var a in i) {
                        var o = i[a]
                          , s = {};
                        s.attribute = o,
                        o.data && (s.data = o.data),
                        r[a] = s,
                        n++
                    }
                    u.attributes = r,
                    u.attributesNum = n,
                    u.index = t
                }(y, x)
            } else {
                var w = !0 === l.wireframe;
                u.geometry === y.id && u.program === d.id && u.wireframe === w || (u.geometry = y.id,
                u.program = d.id,
                u.wireframe = w,
                b = !0)
            }
            !0 === n.isInstancedMesh && (b = !0),
            null !== x && r.update(x, 34963),
            (b || c) && (c = !1,
            function(n, a, o, s) {
                if (!1 !== i.isWebGL2 || !n.isInstancedMesh && !s.isInstancedBufferGeometry || null !== t.get("ANGLE_instanced_arrays")) {
                    f();
                    var l = s.attributes
                      , u = o.getAttributes()
                      , c = a.defaultAttributeValues;
                    for (var h in u) {
                        var d = u[h];
                        if (d.location >= 0) {
                            var p = l[h];
                            if (void 0 === p && ("instanceMatrix" === h && n.instanceMatrix && (p = n.instanceMatrix),
                            "instanceColor" === h && n.instanceColor && (p = n.instanceColor)),
                            void 0 !== p) {
                                var y = p.normalized
                                  , x = p.itemSize
                                  , b = r.get(p);
                                if (void 0 === b)
                                    continue;
                                var S = b.buffer
                                  , w = b.type
                                  , M = b.bytesPerElement;
                                if (p.isInterleavedBufferAttribute) {
                                    var T = p.data
                                      , C = T.stride
                                      , E = p.offset;
                                    if (T.isInstancedInterleavedBuffer) {
                                        for (var P = 0; P < d.locationSize; P++)
                                            v(d.location + P, T.meshPerAttribute);
                                        !0 !== n.isInstancedMesh && void 0 === s._maxInstanceCount && (s._maxInstanceCount = T.meshPerAttribute * T.count)
                                    } else
                                        for (var A = 0; A < d.locationSize; A++)
                                            m(d.location + A);
                                    e.bindBuffer(34962, S);
                                    for (var k = 0; k < d.locationSize; k++)
                                        _(d.location + k, x / d.locationSize, w, y, C * M, (E + x / d.locationSize * k) * M)
                                } else {
                                    if (p.isInstancedBufferAttribute) {
                                        for (var L = 0; L < d.locationSize; L++)
                                            v(d.location + L, p.meshPerAttribute);
                                        !0 !== n.isInstancedMesh && void 0 === s._maxInstanceCount && (s._maxInstanceCount = p.meshPerAttribute * p.count)
                                    } else
                                        for (var R = 0; R < d.locationSize; R++)
                                            m(d.location + R);
                                    e.bindBuffer(34962, S);
                                    for (var D = 0; D < d.locationSize; D++)
                                        _(d.location + D, x / d.locationSize, w, y, x * M, x / d.locationSize * D * M)
                                }
                            } else if (void 0 !== c) {
                                var I = c[h];
                                if (void 0 !== I)
                                    switch (I.length) {
                                    case 2:
                                        e.vertexAttrib2fv(d.location, I);
                                        break;
                                    case 3:
                                        e.vertexAttrib3fv(d.location, I);
                                        break;
                                    case 4:
                                        e.vertexAttrib4fv(d.location, I);
                                        break;
                                    default:
                                        e.vertexAttrib1fv(d.location, I)
                                    }
                            }
                        }
                    }
                    g()
                }
            }(n, l, d, y),
            null !== x && e.bindBuffer(34963, r.get(x).buffer))
        },
        reset: y,
        resetDefaultState: x,
        dispose: function() {
            for (var e in y(),
            s) {
                var t = s[e];
                for (var r in t) {
                    var i = t[r];
                    for (var n in i)
                        d(i[n].object),
                        delete i[n];
                    delete t[r]
                }
                delete s[e]
            }
        },
        releaseStatesOfGeometry: function(e) {
            if (void 0 !== s[e.id]) {
                var t = s[e.id];
                for (var r in t) {
                    var i = t[r];
                    for (var n in i)
                        d(i[n].object),
                        delete i[n];
                    delete t[r]
                }
                delete s[e.id]
            }
        },
        releaseStatesOfProgram: function(e) {
            for (var t in s) {
                var r = s[t];
                if (void 0 !== r[e.id]) {
                    var i = r[e.id];
                    for (var n in i)
                        d(i[n].object),
                        delete i[n];
                    delete r[e.id]
                }
            }
        },
        initAttributes: f,
        enableAttribute: m,
        disableUnusedAttributes: g
    }
}
function WebGLBufferRenderer(e, t, r, i) {
    var n, a = i.isWebGL2;
    this.setMode = function(e) {
        n = e
    }
    ,
    this.render = function(t, i) {
        e.drawArrays(n, t, i),
        r.update(i, n, 1)
    }
    ,
    this.renderInstances = function(i, o, s) {
        if (0 !== s) {
            var l, u;
            if (a)
                l = e,
                u = "drawArraysInstanced";
            else if (u = "drawArraysInstancedANGLE",
            null === (l = t.get("ANGLE_instanced_arrays")))
                return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            l[u](n, i, o, s),
            r.update(o, n, s)
        }
    }
}
function WebGLCapabilities(e, t, r) {
    var i;
    function n(t) {
        if ("highp" === t) {
            if (e.getShaderPrecisionFormat(35633, 36338).precision > 0 && e.getShaderPrecisionFormat(35632, 36338).precision > 0)
                return "highp";
            t = "mediump"
        }
        return "mediump" === t && e.getShaderPrecisionFormat(35633, 36337).precision > 0 && e.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
    }
    var a = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && e instanceof WebGL2ComputeRenderingContext
      , o = void 0 !== r.precision ? r.precision : "highp"
      , s = n(o);
    s !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", s, "instead."),
    o = s);
    var l = a || t.has("WEBGL_draw_buffers")
      , u = !0 === r.logarithmicDepthBuffer
      , c = e.getParameter(34930)
      , h = e.getParameter(35660)
      , d = e.getParameter(3379)
      , p = e.getParameter(34076)
      , f = e.getParameter(34921)
      , m = e.getParameter(36347)
      , v = e.getParameter(36348)
      , g = e.getParameter(36349)
      , _ = h > 0
      , y = a || t.has("OES_texture_float");
    return {
        isWebGL2: a,
        drawBuffers: l,
        getMaxAnisotropy: function() {
            if (void 0 !== i)
                return i;
            if (!0 === t.has("EXT_texture_filter_anisotropic")) {
                var r = t.get("EXT_texture_filter_anisotropic");
                i = e.getParameter(r.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
            } else
                i = 0;
            return i
        },
        getMaxPrecision: n,
        precision: o,
        logarithmicDepthBuffer: u,
        maxTextures: c,
        maxVertexTextures: h,
        maxTextureSize: d,
        maxCubemapSize: p,
        maxAttributes: f,
        maxVertexUniforms: m,
        maxVaryings: v,
        maxFragmentUniforms: g,
        vertexTextures: _,
        floatFragmentTextures: y,
        floatVertexTextures: _ && y,
        maxSamples: a ? e.getParameter(36183) : 0
    }
}
function WebGLClipping(e) {
    var t = this
      , r = null
      , i = 0
      , n = !1
      , a = !1
      , o = new Plane
      , s = new Matrix3
      , l = {
        value: null,
        needsUpdate: !1
    };
    function u() {
        l.value !== r && (l.value = r,
        l.needsUpdate = i > 0),
        t.numPlanes = i,
        t.numIntersection = 0
    }
    function c(e, r, i, n) {
        var a = null !== e ? e.length : 0
          , u = null;
        if (0 !== a) {
            if (u = l.value,
            !0 !== n || null === u) {
                var c = i + 4 * a
                  , h = r.matrixWorldInverse;
                s.getNormalMatrix(h),
                (null === u || u.length < c) && (u = new Float32Array(c));
                for (var d = 0, p = i; d !== a; ++d,
                p += 4)
                    o.copy(e[d]).applyMatrix4(h, s),
                    o.normal.toArray(u, p),
                    u[p + 3] = o.constant
            }
            l.value = u,
            l.needsUpdate = !0
        }
        return t.numPlanes = a,
        t.numIntersection = 0,
        u
    }
    this.uniform = l,
    this.numPlanes = 0,
    this.numIntersection = 0,
    this.init = function(e, t, a) {
        var o = 0 !== e.length || t || 0 !== i || n;
        return n = t,
        r = c(e, a, 0),
        i = e.length,
        o
    }
    ,
    this.beginShadows = function() {
        a = !0,
        c(null)
    }
    ,
    this.endShadows = function() {
        a = !1,
        u()
    }
    ,
    this.setState = function(t, o, s) {
        var h = t.clippingPlanes
          , d = t.clipIntersection
          , p = t.clipShadows
          , f = e.get(t);
        if (!n || null === h || 0 === h.length || a && !p)
            a ? c(null) : u();
        else {
            var m = a ? 0 : i
              , v = 4 * m
              , g = f.clippingState || null;
            l.value = g,
            g = c(h, o, v, s);
            for (var _ = 0; _ !== v; ++_)
                g[_] = r[_];
            f.clippingState = g,
            this.numIntersection = d ? this.numPlanes : 0,
            this.numPlanes += m
        }
    }
}
function WebGLCubeMaps(e) {
    var t = new WeakMap;
    function r(e, t) {
        return t === EquirectangularReflectionMapping ? e.mapping = CubeReflectionMapping : t === EquirectangularRefractionMapping && (e.mapping = CubeRefractionMapping),
        e
    }
    function i(e) {
        var r = e.target;
        r.removeEventListener("dispose", i);
        var n = t.get(r);
        void 0 !== n && (t.delete(r),
        n.dispose())
    }
    return {
        get: function(n) {
            if (n && n.isTexture && !1 === n.isRenderTargetTexture) {
                var a = n.mapping;
                if (a === EquirectangularReflectionMapping || a === EquirectangularRefractionMapping) {
                    if (t.has(n))
                        return r(t.get(n).texture, n.mapping);
                    var o = n.image;
                    if (o && o.height > 0) {
                        var s = new WebGLCubeRenderTarget(o.height / 2);
                        return s.fromEquirectangularTexture(e, n),
                        t.set(n, s),
                        n.addEventListener("dispose", i),
                        r(s.texture, n.mapping)
                    }
                    return null
                }
            }
            return n
        },
        dispose: function() {
            t = new WeakMap
        }
    }
}
ShaderLib.physical = {
    uniforms: mergeUniforms([ShaderLib.standard.uniforms, {
        clearcoat: {
            value: 0
        },
        clearcoatMap: {
            value: null
        },
        clearcoatRoughness: {
            value: 0
        },
        clearcoatRoughnessMap: {
            value: null
        },
        clearcoatNormalScale: {
            value: new Vector2(1,1)
        },
        clearcoatNormalMap: {
            value: null
        },
        sheen: {
            value: 0
        },
        sheenColor: {
            value: new Color(0)
        },
        sheenColorMap: {
            value: null
        },
        sheenRoughness: {
            value: 1
        },
        sheenRoughnessMap: {
            value: null
        },
        transmission: {
            value: 0
        },
        transmissionMap: {
            value: null
        },
        transmissionSamplerSize: {
            value: new Vector2
        },
        transmissionSamplerMap: {
            value: null
        },
        thickness: {
            value: 0
        },
        thicknessMap: {
            value: null
        },
        attenuationDistance: {
            value: 0
        },
        attenuationColor: {
            value: new Color(0)
        },
        specularIntensity: {
            value: 1
        },
        specularIntensityMap: {
            value: null
        },
        specularColor: {
            value: new Color(1,1,1)
        },
        specularColorMap: {
            value: null
        }
    }]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
};
var OrthographicCamera = function(e) {
    _inherits(r, Camera);
    var t = _createSuper(r);
    function r() {
        var e, i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : -1, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : -1, s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : .1, l = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 2e3;
        return _classCallCheck(this, r),
        (e = t.call(this)).type = "OrthographicCamera",
        e.zoom = 1,
        e.view = null,
        e.left = i,
        e.right = n,
        e.top = a,
        e.bottom = o,
        e.near = s,
        e.far = l,
        e.updateProjectionMatrix(),
        e
    }
    return _createClass(r, [{
        key: "copy",
        value: function(e, t) {
            return _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e, t),
            this.left = e.left,
            this.right = e.right,
            this.top = e.top,
            this.bottom = e.bottom,
            this.near = e.near,
            this.far = e.far,
            this.zoom = e.zoom,
            this.view = null === e.view ? null : Object.assign({}, e.view),
            this
        }
    }, {
        key: "setViewOffset",
        value: function(e, t, r, i, n, a) {
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }),
            this.view.enabled = !0,
            this.view.fullWidth = e,
            this.view.fullHeight = t,
            this.view.offsetX = r,
            this.view.offsetY = i,
            this.view.width = n,
            this.view.height = a,
            this.updateProjectionMatrix()
        }
    }, {
        key: "clearViewOffset",
        value: function() {
            null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix()
        }
    }, {
        key: "updateProjectionMatrix",
        value: function() {
            var e = (this.right - this.left) / (2 * this.zoom)
              , t = (this.top - this.bottom) / (2 * this.zoom)
              , r = (this.right + this.left) / 2
              , i = (this.top + this.bottom) / 2
              , n = r - e
              , a = r + e
              , o = i + t
              , s = i - t;
            if (null !== this.view && this.view.enabled) {
                var l = (this.right - this.left) / this.view.fullWidth / this.zoom
                  , u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                a = (n += l * this.view.offsetX) + l * this.view.width,
                s = (o -= u * this.view.offsetY) - u * this.view.height
            }
            this.projectionMatrix.makeOrthographic(n, a, o, s, this.near, this.far),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
        }
    }, {
        key: "toJSON",
        value: function(e) {
            var t = _get(_getPrototypeOf(r.prototype), "toJSON", this).call(this, e);
            return t.object.zoom = this.zoom,
            t.object.left = this.left,
            t.object.right = this.right,
            t.object.top = this.top,
            t.object.bottom = this.bottom,
            t.object.near = this.near,
            t.object.far = this.far,
            null !== this.view && (t.object.view = Object.assign({}, this.view)),
            t
        }
    }]),
    r
}();
OrthographicCamera.prototype.isOrthographicCamera = !0;
var LOD_MIN = 4
  , EXTRA_LOD_SIGMA = [.125, .215, .35, .446, .526, .582]
  , MAX_SAMPLES = 20
  , _flatCamera = new OrthographicCamera
  , _clearColor = new Color
  , _oldTarget = null
  , PHI = (1 + Math.sqrt(5)) / 2
  , INV_PHI = 1 / PHI
  , _axisDirections = [new Vector3(1,1,1), new Vector3(-1,1,1), new Vector3(1,1,-1), new Vector3(-1,1,-1), new Vector3(0,PHI,INV_PHI), new Vector3(0,PHI,-INV_PHI), new Vector3(INV_PHI,0,PHI), new Vector3(-INV_PHI,0,PHI), new Vector3(PHI,INV_PHI,0), new Vector3(-PHI,INV_PHI,0)]
  , PMREMGenerator = function() {
    function e(t) {
        _classCallCheck(this, e),
        this._renderer = t,
        this._pingPongRenderTarget = null,
        this._lodMax = 0,
        this._cubeSize = 0,
        this._lodPlanes = [],
        this._sizeLods = [],
        this._sigmas = [],
        this._blurMaterial = null,
        this._cubemapMaterial = null,
        this._equirectMaterial = null,
        this._compileMaterial(this._blurMaterial)
    }
    return _createClass(e, [{
        key: "fromScene",
        value: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
              , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : .1
              , i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 100;
            _oldTarget = this._renderer.getRenderTarget(),
            this._setSize(256);
            var n = this._allocateTargets();
            return n.depthBuffer = !0,
            this._sceneToCubeUV(e, r, i, n),
            t > 0 && this._blur(n, 0, 0, t),
            this._applyPMREM(n),
            this._cleanup(n),
            n
        }
    }, {
        key: "fromEquirectangular",
        value: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
            return this._fromTexture(e, t)
        }
    }, {
        key: "fromCubemap",
        value: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
            return this._fromTexture(e, t)
        }
    }, {
        key: "compileCubemapShader",
        value: function() {
            null === this._cubemapMaterial && (this._cubemapMaterial = _getCubemapMaterial(),
            this._compileMaterial(this._cubemapMaterial))
        }
    }, {
        key: "compileEquirectangularShader",
        value: function() {
            null === this._equirectMaterial && (this._equirectMaterial = _getEquirectMaterial(),
            this._compileMaterial(this._equirectMaterial))
        }
    }, {
        key: "dispose",
        value: function() {
            this._dispose(),
            null !== this._cubemapMaterial && this._cubemapMaterial.dispose(),
            null !== this._equirectMaterial && this._equirectMaterial.dispose()
        }
    }, {
        key: "_setSize",
        value: function(e) {
            this._lodMax = Math.floor(Math.log2(e)),
            this._cubeSize = Math.pow(2, this._lodMax)
        }
    }, {
        key: "_dispose",
        value: function() {
            null !== this._blurMaterial && this._blurMaterial.dispose(),
            null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
            for (var e = 0; e < this._lodPlanes.length; e++)
                this._lodPlanes[e].dispose()
        }
    }, {
        key: "_cleanup",
        value: function(e) {
            this._renderer.setRenderTarget(_oldTarget),
            e.scissorTest = !1,
            _setViewport(e, 0, 0, e.width, e.height)
        }
    }, {
        key: "_fromTexture",
        value: function(e, t) {
            e.mapping === CubeReflectionMapping || e.mapping === CubeRefractionMapping ? this._setSize(0 === e.image.length ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4),
            _oldTarget = this._renderer.getRenderTarget();
            var r = t || this._allocateTargets();
            return this._textureToCubeUV(e, r),
            this._applyPMREM(r),
            this._cleanup(r),
            r
        }
    }, {
        key: "_allocateTargets",
        value: function() {
            var e = 3 * Math.max(this._cubeSize, 112)
              , t = 4 * this._cubeSize - 32
              , r = {
                magFilter: LinearFilter,
                minFilter: LinearFilter,
                generateMipmaps: !1,
                type: HalfFloatType,
                format: RGBAFormat,
                encoding: LinearEncoding,
                depthBuffer: !1
            }
              , i = _createRenderTarget(e, t, r);
            if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== e) {
                null !== this._pingPongRenderTarget && this._dispose(),
                this._pingPongRenderTarget = _createRenderTarget(e, t, r);
                var n = this._lodMax
                  , a = _createPlanes(n);
                this._sizeLods = a.sizeLods,
                this._lodPlanes = a.lodPlanes,
                this._sigmas = a.sigmas,
                this._blurMaterial = _getBlurShader(n, e, t)
            }
            return i
        }
    }, {
        key: "_compileMaterial",
        value: function(e) {
            var t = new Mesh(this._lodPlanes[0],e);
            this._renderer.compile(t, _flatCamera)
        }
    }, {
        key: "_sceneToCubeUV",
        value: function(e, t, r, i) {
            var n = new PerspectiveCamera(90,1,t,r)
              , a = [1, -1, 1, 1, 1, 1]
              , o = [1, 1, 1, -1, -1, -1]
              , s = this._renderer
              , l = s.autoClear
              , u = s.toneMapping;
            s.getClearColor(_clearColor),
            s.toneMapping = NoToneMapping,
            s.autoClear = !1;
            var c = new MeshBasicMaterial({
                name: "PMREM.Background",
                side: BackSide,
                depthWrite: !1,
                depthTest: !1
            })
              , h = new Mesh(new BoxGeometry,c)
              , d = !1
              , p = e.background;
            p ? p.isColor && (c.color.copy(p),
            e.background = null,
            d = !0) : (c.color.copy(_clearColor),
            d = !0);
            for (var f = 0; f < 6; f++) {
                var m = f % 3;
                0 === m ? (n.up.set(0, a[f], 0),
                n.lookAt(o[f], 0, 0)) : 1 === m ? (n.up.set(0, 0, a[f]),
                n.lookAt(0, o[f], 0)) : (n.up.set(0, a[f], 0),
                n.lookAt(0, 0, o[f]));
                var v = this._cubeSize;
                _setViewport(i, m * v, f > 2 ? v : 0, v, v),
                s.setRenderTarget(i),
                d && s.render(h, n),
                s.render(e, n)
            }
            h.geometry.dispose(),
            h.material.dispose(),
            s.toneMapping = u,
            s.autoClear = l,
            e.background = p
        }
    }, {
        key: "_textureToCubeUV",
        value: function(e, t) {
            var r = this._renderer
              , i = e.mapping === CubeReflectionMapping || e.mapping === CubeRefractionMapping;
            i ? (null === this._cubemapMaterial && (this._cubemapMaterial = _getCubemapMaterial()),
            this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === e.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = _getEquirectMaterial());
            var n = i ? this._cubemapMaterial : this._equirectMaterial
              , a = new Mesh(this._lodPlanes[0],n);
            n.uniforms.envMap.value = e;
            var o = this._cubeSize;
            _setViewport(t, 0, 0, 3 * o, 2 * o),
            r.setRenderTarget(t),
            r.render(a, _flatCamera)
        }
    }, {
        key: "_applyPMREM",
        value: function(e) {
            var t = this._renderer
              , r = t.autoClear;
            t.autoClear = !1;
            for (var i = 1; i < this._lodPlanes.length; i++) {
                var n = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1])
                  , a = _axisDirections[(i - 1) % _axisDirections.length];
                this._blur(e, i - 1, i, n, a)
            }
            t.autoClear = r
        }
    }, {
        key: "_blur",
        value: function(e, t, r, i, n) {
            var a = this._pingPongRenderTarget;
            this._halfBlur(e, a, t, r, i, "latitudinal", n),
            this._halfBlur(a, e, r, r, i, "longitudinal", n)
        }
    }, {
        key: "_halfBlur",
        value: function(e, t, r, i, n, a, o) {
            var s = this._renderer
              , l = this._blurMaterial;
            "latitudinal" !== a && "longitudinal" !== a && console.error("blur direction must be either latitudinal or longitudinal!");
            var u = new Mesh(this._lodPlanes[i],l)
              , c = l.uniforms
              , h = this._sizeLods[r] - 1
              , d = isFinite(n) ? Math.PI / (2 * h) : 2 * Math.PI / (2 * MAX_SAMPLES - 1)
              , p = n / d
              , f = isFinite(n) ? 1 + Math.floor(3 * p) : MAX_SAMPLES;
            f > MAX_SAMPLES && console.warn("sigmaRadians, ".concat(n, ", is too large and will clip, as it requested ").concat(f, " samples when the maximum is set to ").concat(MAX_SAMPLES));
            for (var m = [], v = 0, g = 0; g < MAX_SAMPLES; ++g) {
                var _ = g / p
                  , y = Math.exp(-_ * _ / 2);
                m.push(y),
                0 === g ? v += y : g < f && (v += 2 * y)
            }
            for (var x = 0; x < m.length; x++)
                m[x] = m[x] / v;
            c.envMap.value = e.texture,
            c.samples.value = f,
            c.weights.value = m,
            c.latitudinal.value = "latitudinal" === a,
            o && (c.poleAxis.value = o);
            var b = this._lodMax;
            c.dTheta.value = d,
            c.mipInt.value = b - r;
            var S = this._sizeLods[i];
            _setViewport(t, 3 * S * (i > b - LOD_MIN ? i - b + LOD_MIN : 0), 4 * (this._cubeSize - S), 3 * S, 2 * S),
            s.setRenderTarget(t),
            s.render(u, _flatCamera)
        }
    }]),
    e
}();
function _createPlanes(e) {
    for (var t = [], r = [], i = [], n = e, a = e - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length, o = 0; o < a; o++) {
        var s = Math.pow(2, n);
        r.push(s);
        var l = 1 / s;
        o > e - LOD_MIN ? l = EXTRA_LOD_SIGMA[o - e + LOD_MIN - 1] : 0 === o && (l = 0),
        i.push(l);
        for (var u = 1 / (s - 1), c = -u / 2, h = 1 + u / 2, d = [c, c, h, c, h, h, c, c, h, h, c, h], p = new Float32Array(108), f = new Float32Array(72), m = new Float32Array(36), v = 0; v < 6; v++) {
            var g = v % 3 * 2 / 3 - 1
              , _ = v > 2 ? 0 : -1
              , y = [g, _, 0, g + 2 / 3, _, 0, g + 2 / 3, _ + 1, 0, g, _, 0, g + 2 / 3, _ + 1, 0, g, _ + 1, 0];
            p.set(y, 18 * v),
            f.set(d, 12 * v);
            var x = [v, v, v, v, v, v];
            m.set(x, 6 * v)
        }
        var b = new BufferGeometry;
        b.setAttribute("position", new BufferAttribute(p,3)),
        b.setAttribute("uv", new BufferAttribute(f,2)),
        b.setAttribute("faceIndex", new BufferAttribute(m,1)),
        t.push(b),
        n > LOD_MIN && n--
    }
    return {
        lodPlanes: t,
        sizeLods: r,
        sigmas: i
    }
}
function _createRenderTarget(e, t, r) {
    var i = new WebGLRenderTarget(e,t,r);
    return i.texture.mapping = CubeUVReflectionMapping,
    i.texture.name = "PMREM.cubeUv",
    i.scissorTest = !0,
    i
}
function _setViewport(e, t, r, i, n) {
    e.viewport.set(t, r, i, n),
    e.scissor.set(t, r, i, n)
}
function _getBlurShader(e, t, r) {
    var i = new Float32Array(MAX_SAMPLES)
      , n = new Vector3(0,1,0);
    return new ShaderMaterial({
        name: "SphericalGaussianBlur",
        defines: {
            n: MAX_SAMPLES,
            CUBEUV_TEXEL_WIDTH: 1 / t,
            CUBEUV_TEXEL_HEIGHT: 1 / r,
            CUBEUV_MAX_MIP: "".concat(e, ".0")
        },
        uniforms: {
            envMap: {
                value: null
            },
            samples: {
                value: 1
            },
            weights: {
                value: i
            },
            latitudinal: {
                value: !1
            },
            dTheta: {
                value: 0
            },
            mipInt: {
                value: 0
            },
            poleAxis: {
                value: n
            }
        },
        vertexShader: _getCommonVertexShader(),
        fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
        blending: NoBlending,
        depthTest: !1,
        depthWrite: !1
    })
}
function _getEquirectMaterial() {
    return new ShaderMaterial({
        name: "EquirectangularToCubeUV",
        uniforms: {
            envMap: {
                value: null
            }
        },
        vertexShader: _getCommonVertexShader(),
        fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
        blending: NoBlending,
        depthTest: !1,
        depthWrite: !1
    })
}
function _getCubemapMaterial() {
    return new ShaderMaterial({
        name: "CubemapToCubeUV",
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            }
        },
        vertexShader: _getCommonVertexShader(),
        fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
        blending: NoBlending,
        depthTest: !1,
        depthWrite: !1
    })
}
function _getCommonVertexShader() {
    return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"
}
function WebGLCubeUVMaps(e) {
    var t = new WeakMap
      , r = null;
    function i(e) {
        var r = e.target;
        r.removeEventListener("dispose", i);
        var n = t.get(r);
        void 0 !== n && (t.delete(r),
        n.dispose())
    }
    return {
        get: function(n) {
            if (n && n.isTexture) {
                var a = n.mapping
                  , o = a === EquirectangularReflectionMapping || a === EquirectangularRefractionMapping
                  , s = a === CubeReflectionMapping || a === CubeRefractionMapping;
                if (o || s) {
                    if (n.isRenderTargetTexture && !0 === n.needsPMREMUpdate) {
                        n.needsPMREMUpdate = !1;
                        var l = t.get(n);
                        return null === r && (r = new PMREMGenerator(e)),
                        l = o ? r.fromEquirectangular(n, l) : r.fromCubemap(n, l),
                        t.set(n, l),
                        l.texture
                    }
                    if (t.has(n))
                        return t.get(n).texture;
                    var u = n.image;
                    if (o && u && u.height > 0 || s && u && function(e) {
                        for (var t = 0, r = 0; r < 6; r++)
                            void 0 !== e[r] && t++;
                        return 6 === t
                    }(u)) {
                        null === r && (r = new PMREMGenerator(e));
                        var c = o ? r.fromEquirectangular(n) : r.fromCubemap(n);
                        return t.set(n, c),
                        n.addEventListener("dispose", i),
                        c.texture
                    }
                    return null
                }
            }
            return n
        },
        dispose: function() {
            t = new WeakMap,
            null !== r && (r.dispose(),
            r = null)
        }
    }
}
function WebGLExtensions(e) {
    var t = {};
    function r(r) {
        if (void 0 !== t[r])
            return t[r];
        var i;
        switch (r) {
        case "WEBGL_depth_texture":
            i = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
        case "EXT_texture_filter_anisotropic":
            i = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
        case "WEBGL_compressed_texture_s3tc":
            i = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
        case "WEBGL_compressed_texture_pvrtc":
            i = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
        default:
            i = e.getExtension(r)
        }
        return t[r] = i,
        i
    }
    return {
        has: function(e) {
            return null !== r(e)
        },
        init: function(e) {
            e.isWebGL2 ? r("EXT_color_buffer_float") : (r("WEBGL_depth_texture"),
            r("OES_texture_float"),
            r("OES_texture_half_float"),
            r("OES_texture_half_float_linear"),
            r("OES_standard_derivatives"),
            r("OES_element_index_uint"),
            r("OES_vertex_array_object"),
            r("ANGLE_instanced_arrays")),
            r("OES_texture_float_linear"),
            r("EXT_color_buffer_half_float"),
            r("WEBGL_multisampled_render_to_texture")
        },
        get: function(e) {
            var t = r(e);
            return null === t && console.warn("THREE.WebGLRenderer: " + e + " extension not supported."),
            t
        }
    }
}
function WebGLGeometries(e, t, r, i) {
    var n = {}
      , a = new WeakMap;
    function o(e) {
        var s = e.target;
        for (var l in null !== s.index && t.remove(s.index),
        s.attributes)
            t.remove(s.attributes[l]);
        s.removeEventListener("dispose", o),
        delete n[s.id];
        var u = a.get(s);
        u && (t.remove(u),
        a.delete(s)),
        i.releaseStatesOfGeometry(s),
        !0 === s.isInstancedBufferGeometry && delete s._maxInstanceCount,
        r.memory.geometries--
    }
    function s(e) {
        var r = []
          , i = e.index
          , n = e.attributes.position
          , o = 0;
        if (null !== i) {
            var s = i.array;
            o = i.version;
            for (var l = 0, u = s.length; l < u; l += 3) {
                var c = s[l + 0]
                  , h = s[l + 1]
                  , d = s[l + 2];
                r.push(c, h, h, d, d, c)
            }
        } else {
            var p = n.array;
            o = n.version;
            for (var f = 0, m = p.length / 3 - 1; f < m; f += 3) {
                var v = f + 0
                  , g = f + 1
                  , _ = f + 2;
                r.push(v, g, g, _, _, v)
            }
        }
        var y = new (arrayNeedsUint32(r) ? Uint32BufferAttribute : Uint16BufferAttribute)(r,1);
        y.version = o;
        var x = a.get(e);
        x && t.remove(x),
        a.set(e, y)
    }
    return {
        get: function(e, t) {
            return !0 === n[t.id] || (t.addEventListener("dispose", o),
            n[t.id] = !0,
            r.memory.geometries++),
            t
        },
        update: function(e) {
            var r = e.attributes;
            for (var i in r)
                t.update(r[i], 34962);
            var n = e.morphAttributes;
            for (var a in n)
                for (var o = n[a], s = 0, l = o.length; s < l; s++)
                    t.update(o[s], 34962)
        },
        getWireframeAttribute: function(e) {
            var t = a.get(e);
            if (t) {
                var r = e.index;
                null !== r && t.version < r.version && s(e)
            } else
                s(e);
            return a.get(e)
        }
    }
}
function WebGLIndexedBufferRenderer(e, t, r, i) {
    var n, a, o, s = i.isWebGL2;
    this.setMode = function(e) {
        n = e
    }
    ,
    this.setIndex = function(e) {
        a = e.type,
        o = e.bytesPerElement
    }
    ,
    this.render = function(t, i) {
        e.drawElements(n, i, a, t * o),
        r.update(i, n, 1)
    }
    ,
    this.renderInstances = function(i, l, u) {
        if (0 !== u) {
            var c, h;
            if (s)
                c = e,
                h = "drawElementsInstanced";
            else if (h = "drawElementsInstancedANGLE",
            null === (c = t.get("ANGLE_instanced_arrays")))
                return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            c[h](n, l, a, i * o, u),
            r.update(l, n, u)
        }
    }
}
function WebGLInfo(e) {
    var t = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
    };
    return {
        memory: {
            geometries: 0,
            textures: 0
        },
        render: t,
        programs: null,
        autoReset: !0,
        reset: function() {
            t.frame++,
            t.calls = 0,
            t.triangles = 0,
            t.points = 0,
            t.lines = 0
        },
        update: function(e, r, i) {
            switch (t.calls++,
            r) {
            case 4:
                t.triangles += i * (e / 3);
                break;
            case 1:
                t.lines += i * (e / 2);
                break;
            case 3:
                t.lines += i * (e - 1);
                break;
            case 2:
                t.lines += i * e;
                break;
            case 0:
                t.points += i * e;
                break;
            default:
                console.error("THREE.WebGLInfo: Unknown draw mode:", r)
            }
        }
    }
}
function numericalSort(e, t) {
    return e[0] - t[0]
}
function absNumericalSort(e, t) {
    return Math.abs(t[1]) - Math.abs(e[1])
}
function denormalize(e, t) {
    var r = 1
      , i = t.isInterleavedBufferAttribute ? t.data.array : t.array;
    i instanceof Int8Array ? r = 127 : i instanceof Int16Array ? r = 32767 : i instanceof Int32Array ? r = 2147483647 : console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", i),
    e.divideScalar(r)
}
function WebGLMorphtargets(e, t, r) {
    for (var i = {}, n = new Float32Array(8), a = new WeakMap, o = new Vector4, s = [], l = 0; l < 8; l++)
        s[l] = [l, 0];
    return {
        update: function(l, u, c, h) {
            var d = l.morphTargetInfluences;
            if (!0 === t.isWebGL2) {
                var p = u.morphAttributes.position || u.morphAttributes.normal || u.morphAttributes.color
                  , f = void 0 !== p ? p.length : 0
                  , m = a.get(u);
                if (void 0 === m || m.count !== f) {
                    void 0 !== m && m.texture.dispose();
                    var v = void 0 !== u.morphAttributes.position
                      , g = void 0 !== u.morphAttributes.normal
                      , _ = void 0 !== u.morphAttributes.color
                      , y = u.morphAttributes.position || []
                      , x = u.morphAttributes.normal || []
                      , b = u.morphAttributes.color || []
                      , S = 0;
                    !0 === v && (S = 1),
                    !0 === g && (S = 2),
                    !0 === _ && (S = 3);
                    var w = u.attributes.position.count * S
                      , M = 1;
                    w > t.maxTextureSize && (M = Math.ceil(w / t.maxTextureSize),
                    w = t.maxTextureSize);
                    var T = new Float32Array(w * M * 4 * f)
                      , C = new DataArrayTexture(T,w,M,f);
                    C.type = FloatType,
                    C.needsUpdate = !0;
                    for (var E = 4 * S, P = 0; P < f; P++)
                        for (var A = y[P], k = x[P], L = b[P], R = w * M * 4 * P, D = 0; D < A.count; D++) {
                            var I = D * E;
                            !0 === v && (o.fromBufferAttribute(A, D),
                            !0 === A.normalized && denormalize(o, A),
                            T[R + I + 0] = o.x,
                            T[R + I + 1] = o.y,
                            T[R + I + 2] = o.z,
                            T[R + I + 3] = 0),
                            !0 === g && (o.fromBufferAttribute(k, D),
                            !0 === k.normalized && denormalize(o, k),
                            T[R + I + 4] = o.x,
                            T[R + I + 5] = o.y,
                            T[R + I + 6] = o.z,
                            T[R + I + 7] = 0),
                            !0 === _ && (o.fromBufferAttribute(L, D),
                            !0 === L.normalized && denormalize(o, L),
                            T[R + I + 8] = o.x,
                            T[R + I + 9] = o.y,
                            T[R + I + 10] = o.z,
                            T[R + I + 11] = 4 === L.itemSize ? o.w : 1)
                        }
                    m = {
                        count: f,
                        texture: C,
                        size: new Vector2(w,M)
                    },
                    a.set(u, m),
                    u.addEventListener("dispose", (function e() {
                        C.dispose(),
                        a.delete(u),
                        u.removeEventListener("dispose", e)
                    }
                    ))
                }
                for (var O = 0, N = 0; N < d.length; N++)
                    O += d[N];
                var F = u.morphTargetsRelative ? 1 : 1 - O;
                h.getUniforms().setValue(e, "morphTargetBaseInfluence", F),
                h.getUniforms().setValue(e, "morphTargetInfluences", d),
                h.getUniforms().setValue(e, "morphTargetsTexture", m.texture, r),
                h.getUniforms().setValue(e, "morphTargetsTextureSize", m.size)
            } else {
                var B = void 0 === d ? 0 : d.length
                  , z = i[u.id];
                if (void 0 === z || z.length !== B) {
                    z = [];
                    for (var U = 0; U < B; U++)
                        z[U] = [U, 0];
                    i[u.id] = z
                }
                for (var V = 0; V < B; V++) {
                    var G = z[V];
                    G[0] = V,
                    G[1] = d[V]
                }
                z.sort(absNumericalSort);
                for (var H = 0; H < 8; H++)
                    H < B && z[H][1] ? (s[H][0] = z[H][0],
                    s[H][1] = z[H][1]) : (s[H][0] = Number.MAX_SAFE_INTEGER,
                    s[H][1] = 0);
                s.sort(numericalSort);
                for (var W = u.morphAttributes.position, $ = u.morphAttributes.normal, j = 0, q = 0; q < 8; q++) {
                    var X = s[q]
                      , Y = X[0]
                      , K = X[1];
                    Y !== Number.MAX_SAFE_INTEGER && K ? (W && u.getAttribute("morphTarget" + q) !== W[Y] && u.setAttribute("morphTarget" + q, W[Y]),
                    $ && u.getAttribute("morphNormal" + q) !== $[Y] && u.setAttribute("morphNormal" + q, $[Y]),
                    n[q] = K,
                    j += K) : (W && !0 === u.hasAttribute("morphTarget" + q) && u.deleteAttribute("morphTarget" + q),
                    $ && !0 === u.hasAttribute("morphNormal" + q) && u.deleteAttribute("morphNormal" + q),
                    n[q] = 0)
                }
                var Z = u.morphTargetsRelative ? 1 : 1 - j;
                h.getUniforms().setValue(e, "morphTargetBaseInfluence", Z),
                h.getUniforms().setValue(e, "morphTargetInfluences", n)
            }
        }
    }
}
function WebGLObjects(e, t, r, i) {
    var n = new WeakMap;
    function a(e) {
        var t = e.target;
        t.removeEventListener("dispose", a),
        r.remove(t.instanceMatrix),
        null !== t.instanceColor && r.remove(t.instanceColor)
    }
    return {
        update: function(e) {
            var o = i.render.frame
              , s = e.geometry
              , l = t.get(e, s);
            return n.get(l) !== o && (t.update(l),
            n.set(l, o)),
            e.isInstancedMesh && (!1 === e.hasEventListener("dispose", a) && e.addEventListener("dispose", a),
            r.update(e.instanceMatrix, 34962),
            null !== e.instanceColor && r.update(e.instanceColor, 34962)),
            l
        },
        dispose: function() {
            n = new WeakMap
        }
    }
}
var emptyTexture = new Texture
  , emptyArrayTexture = new DataArrayTexture
  , empty3dTexture = new Data3DTexture
  , emptyCubeTexture = new CubeTexture
  , arrayCacheF32 = []
  , arrayCacheI32 = []
  , mat4array = new Float32Array(16)
  , mat3array = new Float32Array(9)
  , mat2array = new Float32Array(4);
function flatten(e, t, r) {
    var i = e[0];
    if (i <= 0 || i > 0)
        return e;
    var n = t * r
      , a = arrayCacheF32[n];
    if (void 0 === a && (a = new Float32Array(n),
    arrayCacheF32[n] = a),
    0 !== t) {
        i.toArray(a, 0);
        for (var o = 1, s = 0; o !== t; ++o)
            s += r,
            e[o].toArray(a, s)
    }
    return a
}
function arraysEqual(e, t) {
    if (e.length !== t.length)
        return !1;
    for (var r = 0, i = e.length; r < i; r++)
        if (e[r] !== t[r])
            return !1;
    return !0
}
function copyArray(e, t) {
    for (var r = 0, i = t.length; r < i; r++)
        e[r] = t[r]
}
function allocTexUnits(e, t) {
    var r = arrayCacheI32[t];
    void 0 === r && (r = new Int32Array(t),
    arrayCacheI32[t] = r);
    for (var i = 0; i !== t; ++i)
        r[i] = e.allocateTextureUnit();
    return r
}
function setValueV1f(e, t) {
    var r = this.cache;
    r[0] !== t && (e.uniform1f(this.addr, t),
    r[0] = t)
}
function setValueV2f(e, t) {
    var r = this.cache;
    if (void 0 !== t.x)
        r[0] === t.x && r[1] === t.y || (e.uniform2f(this.addr, t.x, t.y),
        r[0] = t.x,
        r[1] = t.y);
    else {
        if (arraysEqual(r, t))
            return;
        e.uniform2fv(this.addr, t),
        copyArray(r, t)
    }
}
function setValueV3f(e, t) {
    var r = this.cache;
    if (void 0 !== t.x)
        r[0] === t.x && r[1] === t.y && r[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z),
        r[0] = t.x,
        r[1] = t.y,
        r[2] = t.z);
    else if (void 0 !== t.r)
        r[0] === t.r && r[1] === t.g && r[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b),
        r[0] = t.r,
        r[1] = t.g,
        r[2] = t.b);
    else {
        if (arraysEqual(r, t))
            return;
        e.uniform3fv(this.addr, t),
        copyArray(r, t)
    }
}
function setValueV4f(e, t) {
    var r = this.cache;
    if (void 0 !== t.x)
        r[0] === t.x && r[1] === t.y && r[2] === t.z && r[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w),
        r[0] = t.x,
        r[1] = t.y,
        r[2] = t.z,
        r[3] = t.w);
    else {
        if (arraysEqual(r, t))
            return;
        e.uniform4fv(this.addr, t),
        copyArray(r, t)
    }
}
function setValueM2(e, t) {
    var r = this.cache
      , i = t.elements;
    if (void 0 === i) {
        if (arraysEqual(r, t))
            return;
        e.uniformMatrix2fv(this.addr, !1, t),
        copyArray(r, t)
    } else {
        if (arraysEqual(r, i))
            return;
        mat2array.set(i),
        e.uniformMatrix2fv(this.addr, !1, mat2array),
        copyArray(r, i)
    }
}
function setValueM3(e, t) {
    var r = this.cache
      , i = t.elements;
    if (void 0 === i) {
        if (arraysEqual(r, t))
            return;
        e.uniformMatrix3fv(this.addr, !1, t),
        copyArray(r, t)
    } else {
        if (arraysEqual(r, i))
            return;
        mat3array.set(i),
        e.uniformMatrix3fv(this.addr, !1, mat3array),
        copyArray(r, i)
    }
}
function setValueM4(e, t) {
    var r = this.cache
      , i = t.elements;
    if (void 0 === i) {
        if (arraysEqual(r, t))
            return;
        e.uniformMatrix4fv(this.addr, !1, t),
        copyArray(r, t)
    } else {
        if (arraysEqual(r, i))
            return;
        mat4array.set(i),
        e.uniformMatrix4fv(this.addr, !1, mat4array),
        copyArray(r, i)
    }
}
function setValueV1i(e, t) {
    var r = this.cache;
    r[0] !== t && (e.uniform1i(this.addr, t),
    r[0] = t)
}
function setValueV2i(e, t) {
    var r = this.cache;
    arraysEqual(r, t) || (e.uniform2iv(this.addr, t),
    copyArray(r, t))
}
function setValueV3i(e, t) {
    var r = this.cache;
    arraysEqual(r, t) || (e.uniform3iv(this.addr, t),
    copyArray(r, t))
}
function setValueV4i(e, t) {
    var r = this.cache;
    arraysEqual(r, t) || (e.uniform4iv(this.addr, t),
    copyArray(r, t))
}
function setValueV1ui(e, t) {
    var r = this.cache;
    r[0] !== t && (e.uniform1ui(this.addr, t),
    r[0] = t)
}
function setValueV2ui(e, t) {
    var r = this.cache;
    arraysEqual(r, t) || (e.uniform2uiv(this.addr, t),
    copyArray(r, t))
}
function setValueV3ui(e, t) {
    var r = this.cache;
    arraysEqual(r, t) || (e.uniform3uiv(this.addr, t),
    copyArray(r, t))
}
function setValueV4ui(e, t) {
    var r = this.cache;
    arraysEqual(r, t) || (e.uniform4uiv(this.addr, t),
    copyArray(r, t))
}
function setValueT1(e, t, r) {
    var i = this.cache
      , n = r.allocateTextureUnit();
    i[0] !== n && (e.uniform1i(this.addr, n),
    i[0] = n),
    r.setTexture2D(t || emptyTexture, n)
}
function setValueT3D1(e, t, r) {
    var i = this.cache
      , n = r.allocateTextureUnit();
    i[0] !== n && (e.uniform1i(this.addr, n),
    i[0] = n),
    r.setTexture3D(t || empty3dTexture, n)
}
function setValueT6(e, t, r) {
    var i = this.cache
      , n = r.allocateTextureUnit();
    i[0] !== n && (e.uniform1i(this.addr, n),
    i[0] = n),
    r.setTextureCube(t || emptyCubeTexture, n)
}
function setValueT2DArray1(e, t, r) {
    var i = this.cache
      , n = r.allocateTextureUnit();
    i[0] !== n && (e.uniform1i(this.addr, n),
    i[0] = n),
    r.setTexture2DArray(t || emptyArrayTexture, n)
}
function getSingularSetter(e) {
    switch (e) {
    case 5126:
        return setValueV1f;
    case 35664:
        return setValueV2f;
    case 35665:
        return setValueV3f;
    case 35666:
        return setValueV4f;
    case 35674:
        return setValueM2;
    case 35675:
        return setValueM3;
    case 35676:
        return setValueM4;
    case 5124:
    case 35670:
        return setValueV1i;
    case 35667:
    case 35671:
        return setValueV2i;
    case 35668:
    case 35672:
        return setValueV3i;
    case 35669:
    case 35673:
        return setValueV4i;
    case 5125:
        return setValueV1ui;
    case 36294:
        return setValueV2ui;
    case 36295:
        return setValueV3ui;
    case 36296:
        return setValueV4ui;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return setValueT1;
    case 35679:
    case 36299:
    case 36307:
        return setValueT3D1;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return setValueT6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return setValueT2DArray1
    }
}
function setValueV1fArray(e, t) {
    e.uniform1fv(this.addr, t)
}
function setValueV2fArray(e, t) {
    var r = flatten(t, this.size, 2);
    e.uniform2fv(this.addr, r)
}
function setValueV3fArray(e, t) {
    var r = flatten(t, this.size, 3);
    e.uniform3fv(this.addr, r)
}
function setValueV4fArray(e, t) {
    var r = flatten(t, this.size, 4);
    e.uniform4fv(this.addr, r)
}
function setValueM2Array(e, t) {
    var r = flatten(t, this.size, 4);
    e.uniformMatrix2fv(this.addr, !1, r)
}
function setValueM3Array(e, t) {
    var r = flatten(t, this.size, 9);
    e.uniformMatrix3fv(this.addr, !1, r)
}
function setValueM4Array(e, t) {
    var r = flatten(t, this.size, 16);
    e.uniformMatrix4fv(this.addr, !1, r)
}
function setValueV1iArray(e, t) {
    e.uniform1iv(this.addr, t)
}
function setValueV2iArray(e, t) {
    e.uniform2iv(this.addr, t)
}
function setValueV3iArray(e, t) {
    e.uniform3iv(this.addr, t)
}
function setValueV4iArray(e, t) {
    e.uniform4iv(this.addr, t)
}
function setValueV1uiArray(e, t) {
    e.uniform1uiv(this.addr, t)
}
function setValueV2uiArray(e, t) {
    e.uniform2uiv(this.addr, t)
}
function setValueV3uiArray(e, t) {
    e.uniform3uiv(this.addr, t)
}
function setValueV4uiArray(e, t) {
    e.uniform4uiv(this.addr, t)
}
function setValueT1Array(e, t, r) {
    var i = t.length
      , n = allocTexUnits(r, i);
    e.uniform1iv(this.addr, n);
    for (var a = 0; a !== i; ++a)
        r.setTexture2D(t[a] || emptyTexture, n[a])
}
function setValueT3DArray(e, t, r) {
    var i = t.length
      , n = allocTexUnits(r, i);
    e.uniform1iv(this.addr, n);
    for (var a = 0; a !== i; ++a)
        r.setTexture3D(t[a] || empty3dTexture, n[a])
}
function setValueT6Array(e, t, r) {
    var i = t.length
      , n = allocTexUnits(r, i);
    e.uniform1iv(this.addr, n);
    for (var a = 0; a !== i; ++a)
        r.setTextureCube(t[a] || emptyCubeTexture, n[a])
}
function setValueT2DArrayArray(e, t, r) {
    var i = t.length
      , n = allocTexUnits(r, i);
    e.uniform1iv(this.addr, n);
    for (var a = 0; a !== i; ++a)
        r.setTexture2DArray(t[a] || emptyArrayTexture, n[a])
}
function getPureArraySetter(e) {
    switch (e) {
    case 5126:
        return setValueV1fArray;
    case 35664:
        return setValueV2fArray;
    case 35665:
        return setValueV3fArray;
    case 35666:
        return setValueV4fArray;
    case 35674:
        return setValueM2Array;
    case 35675:
        return setValueM3Array;
    case 35676:
        return setValueM4Array;
    case 5124:
    case 35670:
        return setValueV1iArray;
    case 35667:
    case 35671:
        return setValueV2iArray;
    case 35668:
    case 35672:
        return setValueV3iArray;
    case 35669:
    case 35673:
        return setValueV4iArray;
    case 5125:
        return setValueV1uiArray;
    case 36294:
        return setValueV2uiArray;
    case 36295:
        return setValueV3uiArray;
    case 36296:
        return setValueV4uiArray;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return setValueT1Array;
    case 35679:
    case 36299:
    case 36307:
        return setValueT3DArray;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return setValueT6Array;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return setValueT2DArrayArray
    }
}
function SingleUniform(e, t, r) {
    this.id = e,
    this.addr = r,
    this.cache = [],
    this.setValue = getSingularSetter(t.type)
}
function PureArrayUniform(e, t, r) {
    this.id = e,
    this.addr = r,
    this.cache = [],
    this.size = t.size,
    this.setValue = getPureArraySetter(t.type)
}
function StructuredUniform(e) {
    this.id = e,
    this.seq = [],
    this.map = {}
}
PureArrayUniform.prototype.updateCache = function(e) {
    var t = this.cache;
    e instanceof Float32Array && t.length !== e.length && (this.cache = new Float32Array(e.length)),
    copyArray(t, e)
}
,
StructuredUniform.prototype.setValue = function(e, t, r) {
    for (var i = this.seq, n = 0, a = i.length; n !== a; ++n) {
        var o = i[n];
        o.setValue(e, t[o.id], r)
    }
}
;
var RePathPart = /(\w+)(\])?(\[|\.)?/g;
function addUniform(e, t) {
    e.seq.push(t),
    e.map[t.id] = t
}
function parseUniform(e, t, r) {
    var i = e.name
      , n = i.length;
    for (RePathPart.lastIndex = 0; ; ) {
        var a = RePathPart.exec(i)
          , o = RePathPart.lastIndex
          , s = a[1]
          , l = "]" === a[2]
          , u = a[3];
        if (l && (s |= 0),
        void 0 === u || "[" === u && o + 2 === n) {
            addUniform(r, void 0 === u ? new SingleUniform(s,e,t) : new PureArrayUniform(s,e,t));
            break
        }
        var c = r.map[s];
        void 0 === c && addUniform(r, c = new StructuredUniform(s)),
        r = c
    }
}
function WebGLUniforms(e, t) {
    this.seq = [],
    this.map = {};
    for (var r = e.getProgramParameter(t, 35718), i = 0; i < r; ++i) {
        var n = e.getActiveUniform(t, i);
        parseUniform(n, e.getUniformLocation(t, n.name), this)
    }
}
function WebGLShader(e, t, r) {
    var i = e.createShader(t);
    return e.shaderSource(i, r),
    e.compileShader(i),
    i
}
WebGLUniforms.prototype.setValue = function(e, t, r, i) {
    var n = this.map[t];
    void 0 !== n && n.setValue(e, r, i)
}
,
WebGLUniforms.prototype.setOptional = function(e, t, r) {
    var i = t[r];
    void 0 !== i && this.setValue(e, r, i)
}
,
WebGLUniforms.upload = function(e, t, r, i) {
    for (var n = 0, a = t.length; n !== a; ++n) {
        var o = t[n]
          , s = r[o.id];
        !1 !== s.needsUpdate && o.setValue(e, s.value, i)
    }
}
,
WebGLUniforms.seqWithValue = function(e, t) {
    for (var r = [], i = 0, n = e.length; i !== n; ++i) {
        var a = e[i];
        a.id in t && r.push(a)
    }
    return r
}
;
var programIdCount = 0;
function handleSource(e, t) {
    for (var r = e.split("\n"), i = [], n = Math.max(t - 6, 0), a = Math.min(t + 6, r.length), o = n; o < a; o++)
        i.push(o + 1 + ": " + r[o]);
    return i.join("\n")
}
function getEncodingComponents(e) {
    switch (e) {
    case LinearEncoding:
        return ["Linear", "( value )"];
    case sRGBEncoding:
        return ["sRGB", "( value )"];
    default:
        return console.warn("THREE.WebGLProgram: Unsupported encoding:", e),
        ["Linear", "( value )"]
    }
}
function getShaderErrors(e, t, r) {
    var i = e.getShaderParameter(t, 35713)
      , n = e.getShaderInfoLog(t).trim();
    if (i && "" === n)
        return "";
    var a = parseInt(/ERROR: 0:(\d+)/.exec(n)[1]);
    return r.toUpperCase() + "\n\n" + n + "\n\n" + handleSource(e.getShaderSource(t), a)
}
function getTexelEncodingFunction(e, t) {
    var r = getEncodingComponents(t);
    return "vec4 " + e + "( vec4 value ) { return LinearTo" + r[0] + r[1] + "; }"
}
function getToneMappingFunction(e, t) {
    var r;
    switch (t) {
    case LinearToneMapping:
        r = "Linear";
        break;
    case ReinhardToneMapping:
        r = "Reinhard";
        break;
    case CineonToneMapping:
        r = "OptimizedCineon";
        break;
    case ACESFilmicToneMapping:
        r = "ACESFilmic";
        break;
    case CustomToneMapping:
        r = "Custom";
        break;
    default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t),
        r = "Linear"
    }
    return "vec3 " + e + "( vec3 color ) { return " + r + "ToneMapping( color ); }"
}
function generateExtensions(e) {
    return [e.extensionDerivatives || e.envMapCubeUVHeight || e.bumpMap || e.tangentSpaceNormalMap || e.clearcoatNormalMap || e.flatShading || "physical" === e.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (e.extensionFragDepth || e.logarithmicDepthBuffer) && e.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", e.extensionDrawBuffers && e.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (e.extensionShaderTextureLOD || e.envMap || e.transmission) && e.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(filterEmptyLine).join("\n")
}
function generateDefines(e) {
    var t = [];
    for (var r in e) {
        var i = e[r];
        !1 !== i && t.push("#define " + r + " " + i)
    }
    return t.join("\n")
}
function fetchAttributeLocations(e, t) {
    for (var r = {}, i = e.getProgramParameter(t, 35721), n = 0; n < i; n++) {
        var a = e.getActiveAttrib(t, n)
          , o = a.name
          , s = 1;
        35674 === a.type && (s = 2),
        35675 === a.type && (s = 3),
        35676 === a.type && (s = 4),
        r[o] = {
            type: a.type,
            location: e.getAttribLocation(t, o),
            locationSize: s
        }
    }
    return r
}
function filterEmptyLine(e) {
    return "" !== e
}
function replaceLightNums(e, t) {
    return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
}
function replaceClippingPlaneNums(e, t) {
    return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
}
var includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(e) {
    return e.replace(includePattern, includeReplacer)
}
function includeReplacer(e, t) {
    var r = ShaderChunk[t];
    if (void 0 === r)
        throw new Error("Can not resolve #include <" + t + ">");
    return resolveIncludes(r)
}
var deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g
  , unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function unrollLoops(e) {
    return e.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer)
}
function deprecatedLoopReplacer(e, t, r, i) {
    return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),
    loopReplacer(e, t, r, i)
}
function loopReplacer(e, t, r, i) {
    for (var n = "", a = parseInt(t); a < parseInt(r); a++)
        n += i.replace(/\[\s*i\s*\]/g, "[ " + a + " ]").replace(/UNROLLED_LOOP_INDEX/g, a);
    return n
}
function generatePrecision(e) {
    var t = "precision " + e.precision + " float;\nprecision " + e.precision + " int;";
    return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"),
    t
}
function generateShadowMapTypeDefine(e) {
    var t = "SHADOWMAP_TYPE_BASIC";
    return e.shadowMapType === PCFShadowMap ? t = "SHADOWMAP_TYPE_PCF" : e.shadowMapType === PCFSoftShadowMap ? t = "SHADOWMAP_TYPE_PCF_SOFT" : e.shadowMapType === VSMShadowMap && (t = "SHADOWMAP_TYPE_VSM"),
    t
}
function generateEnvMapTypeDefine(e) {
    var t = "ENVMAP_TYPE_CUBE";
    if (e.envMap)
        switch (e.envMapMode) {
        case CubeReflectionMapping:
        case CubeRefractionMapping:
            t = "ENVMAP_TYPE_CUBE";
            break;
        case CubeUVReflectionMapping:
            t = "ENVMAP_TYPE_CUBE_UV"
        }
    return t
}
function generateEnvMapModeDefine(e) {
    var t = "ENVMAP_MODE_REFLECTION";
    return e.envMap && e.envMapMode === CubeRefractionMapping && (t = "ENVMAP_MODE_REFRACTION"),
    t
}
function generateEnvMapBlendingDefine(e) {
    var t = "ENVMAP_BLENDING_NONE";
    if (e.envMap)
        switch (e.combine) {
        case MultiplyOperation:
            t = "ENVMAP_BLENDING_MULTIPLY";
            break;
        case MixOperation:
            t = "ENVMAP_BLENDING_MIX";
            break;
        case AddOperation:
            t = "ENVMAP_BLENDING_ADD"
        }
    return t
}
function generateCubeUVSize(e) {
    var t = e.envMapCubeUVHeight;
    if (null === t)
        return null;
    var r = Math.log2(t / 32 + 1) + 3
      , i = 1 / t;
    return {
        texelWidth: 1 / (3 * Math.max(Math.pow(2, r), 112)),
        texelHeight: i,
        maxMip: r
    }
}
function WebGLProgram(e, t, r, i) {
    var n, a, o = e.getContext(), s = r.defines, l = r.vertexShader, u = r.fragmentShader, c = generateShadowMapTypeDefine(r), h = generateEnvMapTypeDefine(r), d = generateEnvMapModeDefine(r), p = generateEnvMapBlendingDefine(r), f = generateCubeUVSize(r), m = r.isWebGL2 ? "" : generateExtensions(r), v = generateDefines(s), g = o.createProgram(), _ = r.glslVersion ? "#version " + r.glslVersion + "\n" : "";
    r.isRawShaderMaterial ? ((n = [v].filter(filterEmptyLine).join("\n")).length > 0 && (n += "\n"),
    (a = [m, v].filter(filterEmptyLine).join("\n")).length > 0 && (a += "\n")) : (n = [generatePrecision(r), "#define SHADER_NAME " + r.shaderName, v, r.instancing ? "#define USE_INSTANCING" : "", r.instancingColor ? "#define USE_INSTANCING_COLOR" : "", r.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define MAX_BONES " + r.maxBones, r.useFog && r.fog ? "#define USE_FOG" : "", r.useFog && r.fogExp2 ? "#define FOG_EXP2" : "", r.map ? "#define USE_MAP" : "", r.envMap ? "#define USE_ENVMAP" : "", r.envMap ? "#define " + d : "", r.lightMap ? "#define USE_LIGHTMAP" : "", r.aoMap ? "#define USE_AOMAP" : "", r.emissiveMap ? "#define USE_EMISSIVEMAP" : "", r.bumpMap ? "#define USE_BUMPMAP" : "", r.normalMap ? "#define USE_NORMALMAP" : "", r.normalMap && r.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", r.normalMap && r.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", r.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", r.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", r.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", r.displacementMap && r.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", r.specularMap ? "#define USE_SPECULARMAP" : "", r.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", r.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", r.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", r.metalnessMap ? "#define USE_METALNESSMAP" : "", r.alphaMap ? "#define USE_ALPHAMAP" : "", r.transmission ? "#define USE_TRANSMISSION" : "", r.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", r.thicknessMap ? "#define USE_THICKNESSMAP" : "", r.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", r.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", r.vertexTangents ? "#define USE_TANGENT" : "", r.vertexColors ? "#define USE_COLOR" : "", r.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", r.vertexUvs ? "#define USE_UV" : "", r.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", r.flatShading ? "#define FLAT_SHADED" : "", r.skinning ? "#define USE_SKINNING" : "", r.useVertexTexture ? "#define BONE_TEXTURE" : "", r.morphTargets ? "#define USE_MORPHTARGETS" : "", r.morphNormals && !1 === r.flatShading ? "#define USE_MORPHNORMALS" : "", r.morphColors && r.isWebGL2 ? "#define USE_MORPHCOLORS" : "", r.morphTargetsCount > 0 && r.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", r.morphTargetsCount > 0 && r.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + r.morphTextureStride : "", r.morphTargetsCount > 0 && r.isWebGL2 ? "#define MORPHTARGETS_COUNT " + r.morphTargetsCount : "", r.doubleSided ? "#define DOUBLE_SIDED" : "", r.flipSided ? "#define FLIP_SIDED" : "", r.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", r.shadowMapEnabled ? "#define " + c : "", r.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", r.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", r.logarithmicDepthBuffer && r.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(filterEmptyLine).join("\n"),
    a = [m, generatePrecision(r), "#define SHADER_NAME " + r.shaderName, v, r.useFog && r.fog ? "#define USE_FOG" : "", r.useFog && r.fogExp2 ? "#define FOG_EXP2" : "", r.map ? "#define USE_MAP" : "", r.matcap ? "#define USE_MATCAP" : "", r.envMap ? "#define USE_ENVMAP" : "", r.envMap ? "#define " + h : "", r.envMap ? "#define " + d : "", r.envMap ? "#define " + p : "", f ? "#define CUBEUV_TEXEL_WIDTH " + f.texelWidth : "", f ? "#define CUBEUV_TEXEL_HEIGHT " + f.texelHeight : "", f ? "#define CUBEUV_MAX_MIP " + f.maxMip + ".0" : "", r.lightMap ? "#define USE_LIGHTMAP" : "", r.aoMap ? "#define USE_AOMAP" : "", r.emissiveMap ? "#define USE_EMISSIVEMAP" : "", r.bumpMap ? "#define USE_BUMPMAP" : "", r.normalMap ? "#define USE_NORMALMAP" : "", r.normalMap && r.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", r.normalMap && r.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", r.clearcoat ? "#define USE_CLEARCOAT" : "", r.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", r.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", r.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", r.specularMap ? "#define USE_SPECULARMAP" : "", r.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", r.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", r.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", r.metalnessMap ? "#define USE_METALNESSMAP" : "", r.alphaMap ? "#define USE_ALPHAMAP" : "", r.alphaTest ? "#define USE_ALPHATEST" : "", r.sheen ? "#define USE_SHEEN" : "", r.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", r.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", r.transmission ? "#define USE_TRANSMISSION" : "", r.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", r.thicknessMap ? "#define USE_THICKNESSMAP" : "", r.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", r.vertexTangents ? "#define USE_TANGENT" : "", r.vertexColors || r.instancingColor ? "#define USE_COLOR" : "", r.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", r.vertexUvs ? "#define USE_UV" : "", r.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", r.gradientMap ? "#define USE_GRADIENTMAP" : "", r.flatShading ? "#define FLAT_SHADED" : "", r.doubleSided ? "#define DOUBLE_SIDED" : "", r.flipSided ? "#define FLIP_SIDED" : "", r.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", r.shadowMapEnabled ? "#define " + c : "", r.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", r.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", r.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", r.logarithmicDepthBuffer && r.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", r.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "", r.toneMapping !== NoToneMapping ? ShaderChunk.tonemapping_pars_fragment : "", r.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", r.toneMapping) : "", r.dithering ? "#define DITHERING" : "", r.opaque ? "#define OPAQUE" : "", ShaderChunk.encodings_pars_fragment, getTexelEncodingFunction("linearToOutputTexel", r.outputEncoding), r.depthPacking ? "#define DEPTH_PACKING " + r.depthPacking : "", "\n"].filter(filterEmptyLine).join("\n")),
    l = replaceClippingPlaneNums(l = replaceLightNums(l = resolveIncludes(l), r), r),
    u = replaceClippingPlaneNums(u = replaceLightNums(u = resolveIncludes(u), r), r),
    l = unrollLoops(l),
    u = unrollLoops(u),
    r.isWebGL2 && !0 !== r.isRawShaderMaterial && (_ = "#version 300 es\n",
    n = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + n,
    a = ["#define varying in", r.glslVersion === GLSL3 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", r.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + a);
    var y, x, b = _ + a + u, S = WebGLShader(o, 35633, _ + n + l), w = WebGLShader(o, 35632, b);
    if (o.attachShader(g, S),
    o.attachShader(g, w),
    void 0 !== r.index0AttributeName ? o.bindAttribLocation(g, 0, r.index0AttributeName) : !0 === r.morphTargets && o.bindAttribLocation(g, 0, "position"),
    o.linkProgram(g),
    e.debug.checkShaderErrors) {
        var M = o.getProgramInfoLog(g).trim()
          , T = o.getShaderInfoLog(S).trim()
          , C = o.getShaderInfoLog(w).trim()
          , E = !0
          , P = !0;
        if (!1 === o.getProgramParameter(g, 35714)) {
            E = !1;
            var A = getShaderErrors(o, S, "vertex")
              , k = getShaderErrors(o, w, "fragment");
            console.error("THREE.WebGLProgram: Shader Error " + o.getError() + " - VALIDATE_STATUS " + o.getProgramParameter(g, 35715) + "\n\nProgram Info Log: " + M + "\n" + A + "\n" + k)
        } else
            "" !== M ? console.warn("THREE.WebGLProgram: Program Info Log:", M) : "" !== T && "" !== C || (P = !1);
        P && (this.diagnostics = {
            runnable: E,
            programLog: M,
            vertexShader: {
                log: T,
                prefix: n
            },
            fragmentShader: {
                log: C,
                prefix: a
            }
        })
    }
    return o.deleteShader(S),
    o.deleteShader(w),
    this.getUniforms = function() {
        return void 0 === y && (y = new WebGLUniforms(o,g)),
        y
    }
    ,
    this.getAttributes = function() {
        return void 0 === x && (x = fetchAttributeLocations(o, g)),
        x
    }
    ,
    this.destroy = function() {
        i.releaseStatesOfProgram(this),
        o.deleteProgram(g),
        this.program = void 0
    }
    ,
    this.name = r.shaderName,
    this.id = programIdCount++,
    this.cacheKey = t,
    this.usedTimes = 1,
    this.program = g,
    this.vertexShader = S,
    this.fragmentShader = w,
    this
}
var _id = 0
  , WebGLShaderCache = function() {
    function e() {
        _classCallCheck(this, e),
        this.shaderCache = new Map,
        this.materialCache = new Map
    }
    return _createClass(e, [{
        key: "update",
        value: function(e) {
            var t = e.vertexShader
              , r = e.fragmentShader
              , i = this._getShaderStage(t)
              , n = this._getShaderStage(r)
              , a = this._getShaderCacheForMaterial(e);
            return !1 === a.has(i) && (a.add(i),
            i.usedTimes++),
            !1 === a.has(n) && (a.add(n),
            n.usedTimes++),
            this
        }
    }, {
        key: "remove",
        value: function(e) {
            var t, r = _createForOfIteratorHelper(this.materialCache.get(e));
            try {
                for (r.s(); !(t = r.n()).done; ) {
                    var i = t.value;
                    i.usedTimes--,
                    0 === i.usedTimes && this.shaderCache.delete(i.code)
                }
            } catch (n) {
                r.e(n)
            } finally {
                r.f()
            }
            return this.materialCache.delete(e),
            this
        }
    }, {
        key: "getVertexShaderID",
        value: function(e) {
            return this._getShaderStage(e.vertexShader).id
        }
    }, {
        key: "getFragmentShaderID",
        value: function(e) {
            return this._getShaderStage(e.fragmentShader).id
        }
    }, {
        key: "dispose",
        value: function() {
            this.shaderCache.clear(),
            this.materialCache.clear()
        }
    }, {
        key: "_getShaderCacheForMaterial",
        value: function(e) {
            var t = this.materialCache;
            return !1 === t.has(e) && t.set(e, new Set),
            t.get(e)
        }
    }, {
        key: "_getShaderStage",
        value: function(e) {
            var t = this.shaderCache;
            if (!1 === t.has(e)) {
                var r = new WebGLShaderStage(e);
                t.set(e, r)
            }
            return t.get(e)
        }
    }]),
    e
}()
  , WebGLShaderStage = _createClass((function e(t) {
    _classCallCheck(this, e),
    this.id = _id++,
    this.code = t,
    this.usedTimes = 0
}
));
function WebGLPrograms(e, t, r, i, n, a, o) {
    var s = new Layers
      , l = new WebGLShaderCache
      , u = []
      , c = n.isWebGL2
      , h = n.logarithmicDepthBuffer
      , d = n.floatVertexTextures
      , p = n.maxVertexUniforms
      , f = n.vertexTextures
      , m = n.precision
      , v = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
    };
    return {
        getParameters: function(a, s, u, g, _) {
            var y = g.fog
              , x = _.geometry
              , b = a.isMeshStandardMaterial ? g.environment : null
              , S = (a.isMeshStandardMaterial ? r : t).get(a.envMap || b)
              , w = S && S.mapping === CubeUVReflectionMapping ? S.image.height : null
              , M = v[a.type]
              , T = _.isSkinnedMesh ? function(e) {
                var t = e.skeleton.bones;
                if (d)
                    return 1024;
                var r = p
                  , i = Math.floor((r - 20) / 4)
                  , n = Math.min(i, t.length);
                return n < t.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + t.length + " bones. This GPU supports " + n + "."),
                0) : n
            }(_) : 0;
            null !== a.precision && (m = n.getMaxPrecision(a.precision)) !== a.precision && console.warn("THREE.WebGLProgram.getParameters:", a.precision, "not supported, using", m, "instead.");
            var C, E, P, A, k = x.morphAttributes.position || x.morphAttributes.normal || x.morphAttributes.color, L = void 0 !== k ? k.length : 0, R = 0;
            if (void 0 !== x.morphAttributes.position && (R = 1),
            void 0 !== x.morphAttributes.normal && (R = 2),
            void 0 !== x.morphAttributes.color && (R = 3),
            M) {
                var D = ShaderLib[M];
                C = D.vertexShader,
                E = D.fragmentShader
            } else
                C = a.vertexShader,
                E = a.fragmentShader,
                l.update(a),
                P = l.getVertexShaderID(a),
                A = l.getFragmentShaderID(a);
            var I = e.getRenderTarget()
              , O = a.alphaTest > 0
              , N = a.clearcoat > 0;
            return {
                isWebGL2: c,
                shaderID: M,
                shaderName: a.type,
                vertexShader: C,
                fragmentShader: E,
                defines: a.defines,
                customVertexShaderID: P,
                customFragmentShaderID: A,
                isRawShaderMaterial: !0 === a.isRawShaderMaterial,
                glslVersion: a.glslVersion,
                precision: m,
                instancing: !0 === _.isInstancedMesh,
                instancingColor: !0 === _.isInstancedMesh && null !== _.instanceColor,
                supportsVertexTextures: f,
                outputEncoding: null === I ? e.outputEncoding : !0 === I.isXRRenderTarget ? I.texture.encoding : LinearEncoding,
                map: !!a.map,
                matcap: !!a.matcap,
                envMap: !!S,
                envMapMode: S && S.mapping,
                envMapCubeUVHeight: w,
                lightMap: !!a.lightMap,
                aoMap: !!a.aoMap,
                emissiveMap: !!a.emissiveMap,
                bumpMap: !!a.bumpMap,
                normalMap: !!a.normalMap,
                objectSpaceNormalMap: a.normalMapType === ObjectSpaceNormalMap,
                tangentSpaceNormalMap: a.normalMapType === TangentSpaceNormalMap,
                decodeVideoTexture: !!a.map && !0 === a.map.isVideoTexture && a.map.encoding === sRGBEncoding,
                clearcoat: N,
                clearcoatMap: N && !!a.clearcoatMap,
                clearcoatRoughnessMap: N && !!a.clearcoatRoughnessMap,
                clearcoatNormalMap: N && !!a.clearcoatNormalMap,
                displacementMap: !!a.displacementMap,
                roughnessMap: !!a.roughnessMap,
                metalnessMap: !!a.metalnessMap,
                specularMap: !!a.specularMap,
                specularIntensityMap: !!a.specularIntensityMap,
                specularColorMap: !!a.specularColorMap,
                opaque: !1 === a.transparent && a.blending === NormalBlending,
                alphaMap: !!a.alphaMap,
                alphaTest: O,
                gradientMap: !!a.gradientMap,
                sheen: a.sheen > 0,
                sheenColorMap: !!a.sheenColorMap,
                sheenRoughnessMap: !!a.sheenRoughnessMap,
                transmission: a.transmission > 0,
                transmissionMap: !!a.transmissionMap,
                thicknessMap: !!a.thicknessMap,
                combine: a.combine,
                vertexTangents: !!a.normalMap && !!x.attributes.tangent,
                vertexColors: a.vertexColors,
                vertexAlphas: !0 === a.vertexColors && !!x.attributes.color && 4 === x.attributes.color.itemSize,
                vertexUvs: !!(a.map || a.bumpMap || a.normalMap || a.specularMap || a.alphaMap || a.emissiveMap || a.roughnessMap || a.metalnessMap || a.clearcoatMap || a.clearcoatRoughnessMap || a.clearcoatNormalMap || a.displacementMap || a.transmissionMap || a.thicknessMap || a.specularIntensityMap || a.specularColorMap || a.sheenColorMap || a.sheenRoughnessMap),
                uvsVertexOnly: !(a.map || a.bumpMap || a.normalMap || a.specularMap || a.alphaMap || a.emissiveMap || a.roughnessMap || a.metalnessMap || a.clearcoatNormalMap || a.transmission > 0 || a.transmissionMap || a.thicknessMap || a.specularIntensityMap || a.specularColorMap || a.sheen > 0 || a.sheenColorMap || a.sheenRoughnessMap || !a.displacementMap),
                fog: !!y,
                useFog: a.fog,
                fogExp2: y && y.isFogExp2,
                flatShading: !!a.flatShading,
                sizeAttenuation: a.sizeAttenuation,
                logarithmicDepthBuffer: h,
                skinning: !0 === _.isSkinnedMesh && T > 0,
                maxBones: T,
                useVertexTexture: d,
                morphTargets: void 0 !== x.morphAttributes.position,
                morphNormals: void 0 !== x.morphAttributes.normal,
                morphColors: void 0 !== x.morphAttributes.color,
                morphTargetsCount: L,
                morphTextureStride: R,
                numDirLights: s.directional.length,
                numPointLights: s.point.length,
                numSpotLights: s.spot.length,
                numRectAreaLights: s.rectArea.length,
                numHemiLights: s.hemi.length,
                numDirLightShadows: s.directionalShadowMap.length,
                numPointLightShadows: s.pointShadowMap.length,
                numSpotLightShadows: s.spotShadowMap.length,
                numClippingPlanes: o.numPlanes,
                numClipIntersection: o.numIntersection,
                dithering: a.dithering,
                shadowMapEnabled: e.shadowMap.enabled && u.length > 0,
                shadowMapType: e.shadowMap.type,
                toneMapping: a.toneMapped ? e.toneMapping : NoToneMapping,
                physicallyCorrectLights: e.physicallyCorrectLights,
                premultipliedAlpha: a.premultipliedAlpha,
                doubleSided: a.side === DoubleSide,
                flipSided: a.side === BackSide,
                depthPacking: void 0 !== a.depthPacking && a.depthPacking,
                index0AttributeName: a.index0AttributeName,
                extensionDerivatives: a.extensions && a.extensions.derivatives,
                extensionFragDepth: a.extensions && a.extensions.fragDepth,
                extensionDrawBuffers: a.extensions && a.extensions.drawBuffers,
                extensionShaderTextureLOD: a.extensions && a.extensions.shaderTextureLOD,
                rendererExtensionFragDepth: c || i.has("EXT_frag_depth"),
                rendererExtensionDrawBuffers: c || i.has("WEBGL_draw_buffers"),
                rendererExtensionShaderTextureLod: c || i.has("EXT_shader_texture_lod"),
                customProgramCacheKey: a.customProgramCacheKey()
            }
        },
        getProgramCacheKey: function(t) {
            var r = [];
            if (t.shaderID ? r.push(t.shaderID) : (r.push(t.customVertexShaderID),
            r.push(t.customFragmentShaderID)),
            void 0 !== t.defines)
                for (var i in t.defines)
                    r.push(i),
                    r.push(t.defines[i]);
            return !1 === t.isRawShaderMaterial && (function(e, t) {
                e.push(t.precision),
                e.push(t.outputEncoding),
                e.push(t.envMapMode),
                e.push(t.envMapCubeUVHeight),
                e.push(t.combine),
                e.push(t.vertexUvs),
                e.push(t.fogExp2),
                e.push(t.sizeAttenuation),
                e.push(t.maxBones),
                e.push(t.morphTargetsCount),
                e.push(t.morphAttributeCount),
                e.push(t.numDirLights),
                e.push(t.numPointLights),
                e.push(t.numSpotLights),
                e.push(t.numHemiLights),
                e.push(t.numRectAreaLights),
                e.push(t.numDirLightShadows),
                e.push(t.numPointLightShadows),
                e.push(t.numSpotLightShadows),
                e.push(t.shadowMapType),
                e.push(t.toneMapping),
                e.push(t.numClippingPlanes),
                e.push(t.numClipIntersection)
            }(r, t),
            function(e, t) {
                s.disableAll(),
                t.isWebGL2 && s.enable(0),
                t.supportsVertexTextures && s.enable(1),
                t.instancing && s.enable(2),
                t.instancingColor && s.enable(3),
                t.map && s.enable(4),
                t.matcap && s.enable(5),
                t.envMap && s.enable(6),
                t.lightMap && s.enable(7),
                t.aoMap && s.enable(8),
                t.emissiveMap && s.enable(9),
                t.bumpMap && s.enable(10),
                t.normalMap && s.enable(11),
                t.objectSpaceNormalMap && s.enable(12),
                t.tangentSpaceNormalMap && s.enable(13),
                t.clearcoat && s.enable(14),
                t.clearcoatMap && s.enable(15),
                t.clearcoatRoughnessMap && s.enable(16),
                t.clearcoatNormalMap && s.enable(17),
                t.displacementMap && s.enable(18),
                t.specularMap && s.enable(19),
                t.roughnessMap && s.enable(20),
                t.metalnessMap && s.enable(21),
                t.gradientMap && s.enable(22),
                t.alphaMap && s.enable(23),
                t.alphaTest && s.enable(24),
                t.vertexColors && s.enable(25),
                t.vertexAlphas && s.enable(26),
                t.vertexUvs && s.enable(27),
                t.vertexTangents && s.enable(28),
                t.uvsVertexOnly && s.enable(29),
                t.fog && s.enable(30),
                e.push(s.mask),
                s.disableAll(),
                t.useFog && s.enable(0),
                t.flatShading && s.enable(1),
                t.logarithmicDepthBuffer && s.enable(2),
                t.skinning && s.enable(3),
                t.useVertexTexture && s.enable(4),
                t.morphTargets && s.enable(5),
                t.morphNormals && s.enable(6),
                t.morphColors && s.enable(7),
                t.premultipliedAlpha && s.enable(8),
                t.shadowMapEnabled && s.enable(9),
                t.physicallyCorrectLights && s.enable(10),
                t.doubleSided && s.enable(11),
                t.flipSided && s.enable(12),
                t.depthPacking && s.enable(13),
                t.dithering && s.enable(14),
                t.specularIntensityMap && s.enable(15),
                t.specularColorMap && s.enable(16),
                t.transmission && s.enable(17),
                t.transmissionMap && s.enable(18),
                t.thicknessMap && s.enable(19),
                t.sheen && s.enable(20),
                t.sheenColorMap && s.enable(21),
                t.sheenRoughnessMap && s.enable(22),
                t.decodeVideoTexture && s.enable(23),
                t.opaque && s.enable(24),
                e.push(s.mask)
            }(r, t),
            r.push(e.outputEncoding)),
            r.push(t.customProgramCacheKey),
            r.join()
        },
        getUniforms: function(e) {
            var t, r = v[e.type];
            if (r) {
                var i = ShaderLib[r];
                t = UniformsUtils.clone(i.uniforms)
            } else
                t = e.uniforms;
            return t
        },
        acquireProgram: function(t, r) {
            for (var i, n = 0, o = u.length; n < o; n++) {
                var s = u[n];
                if (s.cacheKey === r) {
                    ++(i = s).usedTimes;
                    break
                }
            }
            return void 0 === i && (i = new WebGLProgram(e,r,t,a),
            u.push(i)),
            i
        },
        releaseProgram: function(e) {
            if (0 == --e.usedTimes) {
                var t = u.indexOf(e);
                u[t] = u[u.length - 1],
                u.pop(),
                e.destroy()
            }
        },
        releaseShaderCache: function(e) {
            l.remove(e)
        },
        programs: u,
        dispose: function() {
            l.dispose()
        }
    }
}
function WebGLProperties() {
    var e = new WeakMap;
    return {
        get: function(t) {
            var r = e.get(t);
            return void 0 === r && (r = {},
            e.set(t, r)),
            r
        },
        remove: function(t) {
            e.delete(t)
        },
        update: function(t, r, i) {
            e.get(t)[r] = i
        },
        dispose: function() {
            e = new WeakMap
        }
    }
}
function painterSortStable(e, t) {
    return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
}
function reversePainterSortStable(e, t) {
    return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
}
function WebGLRenderList() {
    var e = []
      , t = 0
      , r = []
      , i = []
      , n = [];
    function a(r, i, n, a, o, s) {
        var l = e[t];
        return void 0 === l ? (l = {
            id: r.id,
            object: r,
            geometry: i,
            material: n,
            groupOrder: a,
            renderOrder: r.renderOrder,
            z: o,
            group: s
        },
        e[t] = l) : (l.id = r.id,
        l.object = r,
        l.geometry = i,
        l.material = n,
        l.groupOrder = a,
        l.renderOrder = r.renderOrder,
        l.z = o,
        l.group = s),
        t++,
        l
    }
    return {
        opaque: r,
        transmissive: i,
        transparent: n,
        init: function() {
            t = 0,
            r.length = 0,
            i.length = 0,
            n.length = 0
        },
        push: function(e, t, o, s, l, u) {
            var c = a(e, t, o, s, l, u);
            o.transmission > 0 ? i.push(c) : !0 === o.transparent ? n.push(c) : r.push(c)
        },
        unshift: function(e, t, o, s, l, u) {
            var c = a(e, t, o, s, l, u);
            o.transmission > 0 ? i.unshift(c) : !0 === o.transparent ? n.unshift(c) : r.unshift(c)
        },
        finish: function() {
            for (var r = t, i = e.length; r < i; r++) {
                var n = e[r];
                if (null === n.id)
                    break;
                n.id = null,
                n.object = null,
                n.geometry = null,
                n.material = null,
                n.group = null
            }
        },
        sort: function(e, t) {
            r.length > 1 && r.sort(e || painterSortStable),
            i.length > 1 && i.sort(t || reversePainterSortStable),
            n.length > 1 && n.sort(t || reversePainterSortStable)
        }
    }
}
function WebGLRenderLists() {
    var e = new WeakMap;
    return {
        get: function(t, r) {
            var i;
            return !1 === e.has(t) ? (i = new WebGLRenderList,
            e.set(t, [i])) : r >= e.get(t).length ? (i = new WebGLRenderList,
            e.get(t).push(i)) : i = e.get(t)[r],
            i
        },
        dispose: function() {
            e = new WeakMap
        }
    }
}
function UniformsCache() {
    var e = {};
    return {
        get: function(t) {
            if (void 0 !== e[t.id])
                return e[t.id];
            var r;
            switch (t.type) {
            case "DirectionalLight":
                r = {
                    direction: new Vector3,
                    color: new Color
                };
                break;
            case "SpotLight":
                r = {
                    position: new Vector3,
                    direction: new Vector3,
                    color: new Color,
                    distance: 0,
                    coneCos: 0,
                    penumbraCos: 0,
                    decay: 0
                };
                break;
            case "PointLight":
                r = {
                    position: new Vector3,
                    color: new Color,
                    distance: 0,
                    decay: 0
                };
                break;
            case "HemisphereLight":
                r = {
                    direction: new Vector3,
                    skyColor: new Color,
                    groundColor: new Color
                };
                break;
            case "RectAreaLight":
                r = {
                    color: new Color,
                    position: new Vector3,
                    halfWidth: new Vector3,
                    halfHeight: new Vector3
                }
            }
            return e[t.id] = r,
            r
        }
    }
}
function ShadowUniformsCache() {
    var e = {};
    return {
        get: function(t) {
            if (void 0 !== e[t.id])
                return e[t.id];
            var r;
            switch (t.type) {
            case "DirectionalLight":
            case "SpotLight":
                r = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new Vector2
                };
                break;
            case "PointLight":
                r = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new Vector2,
                    shadowCameraNear: 1,
                    shadowCameraFar: 1e3
                }
            }
            return e[t.id] = r,
            r
        }
    }
}
var nextVersion = 0;
function shadowCastingLightsFirst(e, t) {
    return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0)
}
function WebGLLights(e, t) {
    for (var r = new UniformsCache, i = ShadowUniformsCache(), n = {
        version: 0,
        hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1
        },
        ambient: [0, 0, 0],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotShadow: [],
        spotShadowMap: [],
        spotShadowMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: []
    }, a = 0; a < 9; a++)
        n.probe.push(new Vector3);
    var o = new Vector3
      , s = new Matrix4
      , l = new Matrix4;
    return {
        setup: function(a, o) {
            for (var s = 0, l = 0, u = 0, c = 0; c < 9; c++)
                n.probe[c].set(0, 0, 0);
            var h = 0
              , d = 0
              , p = 0
              , f = 0
              , m = 0
              , v = 0
              , g = 0
              , _ = 0;
            a.sort(shadowCastingLightsFirst);
            for (var y = !0 !== o ? Math.PI : 1, x = 0, b = a.length; x < b; x++) {
                var S = a[x]
                  , w = S.color
                  , M = S.intensity
                  , T = S.distance
                  , C = S.shadow && S.shadow.map ? S.shadow.map.texture : null;
                if (S.isAmbientLight)
                    s += w.r * M * y,
                    l += w.g * M * y,
                    u += w.b * M * y;
                else if (S.isLightProbe)
                    for (var E = 0; E < 9; E++)
                        n.probe[E].addScaledVector(S.sh.coefficients[E], M);
                else if (S.isDirectionalLight) {
                    var P = r.get(S);
                    if (P.color.copy(S.color).multiplyScalar(S.intensity * y),
                    S.castShadow) {
                        var A = S.shadow
                          , k = i.get(S);
                        k.shadowBias = A.bias,
                        k.shadowNormalBias = A.normalBias,
                        k.shadowRadius = A.radius,
                        k.shadowMapSize = A.mapSize,
                        n.directionalShadow[h] = k,
                        n.directionalShadowMap[h] = C,
                        n.directionalShadowMatrix[h] = S.shadow.matrix,
                        v++
                    }
                    n.directional[h] = P,
                    h++
                } else if (S.isSpotLight) {
                    var L = r.get(S);
                    if (L.position.setFromMatrixPosition(S.matrixWorld),
                    L.color.copy(w).multiplyScalar(M * y),
                    L.distance = T,
                    L.coneCos = Math.cos(S.angle),
                    L.penumbraCos = Math.cos(S.angle * (1 - S.penumbra)),
                    L.decay = S.decay,
                    S.castShadow) {
                        var R = S.shadow
                          , D = i.get(S);
                        D.shadowBias = R.bias,
                        D.shadowNormalBias = R.normalBias,
                        D.shadowRadius = R.radius,
                        D.shadowMapSize = R.mapSize,
                        n.spotShadow[p] = D,
                        n.spotShadowMap[p] = C,
                        n.spotShadowMatrix[p] = S.shadow.matrix,
                        _++
                    }
                    n.spot[p] = L,
                    p++
                } else if (S.isRectAreaLight) {
                    var I = r.get(S);
                    I.color.copy(w).multiplyScalar(M),
                    I.halfWidth.set(.5 * S.width, 0, 0),
                    I.halfHeight.set(0, .5 * S.height, 0),
                    n.rectArea[f] = I,
                    f++
                } else if (S.isPointLight) {
                    var O = r.get(S);
                    if (O.color.copy(S.color).multiplyScalar(S.intensity * y),
                    O.distance = S.distance,
                    O.decay = S.decay,
                    S.castShadow) {
                        var N = S.shadow
                          , F = i.get(S);
                        F.shadowBias = N.bias,
                        F.shadowNormalBias = N.normalBias,
                        F.shadowRadius = N.radius,
                        F.shadowMapSize = N.mapSize,
                        F.shadowCameraNear = N.camera.near,
                        F.shadowCameraFar = N.camera.far,
                        n.pointShadow[d] = F,
                        n.pointShadowMap[d] = C,
                        n.pointShadowMatrix[d] = S.shadow.matrix,
                        g++
                    }
                    n.point[d] = O,
                    d++
                } else if (S.isHemisphereLight) {
                    var B = r.get(S);
                    B.skyColor.copy(S.color).multiplyScalar(M * y),
                    B.groundColor.copy(S.groundColor).multiplyScalar(M * y),
                    n.hemi[m] = B,
                    m++
                }
            }
            f > 0 && (t.isWebGL2 || !0 === e.has("OES_texture_float_linear") ? (n.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1,
            n.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2) : !0 === e.has("OES_texture_half_float_linear") ? (n.rectAreaLTC1 = UniformsLib.LTC_HALF_1,
            n.rectAreaLTC2 = UniformsLib.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),
            n.ambient[0] = s,
            n.ambient[1] = l,
            n.ambient[2] = u;
            var z = n.hash;
            z.directionalLength === h && z.pointLength === d && z.spotLength === p && z.rectAreaLength === f && z.hemiLength === m && z.numDirectionalShadows === v && z.numPointShadows === g && z.numSpotShadows === _ || (n.directional.length = h,
            n.spot.length = p,
            n.rectArea.length = f,
            n.point.length = d,
            n.hemi.length = m,
            n.directionalShadow.length = v,
            n.directionalShadowMap.length = v,
            n.pointShadow.length = g,
            n.pointShadowMap.length = g,
            n.spotShadow.length = _,
            n.spotShadowMap.length = _,
            n.directionalShadowMatrix.length = v,
            n.pointShadowMatrix.length = g,
            n.spotShadowMatrix.length = _,
            z.directionalLength = h,
            z.pointLength = d,
            z.spotLength = p,
            z.rectAreaLength = f,
            z.hemiLength = m,
            z.numDirectionalShadows = v,
            z.numPointShadows = g,
            z.numSpotShadows = _,
            n.version = nextVersion++)
        },
        setupView: function(e, t) {
            for (var r = 0, i = 0, a = 0, u = 0, c = 0, h = t.matrixWorldInverse, d = 0, p = e.length; d < p; d++) {
                var f = e[d];
                if (f.isDirectionalLight) {
                    var m = n.directional[r];
                    m.direction.setFromMatrixPosition(f.matrixWorld),
                    o.setFromMatrixPosition(f.target.matrixWorld),
                    m.direction.sub(o),
                    m.direction.transformDirection(h),
                    r++
                } else if (f.isSpotLight) {
                    var v = n.spot[a];
                    v.position.setFromMatrixPosition(f.matrixWorld),
                    v.position.applyMatrix4(h),
                    v.direction.setFromMatrixPosition(f.matrixWorld),
                    o.setFromMatrixPosition(f.target.matrixWorld),
                    v.direction.sub(o),
                    v.direction.transformDirection(h),
                    a++
                } else if (f.isRectAreaLight) {
                    var g = n.rectArea[u];
                    g.position.setFromMatrixPosition(f.matrixWorld),
                    g.position.applyMatrix4(h),
                    l.identity(),
                    s.copy(f.matrixWorld),
                    s.premultiply(h),
                    l.extractRotation(s),
                    g.halfWidth.set(.5 * f.width, 0, 0),
                    g.halfHeight.set(0, .5 * f.height, 0),
                    g.halfWidth.applyMatrix4(l),
                    g.halfHeight.applyMatrix4(l),
                    u++
                } else if (f.isPointLight) {
                    var _ = n.point[i];
                    _.position.setFromMatrixPosition(f.matrixWorld),
                    _.position.applyMatrix4(h),
                    i++
                } else if (f.isHemisphereLight) {
                    var y = n.hemi[c];
                    y.direction.setFromMatrixPosition(f.matrixWorld),
                    y.direction.transformDirection(h),
                    y.direction.normalize(),
                    c++
                }
            }
        },
        state: n
    }
}
function WebGLRenderState(e, t) {
    var r = new WebGLLights(e,t)
      , i = []
      , n = [];
    return {
        init: function() {
            i.length = 0,
            n.length = 0
        },
        state: {
            lightsArray: i,
            shadowsArray: n,
            lights: r
        },
        setupLights: function(e) {
            r.setup(i, e)
        },
        setupLightsView: function(e) {
            r.setupView(i, e)
        },
        pushLight: function(e) {
            i.push(e)
        },
        pushShadow: function(e) {
            n.push(e)
        }
    }
}
function WebGLRenderStates(e, t) {
    var r = new WeakMap;
    return {
        get: function(i) {
            var n, a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
            return !1 === r.has(i) ? (n = new WebGLRenderState(e,t),
            r.set(i, [n])) : a >= r.get(i).length ? (n = new WebGLRenderState(e,t),
            r.get(i).push(n)) : n = r.get(i)[a],
            n
        },
        dispose: function() {
            r = new WeakMap
        }
    }
}
var MeshDepthMaterial = function(e) {
    _inherits(r, Material);
    var t = _createSuper(r);
    function r(e) {
        var i;
        return _classCallCheck(this, r),
        (i = t.call(this)).type = "MeshDepthMaterial",
        i.depthPacking = BasicDepthPacking,
        i.map = null,
        i.alphaMap = null,
        i.displacementMap = null,
        i.displacementScale = 1,
        i.displacementBias = 0,
        i.wireframe = !1,
        i.wireframeLinewidth = 1,
        i.fog = !1,
        i.setValues(e),
        i
    }
    return _createClass(r, [{
        key: "copy",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e),
            this.depthPacking = e.depthPacking,
            this.map = e.map,
            this.alphaMap = e.alphaMap,
            this.displacementMap = e.displacementMap,
            this.displacementScale = e.displacementScale,
            this.displacementBias = e.displacementBias,
            this.wireframe = e.wireframe,
            this.wireframeLinewidth = e.wireframeLinewidth,
            this
        }
    }]),
    r
}();
MeshDepthMaterial.prototype.isMeshDepthMaterial = !0;
var MeshDistanceMaterial = function(e) {
    _inherits(r, Material);
    var t = _createSuper(r);
    function r(e) {
        var i;
        return _classCallCheck(this, r),
        (i = t.call(this)).type = "MeshDistanceMaterial",
        i.referencePosition = new Vector3,
        i.nearDistance = 1,
        i.farDistance = 1e3,
        i.map = null,
        i.alphaMap = null,
        i.displacementMap = null,
        i.displacementScale = 1,
        i.displacementBias = 0,
        i.fog = !1,
        i.setValues(e),
        i
    }
    return _createClass(r, [{
        key: "copy",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e),
            this.referencePosition.copy(e.referencePosition),
            this.nearDistance = e.nearDistance,
            this.farDistance = e.farDistance,
            this.map = e.map,
            this.alphaMap = e.alphaMap,
            this.displacementMap = e.displacementMap,
            this.displacementScale = e.displacementScale,
            this.displacementBias = e.displacementBias,
            this
        }
    }]),
    r
}();
MeshDistanceMaterial.prototype.isMeshDistanceMaterial = !0;
var vertex = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}"
  , fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
function WebGLShadowMap(e, t, r) {
    var i = new Frustum
      , n = new Vector2
      , a = new Vector2
      , o = new Vector4
      , s = new MeshDepthMaterial({
        depthPacking: RGBADepthPacking
    })
      , l = new MeshDistanceMaterial
      , u = {}
      , c = r.maxTextureSize
      , h = {
        0: BackSide,
        1: FrontSide,
        2: DoubleSide
    }
      , d = new ShaderMaterial({
        defines: {
            VSM_SAMPLES: 8
        },
        uniforms: {
            shadow_pass: {
                value: null
            },
            resolution: {
                value: new Vector2
            },
            radius: {
                value: 4
            }
        },
        vertexShader: vertex,
        fragmentShader: fragment
    })
      , p = d.clone();
    p.defines.HORIZONTAL_PASS = 1;
    var f = new BufferGeometry;
    f.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
    var m = new Mesh(f,d)
      , v = this;
    function g(r, i) {
        var n = t.update(m);
        d.defines.VSM_SAMPLES !== r.blurSamples && (d.defines.VSM_SAMPLES = r.blurSamples,
        p.defines.VSM_SAMPLES = r.blurSamples,
        d.needsUpdate = !0,
        p.needsUpdate = !0),
        d.uniforms.shadow_pass.value = r.map.texture,
        d.uniforms.resolution.value = r.mapSize,
        d.uniforms.radius.value = r.radius,
        e.setRenderTarget(r.mapPass),
        e.clear(),
        e.renderBufferDirect(i, null, n, d, m, null),
        p.uniforms.shadow_pass.value = r.mapPass.texture,
        p.uniforms.resolution.value = r.mapSize,
        p.uniforms.radius.value = r.radius,
        e.setRenderTarget(r.map),
        e.clear(),
        e.renderBufferDirect(i, null, n, p, m, null)
    }
    function _(t, r, i, n, a, o) {
        var c = null
          , d = !0 === i.isPointLight ? t.customDistanceMaterial : t.customDepthMaterial;
        if (c = void 0 !== d ? d : !0 === i.isPointLight ? l : s,
        e.localClippingEnabled && !0 === r.clipShadows && 0 !== r.clippingPlanes.length || r.displacementMap && 0 !== r.displacementScale || r.alphaMap && r.alphaTest > 0) {
            var p = c.uuid
              , f = r.uuid
              , m = u[p];
            void 0 === m && (m = {},
            u[p] = m);
            var v = m[f];
            void 0 === v && (v = c.clone(),
            m[f] = v),
            c = v
        }
        return c.visible = r.visible,
        c.wireframe = r.wireframe,
        c.side = o === VSMShadowMap ? null !== r.shadowSide ? r.shadowSide : r.side : null !== r.shadowSide ? r.shadowSide : h[r.side],
        c.alphaMap = r.alphaMap,
        c.alphaTest = r.alphaTest,
        c.clipShadows = r.clipShadows,
        c.clippingPlanes = r.clippingPlanes,
        c.clipIntersection = r.clipIntersection,
        c.displacementMap = r.displacementMap,
        c.displacementScale = r.displacementScale,
        c.displacementBias = r.displacementBias,
        c.wireframeLinewidth = r.wireframeLinewidth,
        c.linewidth = r.linewidth,
        !0 === i.isPointLight && !0 === c.isMeshDistanceMaterial && (c.referencePosition.setFromMatrixPosition(i.matrixWorld),
        c.nearDistance = n,
        c.farDistance = a),
        c
    }
    function y(r, n, a, o, s) {
        if (!1 !== r.visible) {
            if (r.layers.test(n.layers) && (r.isMesh || r.isLine || r.isPoints) && (r.castShadow || r.receiveShadow && s === VSMShadowMap) && (!r.frustumCulled || i.intersectsObject(r))) {
                r.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, r.matrixWorld);
                var l = t.update(r)
                  , u = r.material;
                if (Array.isArray(u))
                    for (var c = l.groups, h = 0, d = c.length; h < d; h++) {
                        var p = c[h]
                          , f = u[p.materialIndex];
                        if (f && f.visible) {
                            var m = _(r, f, o, a.near, a.far, s);
                            e.renderBufferDirect(a, null, l, m, r, p)
                        }
                    }
                else if (u.visible) {
                    var v = _(r, u, o, a.near, a.far, s);
                    e.renderBufferDirect(a, null, l, v, r, null)
                }
            }
            for (var g = r.children, x = 0, b = g.length; x < b; x++)
                y(g[x], n, a, o, s)
        }
    }
    this.enabled = !1,
    this.autoUpdate = !0,
    this.needsUpdate = !1,
    this.type = PCFShadowMap,
    this.render = function(t, r, s) {
        if (!1 !== v.enabled && (!1 !== v.autoUpdate || !1 !== v.needsUpdate) && 0 !== t.length) {
            var l = e.getRenderTarget()
              , u = e.getActiveCubeFace()
              , h = e.getActiveMipmapLevel()
              , d = e.state;
            d.setBlending(NoBlending),
            d.buffers.color.setClear(1, 1, 1, 1),
            d.buffers.depth.setTest(!0),
            d.setScissorTest(!1);
            for (var p = 0, f = t.length; p < f; p++) {
                var m = t[p]
                  , _ = m.shadow;
                if (void 0 !== _) {
                    if (!1 !== _.autoUpdate || !1 !== _.needsUpdate) {
                        n.copy(_.mapSize);
                        var x = _.getFrameExtents();
                        if (n.multiply(x),
                        a.copy(_.mapSize),
                        (n.x > c || n.y > c) && (n.x > c && (a.x = Math.floor(c / x.x),
                        n.x = a.x * x.x,
                        _.mapSize.x = a.x),
                        n.y > c && (a.y = Math.floor(c / x.y),
                        n.y = a.y * x.y,
                        _.mapSize.y = a.y)),
                        null !== _.map || _.isPointLightShadow || this.type !== VSMShadowMap || (_.map = new WebGLRenderTarget(n.x,n.y),
                        _.map.texture.name = m.name + ".shadowMap",
                        _.mapPass = new WebGLRenderTarget(n.x,n.y),
                        _.camera.updateProjectionMatrix()),
                        null === _.map) {
                            var b = {
                                minFilter: NearestFilter,
                                magFilter: NearestFilter,
                                format: RGBAFormat
                            };
                            _.map = new WebGLRenderTarget(n.x,n.y,b),
                            _.map.texture.name = m.name + ".shadowMap",
                            _.camera.updateProjectionMatrix()
                        }
                        e.setRenderTarget(_.map),
                        e.clear();
                        for (var S = _.getViewportCount(), w = 0; w < S; w++) {
                            var M = _.getViewport(w);
                            o.set(a.x * M.x, a.y * M.y, a.x * M.z, a.y * M.w),
                            d.viewport(o),
                            _.updateMatrices(m, w),
                            i = _.getFrustum(),
                            y(r, s, _.camera, m, this.type)
                        }
                        _.isPointLightShadow || this.type !== VSMShadowMap || g(_, s),
                        _.needsUpdate = !1
                    }
                } else
                    console.warn("THREE.WebGLShadowMap:", m, "has no shadow.")
            }
            v.needsUpdate = !1,
            e.setRenderTarget(l, u, h)
        }
    }
}
function WebGLState(e, t, r) {
    var i, n, a = r.isWebGL2, o = new function() {
        var t = !1
          , r = new Vector4
          , i = null
          , n = new Vector4(0,0,0,0);
        return {
            setMask: function(r) {
                i === r || t || (e.colorMask(r, r, r, r),
                i = r)
            },
            setLocked: function(e) {
                t = e
            },
            setClear: function(t, i, a, o, s) {
                !0 === s && (t *= o,
                i *= o,
                a *= o),
                r.set(t, i, a, o),
                !1 === n.equals(r) && (e.clearColor(t, i, a, o),
                n.copy(r))
            },
            reset: function() {
                t = !1,
                i = null,
                n.set(-1, 0, 0, 0)
            }
        }
    }
    , s = new function() {
        var t = !1
          , r = null
          , i = null
          , n = null;
        return {
            setTest: function(e) {
                e ? U(2929) : V(2929)
            },
            setMask: function(i) {
                r === i || t || (e.depthMask(i),
                r = i)
            },
            setFunc: function(t) {
                if (i !== t) {
                    if (t)
                        switch (t) {
                        case NeverDepth:
                            e.depthFunc(512);
                            break;
                        case AlwaysDepth:
                            e.depthFunc(519);
                            break;
                        case LessDepth:
                            e.depthFunc(513);
                            break;
                        case LessEqualDepth:
                            e.depthFunc(515);
                            break;
                        case EqualDepth:
                            e.depthFunc(514);
                            break;
                        case GreaterEqualDepth:
                            e.depthFunc(518);
                            break;
                        case GreaterDepth:
                            e.depthFunc(516);
                            break;
                        case NotEqualDepth:
                            e.depthFunc(517);
                            break;
                        default:
                            e.depthFunc(515)
                        }
                    else
                        e.depthFunc(515);
                    i = t
                }
            },
            setLocked: function(e) {
                t = e
            },
            setClear: function(t) {
                n !== t && (e.clearDepth(t),
                n = t)
            },
            reset: function() {
                t = !1,
                r = null,
                i = null,
                n = null
            }
        }
    }
    , l = new function() {
        var t = !1
          , r = null
          , i = null
          , n = null
          , a = null
          , o = null
          , s = null
          , l = null
          , u = null;
        return {
            setTest: function(e) {
                t || (e ? U(2960) : V(2960))
            },
            setMask: function(i) {
                r === i || t || (e.stencilMask(i),
                r = i)
            },
            setFunc: function(t, r, o) {
                i === t && n === r && a === o || (e.stencilFunc(t, r, o),
                i = t,
                n = r,
                a = o)
            },
            setOp: function(t, r, i) {
                o === t && s === r && l === i || (e.stencilOp(t, r, i),
                o = t,
                s = r,
                l = i)
            },
            setLocked: function(e) {
                t = e
            },
            setClear: function(t) {
                u !== t && (e.clearStencil(t),
                u = t)
            },
            reset: function() {
                t = !1,
                r = null,
                i = null,
                n = null,
                a = null,
                o = null,
                s = null,
                l = null,
                u = null
            }
        }
    }
    , u = {}, c = {}, h = new WeakMap, d = [], p = null, f = !1, m = null, v = null, g = null, _ = null, y = null, x = null, b = null, S = !1, w = null, M = null, T = null, C = null, E = null, P = e.getParameter(35661), A = !1, k = 0, L = e.getParameter(7938);
    -1 !== L.indexOf("WebGL") ? (k = parseFloat(/^WebGL (\d)/.exec(L)[1]),
    A = k >= 1) : -1 !== L.indexOf("OpenGL ES") && (k = parseFloat(/^OpenGL ES (\d)/.exec(L)[1]),
    A = k >= 2);
    var R = null
      , D = {}
      , I = e.getParameter(3088)
      , O = e.getParameter(2978)
      , N = (new Vector4).fromArray(I)
      , F = (new Vector4).fromArray(O);
    function B(t, r, i) {
        var n = new Uint8Array(4)
          , a = e.createTexture();
        e.bindTexture(t, a),
        e.texParameteri(t, 10241, 9728),
        e.texParameteri(t, 10240, 9728);
        for (var o = 0; o < i; o++)
            e.texImage2D(r + o, 0, 6408, 1, 1, 0, 6408, 5121, n);
        return a
    }
    var z = {};
    function U(t) {
        !0 !== u[t] && (e.enable(t),
        u[t] = !0)
    }
    function V(t) {
        !1 !== u[t] && (e.disable(t),
        u[t] = !1)
    }
    z[3553] = B(3553, 3553, 1),
    z[34067] = B(34067, 34069, 6),
    o.setClear(0, 0, 0, 1),
    s.setClear(1),
    l.setClear(0),
    U(2929),
    s.setFunc(LessEqualDepth),
    j(!1),
    q(CullFaceBack),
    U(2884),
    $(NoBlending);
    var G = (_defineProperty(i = {}, AddEquation, 32774),
    _defineProperty(i, SubtractEquation, 32778),
    _defineProperty(i, ReverseSubtractEquation, 32779),
    i);
    if (a)
        G[MinEquation] = 32775,
        G[MaxEquation] = 32776;
    else {
        var H = t.get("EXT_blend_minmax");
        null !== H && (G[MinEquation] = H.MIN_EXT,
        G[MaxEquation] = H.MAX_EXT)
    }
    var W = (_defineProperty(n = {}, ZeroFactor, 0),
    _defineProperty(n, OneFactor, 1),
    _defineProperty(n, SrcColorFactor, 768),
    _defineProperty(n, SrcAlphaFactor, 770),
    _defineProperty(n, SrcAlphaSaturateFactor, 776),
    _defineProperty(n, DstColorFactor, 774),
    _defineProperty(n, DstAlphaFactor, 772),
    _defineProperty(n, OneMinusSrcColorFactor, 769),
    _defineProperty(n, OneMinusSrcAlphaFactor, 771),
    _defineProperty(n, OneMinusDstColorFactor, 775),
    _defineProperty(n, OneMinusDstAlphaFactor, 773),
    n);
    function $(t, r, i, n, a, o, s, l) {
        if (t !== NoBlending) {
            if (!1 === f && (U(3042),
            f = !0),
            t === CustomBlending)
                a = a || r,
                o = o || i,
                s = s || n,
                r === v && a === y || (e.blendEquationSeparate(G[r], G[a]),
                v = r,
                y = a),
                i === g && n === _ && o === x && s === b || (e.blendFuncSeparate(W[i], W[n], W[o], W[s]),
                g = i,
                _ = n,
                x = o,
                b = s),
                m = t,
                S = null;
            else if (t !== m || l !== S) {
                if (v === AddEquation && y === AddEquation || (e.blendEquation(32774),
                v = AddEquation,
                y = AddEquation),
                l)
                    switch (t) {
                    case NormalBlending:
                        e.blendFuncSeparate(1, 771, 1, 771);
                        break;
                    case AdditiveBlending:
                        e.blendFunc(1, 1);
                        break;
                    case SubtractiveBlending:
                        e.blendFuncSeparate(0, 769, 0, 1);
                        break;
                    case MultiplyBlending:
                        e.blendFuncSeparate(0, 768, 0, 770);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", t)
                    }
                else
                    switch (t) {
                    case NormalBlending:
                        e.blendFuncSeparate(770, 771, 1, 771);
                        break;
                    case AdditiveBlending:
                        e.blendFunc(770, 1);
                        break;
                    case SubtractiveBlending:
                        e.blendFuncSeparate(0, 769, 0, 1);
                        break;
                    case MultiplyBlending:
                        e.blendFunc(0, 768);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", t)
                    }
                g = null,
                _ = null,
                x = null,
                b = null,
                m = t,
                S = l
            }
        } else
            !0 === f && (V(3042),
            f = !1)
    }
    function j(t) {
        w !== t && (t ? e.frontFace(2304) : e.frontFace(2305),
        w = t)
    }
    function q(t) {
        t !== CullFaceNone ? (U(2884),
        t !== M && (t === CullFaceBack ? e.cullFace(1029) : t === CullFaceFront ? e.cullFace(1028) : e.cullFace(1032))) : V(2884),
        M = t
    }
    function X(t, r, i) {
        t ? (U(32823),
        C === r && E === i || (e.polygonOffset(r, i),
        C = r,
        E = i)) : V(32823)
    }
    function Y(t) {
        void 0 === t && (t = 33984 + P - 1),
        R !== t && (e.activeTexture(t),
        R = t)
    }
    return {
        buffers: {
            color: o,
            depth: s,
            stencil: l
        },
        enable: U,
        disable: V,
        bindFramebuffer: function(t, r) {
            return c[t] !== r && (e.bindFramebuffer(t, r),
            c[t] = r,
            a && (36009 === t && (c[36160] = r),
            36160 === t && (c[36009] = r)),
            !0)
        },
        drawBuffers: function(i, n) {
            var a = d
              , o = !1;
            if (i)
                if (void 0 === (a = h.get(n)) && (a = [],
                h.set(n, a)),
                i.isWebGLMultipleRenderTargets) {
                    var s = i.texture;
                    if (a.length !== s.length || 36064 !== a[0]) {
                        for (var l = 0, u = s.length; l < u; l++)
                            a[l] = 36064 + l;
                        a.length = s.length,
                        o = !0
                    }
                } else
                    36064 !== a[0] && (a[0] = 36064,
                    o = !0);
            else
                1029 !== a[0] && (a[0] = 1029,
                o = !0);
            o && (r.isWebGL2 ? e.drawBuffers(a) : t.get("WEBGL_draw_buffers").drawBuffersWEBGL(a))
        },
        useProgram: function(t) {
            return p !== t && (e.useProgram(t),
            p = t,
            !0)
        },
        setBlending: $,
        setMaterial: function(e, t) {
            e.side === DoubleSide ? V(2884) : U(2884);
            var r = e.side === BackSide;
            t && (r = !r),
            j(r),
            e.blending === NormalBlending && !1 === e.transparent ? $(NoBlending) : $(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha),
            s.setFunc(e.depthFunc),
            s.setTest(e.depthTest),
            s.setMask(e.depthWrite),
            o.setMask(e.colorWrite);
            var i = e.stencilWrite;
            l.setTest(i),
            i && (l.setMask(e.stencilWriteMask),
            l.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask),
            l.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)),
            X(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits),
            !0 === e.alphaToCoverage ? U(32926) : V(32926)
        },
        setFlipSided: j,
        setCullFace: q,
        setLineWidth: function(t) {
            t !== T && (A && e.lineWidth(t),
            T = t)
        },
        setPolygonOffset: X,
        setScissorTest: function(e) {
            e ? U(3089) : V(3089)
        },
        activeTexture: Y,
        bindTexture: function(t, r) {
            null === R && Y();
            var i = D[R];
            void 0 === i && (i = {
                type: void 0,
                texture: void 0
            },
            D[R] = i),
            i.type === t && i.texture === r || (e.bindTexture(t, r || z[t]),
            i.type = t,
            i.texture = r)
        },
        unbindTexture: function() {
            var t = D[R];
            void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null),
            t.type = void 0,
            t.texture = void 0)
        },
        compressedTexImage2D: function() {
            try {
                e.compressedTexImage2D.apply(e, arguments)
            } catch (t) {
                console.error("THREE.WebGLState:", t)
            }
        },
        texImage2D: function() {
            try {
                e.texImage2D.apply(e, arguments)
            } catch (t) {
                console.error("THREE.WebGLState:", t)
            }
        },
        texImage3D: function() {
            try {
                e.texImage3D.apply(e, arguments)
            } catch (t) {
                console.error("THREE.WebGLState:", t)
            }
        },
        texStorage2D: function() {
            try {
                e.texStorage2D.apply(e, arguments)
            } catch (t) {
                console.error("THREE.WebGLState:", t)
            }
        },
        texStorage3D: function() {
            try {
                e.texStorage3D.apply(e, arguments)
            } catch (t) {
                console.error("THREE.WebGLState:", t)
            }
        },
        texSubImage2D: function() {
            try {
                e.texSubImage2D.apply(e, arguments)
            } catch (t) {
                console.error("THREE.WebGLState:", t)
            }
        },
        texSubImage3D: function() {
            try {
                e.texSubImage3D.apply(e, arguments)
            } catch (t) {
                console.error("THREE.WebGLState:", t)
            }
        },
        compressedTexSubImage2D: function() {
            try {
                e.compressedTexSubImage2D.apply(e, arguments)
            } catch (t) {
                console.error("THREE.WebGLState:", t)
            }
        },
        scissor: function(t) {
            !1 === N.equals(t) && (e.scissor(t.x, t.y, t.z, t.w),
            N.copy(t))
        },
        viewport: function(t) {
            !1 === F.equals(t) && (e.viewport(t.x, t.y, t.z, t.w),
            F.copy(t))
        },
        reset: function() {
            e.disable(3042),
            e.disable(2884),
            e.disable(2929),
            e.disable(32823),
            e.disable(3089),
            e.disable(2960),
            e.disable(32926),
            e.blendEquation(32774),
            e.blendFunc(1, 0),
            e.blendFuncSeparate(1, 0, 1, 0),
            e.colorMask(!0, !0, !0, !0),
            e.clearColor(0, 0, 0, 0),
            e.depthMask(!0),
            e.depthFunc(513),
            e.clearDepth(1),
            e.stencilMask(4294967295),
            e.stencilFunc(519, 0, 4294967295),
            e.stencilOp(7680, 7680, 7680),
            e.clearStencil(0),
            e.cullFace(1029),
            e.frontFace(2305),
            e.polygonOffset(0, 0),
            e.activeTexture(33984),
            e.bindFramebuffer(36160, null),
            !0 === a && (e.bindFramebuffer(36009, null),
            e.bindFramebuffer(36008, null)),
            e.useProgram(null),
            e.lineWidth(1),
            e.scissor(0, 0, e.canvas.width, e.canvas.height),
            e.viewport(0, 0, e.canvas.width, e.canvas.height),
            u = {},
            R = null,
            D = {},
            c = {},
            h = new WeakMap,
            d = [],
            p = null,
            f = !1,
            m = null,
            v = null,
            g = null,
            _ = null,
            y = null,
            x = null,
            b = null,
            S = !1,
            w = null,
            M = null,
            T = null,
            C = null,
            E = null,
            N.set(0, 0, e.canvas.width, e.canvas.height),
            F.set(0, 0, e.canvas.width, e.canvas.height),
            o.reset(),
            s.reset(),
            l.reset()
        }
    }
}
function WebGLTextures(e, t, r, i, n, a, o) {
    var s, l, u, c = n.isWebGL2, h = n.maxTextures, d = n.maxCubemapSize, p = n.maxTextureSize, f = n.maxSamples, m = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null, v = /OculusBrowser/g.test(navigator.userAgent), g = new WeakMap, _ = new WeakMap, y = !1;
    try {
        y = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1,1).getContext("2d")
    } catch (W) {}
    function x(e, t) {
        return y ? new OffscreenCanvas(e,t) : createElementNS("canvas")
    }
    function b(e, t, r, i) {
        var n = 1;
        if ((e.width > i || e.height > i) && (n = i / Math.max(e.width, e.height)),
        n < 1 || !0 === t) {
            if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                var a = t ? floorPowerOfTwo : Math.floor
                  , o = a(n * e.width)
                  , s = a(n * e.height);
                void 0 === u && (u = x(o, s));
                var l = r ? x(o, s) : u;
                return l.width = o,
                l.height = s,
                l.getContext("2d").drawImage(e, 0, 0, o, s),
                console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + o + "x" + s + ")."),
                l
            }
            return "data"in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ")."),
            e
        }
        return e
    }
    function S(e) {
        return isPowerOfTwo(e.width) && isPowerOfTwo(e.height)
    }
    function w(e, t) {
        return e.generateMipmaps && t && e.minFilter !== NearestFilter && e.minFilter !== LinearFilter
    }
    function M(t) {
        e.generateMipmap(t)
    }
    function T(r, i, n, a) {
        var o = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
        if (!1 === c)
            return i;
        if (null !== r) {
            if (void 0 !== e[r])
                return e[r];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + r + "'")
        }
        var s = i;
        return 6403 === i && (5126 === n && (s = 33326),
        5131 === n && (s = 33325),
        5121 === n && (s = 33321)),
        33319 === i && (5126 === n && (s = 33328),
        5131 === n && (s = 33327),
        5121 === n && (s = 33323)),
        6408 === i && (5126 === n && (s = 34836),
        5131 === n && (s = 34842),
        5121 === n && (s = a === sRGBEncoding && !1 === o ? 35907 : 32856),
        32819 === n && (s = 32854),
        32820 === n && (s = 32855)),
        33325 !== s && 33326 !== s && 33327 !== s && 33328 !== s && 34842 !== s && 34836 !== s || t.get("EXT_color_buffer_float"),
        s
    }
    function C(e, t, r) {
        return !0 === w(e, r) || e.isFramebufferTexture && e.minFilter !== NearestFilter && e.minFilter !== LinearFilter ? Math.log2(Math.max(t.width, t.height)) + 1 : void 0 !== e.mipmaps && e.mipmaps.length > 0 ? e.mipmaps.length : e.isCompressedTexture && Array.isArray(e.image) ? t.mipmaps.length : 1
    }
    function E(e) {
        return e === NearestFilter || e === NearestMipmapNearestFilter || e === NearestMipmapLinearFilter ? 9728 : 9729
    }
    function P(e) {
        var t = e.target;
        t.removeEventListener("dispose", P),
        function(e) {
            var t = i.get(e);
            if (void 0 !== t.__webglInit) {
                var r = e.source
                  , n = _.get(r);
                if (n) {
                    var a = n[t.__cacheKey];
                    a.usedTimes--,
                    0 === a.usedTimes && k(e),
                    0 === Object.keys(n).length && _.delete(r)
                }
                i.remove(e)
            }
        }(t),
        t.isVideoTexture && g.delete(t)
    }
    function A(t) {
        var r = t.target;
        r.removeEventListener("dispose", A),
        function(t) {
            var r = t.texture
              , n = i.get(t)
              , a = i.get(r);
            if (void 0 !== a.__webglTexture && (e.deleteTexture(a.__webglTexture),
            o.memory.textures--),
            t.depthTexture && t.depthTexture.dispose(),
            t.isWebGLCubeRenderTarget)
                for (var s = 0; s < 6; s++)
                    e.deleteFramebuffer(n.__webglFramebuffer[s]),
                    n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer[s]);
            else
                e.deleteFramebuffer(n.__webglFramebuffer),
                n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer),
                n.__webglMultisampledFramebuffer && e.deleteFramebuffer(n.__webglMultisampledFramebuffer),
                n.__webglColorRenderbuffer && e.deleteRenderbuffer(n.__webglColorRenderbuffer),
                n.__webglDepthRenderbuffer && e.deleteRenderbuffer(n.__webglDepthRenderbuffer);
            if (t.isWebGLMultipleRenderTargets)
                for (var l = 0, u = r.length; l < u; l++) {
                    var c = i.get(r[l]);
                    c.__webglTexture && (e.deleteTexture(c.__webglTexture),
                    o.memory.textures--),
                    i.remove(r[l])
                }
            i.remove(r),
            i.remove(t)
        }(r)
    }
    function k(t) {
        var r = i.get(t);
        e.deleteTexture(r.__webglTexture);
        var n = t.source;
        delete _.get(n)[r.__cacheKey],
        o.memory.textures--
    }
    var L = 0;
    function R(e, t) {
        var n = i.get(e);
        if (e.isVideoTexture && function(e) {
            var t = o.render.frame;
            g.get(e) !== t && (g.set(e, t),
            e.update())
        }(e),
        !1 === e.isRenderTargetTexture && e.version > 0 && n.__version !== e.version) {
            var a = e.image;
            if (null === a)
                console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else {
                if (!1 !== a.complete)
                    return void F(n, e, t);
                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
            }
        }
        r.activeTexture(33984 + t),
        r.bindTexture(3553, n.__webglTexture)
    }
    var D = (_defineProperty(s = {}, RepeatWrapping, 10497),
    _defineProperty(s, ClampToEdgeWrapping, 33071),
    _defineProperty(s, MirroredRepeatWrapping, 33648),
    s)
      , I = (_defineProperty(l = {}, NearestFilter, 9728),
    _defineProperty(l, NearestMipmapNearestFilter, 9984),
    _defineProperty(l, NearestMipmapLinearFilter, 9986),
    _defineProperty(l, LinearFilter, 9729),
    _defineProperty(l, LinearMipmapNearestFilter, 9985),
    _defineProperty(l, LinearMipmapLinearFilter, 9987),
    l);
    function O(r, a, o) {
        if (o ? (e.texParameteri(r, 10242, D[a.wrapS]),
        e.texParameteri(r, 10243, D[a.wrapT]),
        32879 !== r && 35866 !== r || e.texParameteri(r, 32882, D[a.wrapR]),
        e.texParameteri(r, 10240, I[a.magFilter]),
        e.texParameteri(r, 10241, I[a.minFilter])) : (e.texParameteri(r, 10242, 33071),
        e.texParameteri(r, 10243, 33071),
        32879 !== r && 35866 !== r || e.texParameteri(r, 32882, 33071),
        a.wrapS === ClampToEdgeWrapping && a.wrapT === ClampToEdgeWrapping || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),
        e.texParameteri(r, 10240, E(a.magFilter)),
        e.texParameteri(r, 10241, E(a.minFilter)),
        a.minFilter !== NearestFilter && a.minFilter !== LinearFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),
        !0 === t.has("EXT_texture_filter_anisotropic")) {
            var s = t.get("EXT_texture_filter_anisotropic");
            if (a.type === FloatType && !1 === t.has("OES_texture_float_linear"))
                return;
            if (!1 === c && a.type === HalfFloatType && !1 === t.has("OES_texture_half_float_linear"))
                return;
            (a.anisotropy > 1 || i.get(a).__currentAnisotropy) && (e.texParameterf(r, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, n.getMaxAnisotropy())),
            i.get(a).__currentAnisotropy = a.anisotropy)
        }
    }
    function N(t, r) {
        var i = !1;
        void 0 === t.__webglInit && (t.__webglInit = !0,
        r.addEventListener("dispose", P));
        var n = r.source
          , a = _.get(n);
        void 0 === a && (a = {},
        _.set(n, a));
        var s = function(e) {
            var t = [];
            return t.push(e.wrapS),
            t.push(e.wrapT),
            t.push(e.magFilter),
            t.push(e.minFilter),
            t.push(e.anisotropy),
            t.push(e.internalFormat),
            t.push(e.format),
            t.push(e.type),
            t.push(e.generateMipmaps),
            t.push(e.premultiplyAlpha),
            t.push(e.flipY),
            t.push(e.unpackAlignment),
            t.push(e.encoding),
            t.join()
        }(r);
        if (s !== t.__cacheKey) {
            void 0 === a[s] && (a[s] = {
                texture: e.createTexture(),
                usedTimes: 0
            },
            o.memory.textures++,
            i = !0),
            a[s].usedTimes++;
            var l = a[t.__cacheKey];
            void 0 !== l && (a[t.__cacheKey].usedTimes--,
            0 === l.usedTimes && k(r)),
            t.__cacheKey = s,
            t.__webglTexture = a[s].texture
        }
        return i
    }
    function F(t, i, n) {
        var o = 3553;
        i.isDataArrayTexture && (o = 35866),
        i.isData3DTexture && (o = 32879);
        var s = N(t, i)
          , l = i.source;
        if (r.activeTexture(33984 + n),
        r.bindTexture(o, t.__webglTexture),
        l.version !== l.__currentVersion || !0 === s) {
            e.pixelStorei(37440, i.flipY),
            e.pixelStorei(37441, i.premultiplyAlpha),
            e.pixelStorei(3317, i.unpackAlignment),
            e.pixelStorei(37443, 0);
            var u, h = function(e) {
                return !c && (e.wrapS !== ClampToEdgeWrapping || e.wrapT !== ClampToEdgeWrapping || e.minFilter !== NearestFilter && e.minFilter !== LinearFilter)
            }(i) && !1 === S(i.image), d = b(i.image, h, !1, p), f = S(d = H(i, d)) || c, m = a.convert(i.format, i.encoding), v = a.convert(i.type), g = T(i.internalFormat, m, v, i.encoding, i.isVideoTexture);
            O(o, i, f);
            var _ = i.mipmaps
              , y = c && !0 !== i.isVideoTexture
              , x = void 0 === t.__version
              , E = C(i, d, f);
            if (i.isDepthTexture)
                g = 6402,
                c ? g = i.type === FloatType ? 36012 : i.type === UnsignedIntType ? 33190 : i.type === UnsignedInt248Type ? 35056 : 33189 : i.type === FloatType && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),
                i.format === DepthFormat && 6402 === g && i.type !== UnsignedShortType && i.type !== UnsignedIntType && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
                i.type = UnsignedShortType,
                v = a.convert(i.type)),
                i.format === DepthStencilFormat && 6402 === g && (g = 34041,
                i.type !== UnsignedInt248Type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),
                i.type = UnsignedInt248Type,
                v = a.convert(i.type))),
                y && x ? r.texStorage2D(3553, 1, g, d.width, d.height) : r.texImage2D(3553, 0, g, d.width, d.height, 0, m, v, null);
            else if (i.isDataTexture)
                if (_.length > 0 && f) {
                    y && x && r.texStorage2D(3553, E, g, _[0].width, _[0].height);
                    for (var P = 0, A = _.length; P < A; P++)
                        u = _[P],
                        y ? r.texSubImage2D(3553, P, 0, 0, u.width, u.height, m, v, u.data) : r.texImage2D(3553, P, g, u.width, u.height, 0, m, v, u.data);
                    i.generateMipmaps = !1
                } else
                    y ? (x && r.texStorage2D(3553, E, g, d.width, d.height),
                    r.texSubImage2D(3553, 0, 0, 0, d.width, d.height, m, v, d.data)) : r.texImage2D(3553, 0, g, d.width, d.height, 0, m, v, d.data);
            else if (i.isCompressedTexture) {
                y && x && r.texStorage2D(3553, E, g, _[0].width, _[0].height);
                for (var k = 0, L = _.length; k < L; k++)
                    u = _[k],
                    i.format !== RGBAFormat ? null !== m ? y ? r.compressedTexSubImage2D(3553, k, 0, 0, u.width, u.height, m, u.data) : r.compressedTexImage2D(3553, k, g, u.width, u.height, 0, u.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : y ? r.texSubImage2D(3553, k, 0, 0, u.width, u.height, m, v, u.data) : r.texImage2D(3553, k, g, u.width, u.height, 0, m, v, u.data)
            } else if (i.isDataArrayTexture)
                y ? (x && r.texStorage3D(35866, E, g, d.width, d.height, d.depth),
                r.texSubImage3D(35866, 0, 0, 0, 0, d.width, d.height, d.depth, m, v, d.data)) : r.texImage3D(35866, 0, g, d.width, d.height, d.depth, 0, m, v, d.data);
            else if (i.isData3DTexture)
                y ? (x && r.texStorage3D(32879, E, g, d.width, d.height, d.depth),
                r.texSubImage3D(32879, 0, 0, 0, 0, d.width, d.height, d.depth, m, v, d.data)) : r.texImage3D(32879, 0, g, d.width, d.height, d.depth, 0, m, v, d.data);
            else if (i.isFramebufferTexture)
                y && x ? r.texStorage2D(3553, E, g, d.width, d.height) : r.texImage2D(3553, 0, g, d.width, d.height, 0, m, v, null);
            else if (_.length > 0 && f) {
                y && x && r.texStorage2D(3553, E, g, _[0].width, _[0].height);
                for (var R = 0, D = _.length; R < D; R++)
                    u = _[R],
                    y ? r.texSubImage2D(3553, R, 0, 0, m, v, u) : r.texImage2D(3553, R, g, m, v, u);
                i.generateMipmaps = !1
            } else
                y ? (x && r.texStorage2D(3553, E, g, d.width, d.height),
                r.texSubImage2D(3553, 0, 0, 0, m, v, d)) : r.texImage2D(3553, 0, g, m, v, d);
            w(i, f) && M(o),
            l.__currentVersion = l.version,
            i.onUpdate && i.onUpdate(i)
        }
        t.__version = i.version
    }
    function B(t, n, o, s, l) {
        var u = a.convert(o.format, o.encoding)
          , c = a.convert(o.type)
          , h = T(o.internalFormat, u, c, o.encoding);
        i.get(n).__hasExternalTextures || (32879 === l || 35866 === l ? r.texImage3D(l, 0, h, n.width, n.height, n.depth, 0, u, c, null) : r.texImage2D(l, 0, h, n.width, n.height, 0, u, c, null)),
        r.bindFramebuffer(36160, t),
        G(n) ? m.framebufferTexture2DMultisampleEXT(36160, s, l, i.get(o).__webglTexture, 0, V(n)) : e.framebufferTexture2D(36160, s, l, i.get(o).__webglTexture, 0),
        r.bindFramebuffer(36160, null)
    }
    function z(t, r, i) {
        if (e.bindRenderbuffer(36161, t),
        r.depthBuffer && !r.stencilBuffer) {
            var n = 33189;
            if (i || G(r)) {
                var o = r.depthTexture;
                o && o.isDepthTexture && (o.type === FloatType ? n = 36012 : o.type === UnsignedIntType && (n = 33190));
                var s = V(r);
                G(r) ? m.renderbufferStorageMultisampleEXT(36161, s, n, r.width, r.height) : e.renderbufferStorageMultisample(36161, s, n, r.width, r.height)
            } else
                e.renderbufferStorage(36161, n, r.width, r.height);
            e.framebufferRenderbuffer(36160, 36096, 36161, t)
        } else if (r.depthBuffer && r.stencilBuffer) {
            var l = V(r);
            i && !1 === G(r) ? e.renderbufferStorageMultisample(36161, l, 35056, r.width, r.height) : G(r) ? m.renderbufferStorageMultisampleEXT(36161, l, 35056, r.width, r.height) : e.renderbufferStorage(36161, 34041, r.width, r.height),
            e.framebufferRenderbuffer(36160, 33306, 36161, t)
        } else {
            var u = !0 === r.isWebGLMultipleRenderTargets ? r.texture[0] : r.texture
              , c = a.convert(u.format, u.encoding)
              , h = a.convert(u.type)
              , d = T(u.internalFormat, c, h, u.encoding)
              , p = V(r);
            i && !1 === G(r) ? e.renderbufferStorageMultisample(36161, p, d, r.width, r.height) : G(r) ? m.renderbufferStorageMultisampleEXT(36161, p, d, r.width, r.height) : e.renderbufferStorage(36161, d, r.width, r.height)
        }
        e.bindRenderbuffer(36161, null)
    }
    function U(t) {
        var n = i.get(t)
          , a = !0 === t.isWebGLCubeRenderTarget;
        if (t.depthTexture && !n.__autoAllocateDepthBuffer) {
            if (a)
                throw new Error("target.depthTexture not supported in Cube render targets");
            !function(t, n) {
                if (n && n.isWebGLCubeRenderTarget)
                    throw new Error("Depth Texture with cube render targets is not supported");
                if (r.bindFramebuffer(36160, t),
                !n.depthTexture || !n.depthTexture.isDepthTexture)
                    throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                i.get(n.depthTexture).__webglTexture && n.depthTexture.image.width === n.width && n.depthTexture.image.height === n.height || (n.depthTexture.image.width = n.width,
                n.depthTexture.image.height = n.height,
                n.depthTexture.needsUpdate = !0),
                R(n.depthTexture, 0);
                var a = i.get(n.depthTexture).__webglTexture
                  , o = V(n);
                if (n.depthTexture.format === DepthFormat)
                    G(n) ? m.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, a, 0, o) : e.framebufferTexture2D(36160, 36096, 3553, a, 0);
                else {
                    if (n.depthTexture.format !== DepthStencilFormat)
                        throw new Error("Unknown depthTexture format");
                    G(n) ? m.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, a, 0, o) : e.framebufferTexture2D(36160, 33306, 3553, a, 0)
                }
            }(n.__webglFramebuffer, t)
        } else if (a) {
            n.__webglDepthbuffer = [];
            for (var o = 0; o < 6; o++)
                r.bindFramebuffer(36160, n.__webglFramebuffer[o]),
                n.__webglDepthbuffer[o] = e.createRenderbuffer(),
                z(n.__webglDepthbuffer[o], t, !1)
        } else
            r.bindFramebuffer(36160, n.__webglFramebuffer),
            n.__webglDepthbuffer = e.createRenderbuffer(),
            z(n.__webglDepthbuffer, t, !1);
        r.bindFramebuffer(36160, null)
    }
    function V(e) {
        return Math.min(f, e.samples)
    }
    function G(e) {
        var r = i.get(e);
        return c && e.samples > 0 && !0 === t.has("WEBGL_multisampled_render_to_texture") && !1 !== r.__useRenderToTexture
    }
    function H(e, r) {
        var i = e.encoding
          , n = e.format
          , a = e.type;
        return !0 === e.isCompressedTexture || !0 === e.isVideoTexture || e.format === _SRGBAFormat || i !== LinearEncoding && (i === sRGBEncoding ? !1 === c ? !0 === t.has("EXT_sRGB") && n === RGBAFormat ? (e.format = _SRGBAFormat,
        e.minFilter = LinearFilter,
        e.generateMipmaps = !1) : r = ImageUtils.sRGBToLinear(r) : n === RGBAFormat && a === UnsignedByteType || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", i)),
        r
    }
    this.allocateTextureUnit = function() {
        var e = L;
        return e >= h && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + h),
        L += 1,
        e
    }
    ,
    this.resetTextureUnits = function() {
        L = 0
    }
    ,
    this.setTexture2D = R,
    this.setTexture2DArray = function(e, t) {
        var n = i.get(e);
        e.version > 0 && n.__version !== e.version ? F(n, e, t) : (r.activeTexture(33984 + t),
        r.bindTexture(35866, n.__webglTexture))
    }
    ,
    this.setTexture3D = function(e, t) {
        var n = i.get(e);
        e.version > 0 && n.__version !== e.version ? F(n, e, t) : (r.activeTexture(33984 + t),
        r.bindTexture(32879, n.__webglTexture))
    }
    ,
    this.setTextureCube = function(t, n) {
        var o = i.get(t);
        t.version > 0 && o.__version !== t.version ? function(t, i, n) {
            if (6 === i.image.length) {
                var o = N(t, i)
                  , s = i.source;
                if (r.activeTexture(33984 + n),
                r.bindTexture(34067, t.__webglTexture),
                s.version !== s.__currentVersion || !0 === o) {
                    e.pixelStorei(37440, i.flipY),
                    e.pixelStorei(37441, i.premultiplyAlpha),
                    e.pixelStorei(3317, i.unpackAlignment),
                    e.pixelStorei(37443, 0);
                    for (var l = i.isCompressedTexture || i.image[0].isCompressedTexture, u = i.image[0] && i.image[0].isDataTexture, h = [], p = 0; p < 6; p++)
                        h[p] = l || u ? u ? i.image[p].image : i.image[p] : b(i.image[p], !1, !0, d),
                        h[p] = H(i, h[p]);
                    var f, m = h[0], v = S(m) || c, g = a.convert(i.format, i.encoding), _ = a.convert(i.type), y = T(i.internalFormat, g, _, i.encoding), x = c && !0 !== i.isVideoTexture, E = void 0 === t.__version, P = C(i, m, v);
                    if (O(34067, i, v),
                    l) {
                        x && E && r.texStorage2D(34067, P, y, m.width, m.height);
                        for (var A = 0; A < 6; A++) {
                            f = h[A].mipmaps;
                            for (var k = 0; k < f.length; k++) {
                                var L = f[k];
                                i.format !== RGBAFormat ? null !== g ? x ? r.compressedTexSubImage2D(34069 + A, k, 0, 0, L.width, L.height, g, L.data) : r.compressedTexImage2D(34069 + A, k, y, L.width, L.height, 0, L.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : x ? r.texSubImage2D(34069 + A, k, 0, 0, L.width, L.height, g, _, L.data) : r.texImage2D(34069 + A, k, y, L.width, L.height, 0, g, _, L.data)
                            }
                        }
                    } else {
                        f = i.mipmaps,
                        x && E && (f.length > 0 && P++,
                        r.texStorage2D(34067, P, y, h[0].width, h[0].height));
                        for (var R = 0; R < 6; R++)
                            if (u) {
                                x ? r.texSubImage2D(34069 + R, 0, 0, 0, h[R].width, h[R].height, g, _, h[R].data) : r.texImage2D(34069 + R, 0, y, h[R].width, h[R].height, 0, g, _, h[R].data);
                                for (var D = 0; D < f.length; D++) {
                                    var I = f[D].image[R].image;
                                    x ? r.texSubImage2D(34069 + R, D + 1, 0, 0, I.width, I.height, g, _, I.data) : r.texImage2D(34069 + R, D + 1, y, I.width, I.height, 0, g, _, I.data)
                                }
                            } else {
                                x ? r.texSubImage2D(34069 + R, 0, 0, 0, g, _, h[R]) : r.texImage2D(34069 + R, 0, y, g, _, h[R]);
                                for (var F = 0; F < f.length; F++) {
                                    var B = f[F];
                                    x ? r.texSubImage2D(34069 + R, F + 1, 0, 0, g, _, B.image[R]) : r.texImage2D(34069 + R, F + 1, y, g, _, B.image[R])
                                }
                            }
                    }
                    w(i, v) && M(34067),
                    s.__currentVersion = s.version,
                    i.onUpdate && i.onUpdate(i)
                }
                t.__version = i.version
            }
        }(o, t, n) : (r.activeTexture(33984 + n),
        r.bindTexture(34067, o.__webglTexture))
    }
    ,
    this.rebindTextures = function(e, t, r) {
        var n = i.get(e);
        void 0 !== t && B(n.__webglFramebuffer, e, e.texture, 36064, 3553),
        void 0 !== r && U(e)
    }
    ,
    this.setupRenderTarget = function(t) {
        var s = t.texture
          , l = i.get(t)
          , u = i.get(s);
        t.addEventListener("dispose", A),
        !0 !== t.isWebGLMultipleRenderTargets && (void 0 === u.__webglTexture && (u.__webglTexture = e.createTexture()),
        u.__version = s.version,
        o.memory.textures++);
        var h = !0 === t.isWebGLCubeRenderTarget
          , d = !0 === t.isWebGLMultipleRenderTargets
          , p = S(t) || c;
        if (h) {
            l.__webglFramebuffer = [];
            for (var f = 0; f < 6; f++)
                l.__webglFramebuffer[f] = e.createFramebuffer()
        } else if (l.__webglFramebuffer = e.createFramebuffer(),
        d)
            if (n.drawBuffers)
                for (var m = t.texture, v = 0, g = m.length; v < g; v++) {
                    var _ = i.get(m[v]);
                    void 0 === _.__webglTexture && (_.__webglTexture = e.createTexture(),
                    o.memory.textures++)
                }
            else
                console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
        else if (c && t.samples > 0 && !1 === G(t)) {
            l.__webglMultisampledFramebuffer = e.createFramebuffer(),
            l.__webglColorRenderbuffer = e.createRenderbuffer(),
            e.bindRenderbuffer(36161, l.__webglColorRenderbuffer);
            var y = a.convert(s.format, s.encoding)
              , x = a.convert(s.type)
              , b = T(s.internalFormat, y, x, s.encoding)
              , C = V(t);
            e.renderbufferStorageMultisample(36161, C, b, t.width, t.height),
            r.bindFramebuffer(36160, l.__webglMultisampledFramebuffer),
            e.framebufferRenderbuffer(36160, 36064, 36161, l.__webglColorRenderbuffer),
            e.bindRenderbuffer(36161, null),
            t.depthBuffer && (l.__webglDepthRenderbuffer = e.createRenderbuffer(),
            z(l.__webglDepthRenderbuffer, t, !0)),
            r.bindFramebuffer(36160, null)
        }
        if (h) {
            r.bindTexture(34067, u.__webglTexture),
            O(34067, s, p);
            for (var E = 0; E < 6; E++)
                B(l.__webglFramebuffer[E], t, s, 36064, 34069 + E);
            w(s, p) && M(34067),
            r.unbindTexture()
        } else if (d) {
            for (var P = t.texture, k = 0, L = P.length; k < L; k++) {
                var R = P[k]
                  , D = i.get(R);
                r.bindTexture(3553, D.__webglTexture),
                O(3553, R, p),
                B(l.__webglFramebuffer, t, R, 36064 + k, 3553),
                w(R, p) && M(3553)
            }
            r.unbindTexture()
        } else {
            var I = 3553;
            (t.isWebGL3DRenderTarget || t.isWebGLArrayRenderTarget) && (c ? I = t.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),
            r.bindTexture(I, u.__webglTexture),
            O(I, s, p),
            B(l.__webglFramebuffer, t, s, 36064, I),
            w(s, p) && M(I),
            r.unbindTexture()
        }
        t.depthBuffer && U(t)
    }
    ,
    this.updateRenderTargetMipmap = function(e) {
        for (var t = S(e) || c, n = !0 === e.isWebGLMultipleRenderTargets ? e.texture : [e.texture], a = 0, o = n.length; a < o; a++) {
            var s = n[a];
            if (w(s, t)) {
                var l = e.isWebGLCubeRenderTarget ? 34067 : 3553
                  , u = i.get(s).__webglTexture;
                r.bindTexture(l, u),
                M(l),
                r.unbindTexture()
            }
        }
    }
    ,
    this.updateMultisampleRenderTarget = function(t) {
        if (c && t.samples > 0 && !1 === G(t)) {
            var n = t.width
              , a = t.height
              , o = 16384
              , s = [36064]
              , l = t.stencilBuffer ? 33306 : 36096;
            t.depthBuffer && s.push(l);
            var u = i.get(t)
              , h = void 0 !== u.__ignoreDepthValues && u.__ignoreDepthValues;
            !1 === h && (t.depthBuffer && (o |= 256),
            t.stencilBuffer && (o |= 1024)),
            r.bindFramebuffer(36008, u.__webglMultisampledFramebuffer),
            r.bindFramebuffer(36009, u.__webglFramebuffer),
            !0 === h && (e.invalidateFramebuffer(36008, [l]),
            e.invalidateFramebuffer(36009, [l])),
            e.blitFramebuffer(0, 0, n, a, 0, 0, n, a, o, 9728),
            v && e.invalidateFramebuffer(36008, s),
            r.bindFramebuffer(36008, null),
            r.bindFramebuffer(36009, u.__webglMultisampledFramebuffer)
        }
    }
    ,
    this.setupDepthRenderbuffer = U,
    this.setupFrameBufferTexture = B,
    this.useMultisampledRTT = G
}
function WebGLUtils(e, t, r) {
    var i = r.isWebGL2;
    return {
        convert: function(e) {
            var r, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
            if (e === UnsignedByteType)
                return 5121;
            if (e === UnsignedShort4444Type)
                return 32819;
            if (e === UnsignedShort5551Type)
                return 32820;
            if (e === ByteType)
                return 5120;
            if (e === ShortType)
                return 5122;
            if (e === UnsignedShortType)
                return 5123;
            if (e === IntType)
                return 5124;
            if (e === UnsignedIntType)
                return 5125;
            if (e === FloatType)
                return 5126;
            if (e === HalfFloatType)
                return i ? 5131 : null !== (r = t.get("OES_texture_half_float")) ? r.HALF_FLOAT_OES : null;
            if (e === AlphaFormat)
                return 6406;
            if (e === RGBAFormat)
                return 6408;
            if (e === LuminanceFormat)
                return 6409;
            if (e === LuminanceAlphaFormat)
                return 6410;
            if (e === DepthFormat)
                return 6402;
            if (e === DepthStencilFormat)
                return 34041;
            if (e === RedFormat)
                return 6403;
            if (e === RGBFormat)
                return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"),
                6408;
            if (e === _SRGBAFormat)
                return null !== (r = t.get("EXT_sRGB")) ? r.SRGB_ALPHA_EXT : null;
            if (e === RedIntegerFormat)
                return 36244;
            if (e === RGFormat)
                return 33319;
            if (e === RGIntegerFormat)
                return 33320;
            if (e === RGBAIntegerFormat)
                return 36249;
            if (e === RGB_S3TC_DXT1_Format || e === RGBA_S3TC_DXT1_Format || e === RGBA_S3TC_DXT3_Format || e === RGBA_S3TC_DXT5_Format)
                if (n === sRGBEncoding) {
                    if (null === (r = t.get("WEBGL_compressed_texture_s3tc_srgb")))
                        return null;
                    if (e === RGB_S3TC_DXT1_Format)
                        return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    if (e === RGBA_S3TC_DXT1_Format)
                        return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    if (e === RGBA_S3TC_DXT3_Format)
                        return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    if (e === RGBA_S3TC_DXT5_Format)
                        return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                } else {
                    if (null === (r = t.get("WEBGL_compressed_texture_s3tc")))
                        return null;
                    if (e === RGB_S3TC_DXT1_Format)
                        return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (e === RGBA_S3TC_DXT1_Format)
                        return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (e === RGBA_S3TC_DXT3_Format)
                        return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (e === RGBA_S3TC_DXT5_Format)
                        return r.COMPRESSED_RGBA_S3TC_DXT5_EXT
                }
            if (e === RGB_PVRTC_4BPPV1_Format || e === RGB_PVRTC_2BPPV1_Format || e === RGBA_PVRTC_4BPPV1_Format || e === RGBA_PVRTC_2BPPV1_Format) {
                if (null === (r = t.get("WEBGL_compressed_texture_pvrtc")))
                    return null;
                if (e === RGB_PVRTC_4BPPV1_Format)
                    return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (e === RGB_PVRTC_2BPPV1_Format)
                    return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (e === RGBA_PVRTC_4BPPV1_Format)
                    return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (e === RGBA_PVRTC_2BPPV1_Format)
                    return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            }
            if (e === RGB_ETC1_Format)
                return null !== (r = t.get("WEBGL_compressed_texture_etc1")) ? r.COMPRESSED_RGB_ETC1_WEBGL : null;
            if (e === RGB_ETC2_Format || e === RGBA_ETC2_EAC_Format) {
                if (null === (r = t.get("WEBGL_compressed_texture_etc")))
                    return null;
                if (e === RGB_ETC2_Format)
                    return n === sRGBEncoding ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
                if (e === RGBA_ETC2_EAC_Format)
                    return n === sRGBEncoding ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC
            }
            if (e === RGBA_ASTC_4x4_Format || e === RGBA_ASTC_5x4_Format || e === RGBA_ASTC_5x5_Format || e === RGBA_ASTC_6x5_Format || e === RGBA_ASTC_6x6_Format || e === RGBA_ASTC_8x5_Format || e === RGBA_ASTC_8x6_Format || e === RGBA_ASTC_8x8_Format || e === RGBA_ASTC_10x5_Format || e === RGBA_ASTC_10x6_Format || e === RGBA_ASTC_10x8_Format || e === RGBA_ASTC_10x10_Format || e === RGBA_ASTC_12x10_Format || e === RGBA_ASTC_12x12_Format) {
                if (null === (r = t.get("WEBGL_compressed_texture_astc")))
                    return null;
                if (e === RGBA_ASTC_4x4_Format)
                    return n === sRGBEncoding ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (e === RGBA_ASTC_5x4_Format)
                    return n === sRGBEncoding ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (e === RGBA_ASTC_5x5_Format)
                    return n === sRGBEncoding ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (e === RGBA_ASTC_6x5_Format)
                    return n === sRGBEncoding ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (e === RGBA_ASTC_6x6_Format)
                    return n === sRGBEncoding ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (e === RGBA_ASTC_8x5_Format)
                    return n === sRGBEncoding ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (e === RGBA_ASTC_8x6_Format)
                    return n === sRGBEncoding ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (e === RGBA_ASTC_8x8_Format)
                    return n === sRGBEncoding ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (e === RGBA_ASTC_10x5_Format)
                    return n === sRGBEncoding ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (e === RGBA_ASTC_10x6_Format)
                    return n === sRGBEncoding ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (e === RGBA_ASTC_10x8_Format)
                    return n === sRGBEncoding ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (e === RGBA_ASTC_10x10_Format)
                    return n === sRGBEncoding ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (e === RGBA_ASTC_12x10_Format)
                    return n === sRGBEncoding ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (e === RGBA_ASTC_12x12_Format)
                    return n === sRGBEncoding ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR
            }
            if (e === RGBA_BPTC_Format) {
                if (null === (r = t.get("EXT_texture_compression_bptc")))
                    return null;
                if (e === RGBA_BPTC_Format)
                    return n === sRGBEncoding ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT
            }
            return e === UnsignedInt248Type ? i ? 34042 : null !== (r = t.get("WEBGL_depth_texture")) ? r.UNSIGNED_INT_24_8_WEBGL : null : void 0
        }
    }
}
var ArrayCamera = function(e) {
    _inherits(r, PerspectiveCamera);
    var t = _createSuper(r);
    function r() {
        var e, i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
        return _classCallCheck(this, r),
        (e = t.call(this)).cameras = i,
        e
    }
    return _createClass(r)
}();
ArrayCamera.prototype.isArrayCamera = !0;
var Group = function(e) {
    _inherits(r, Object3D);
    var t = _createSuper(r);
    function r() {
        var e;
        return _classCallCheck(this, r),
        (e = t.call(this)).type = "Group",
        e
    }
    return _createClass(r)
}();
Group.prototype.isGroup = !0;
var _moveEvent = {
    type: "move"
}
  , WebXRController = function() {
    function e() {
        _classCallCheck(this, e),
        this._targetRay = null,
        this._grip = null,
        this._hand = null
    }
    return _createClass(e, [{
        key: "getHandSpace",
        value: function() {
            return null === this._hand && (this._hand = new Group,
            this._hand.matrixAutoUpdate = !1,
            this._hand.visible = !1,
            this._hand.joints = {},
            this._hand.inputState = {
                pinching: !1
            }),
            this._hand
        }
    }, {
        key: "getTargetRaySpace",
        value: function() {
            return null === this._targetRay && (this._targetRay = new Group,
            this._targetRay.matrixAutoUpdate = !1,
            this._targetRay.visible = !1,
            this._targetRay.hasLinearVelocity = !1,
            this._targetRay.linearVelocity = new Vector3,
            this._targetRay.hasAngularVelocity = !1,
            this._targetRay.angularVelocity = new Vector3),
            this._targetRay
        }
    }, {
        key: "getGripSpace",
        value: function() {
            return null === this._grip && (this._grip = new Group,
            this._grip.matrixAutoUpdate = !1,
            this._grip.visible = !1,
            this._grip.hasLinearVelocity = !1,
            this._grip.linearVelocity = new Vector3,
            this._grip.hasAngularVelocity = !1,
            this._grip.angularVelocity = new Vector3),
            this._grip
        }
    }, {
        key: "dispatchEvent",
        value: function(e) {
            return null !== this._targetRay && this._targetRay.dispatchEvent(e),
            null !== this._grip && this._grip.dispatchEvent(e),
            null !== this._hand && this._hand.dispatchEvent(e),
            this
        }
    }, {
        key: "disconnect",
        value: function(e) {
            return this.dispatchEvent({
                type: "disconnected",
                data: e
            }),
            null !== this._targetRay && (this._targetRay.visible = !1),
            null !== this._grip && (this._grip.visible = !1),
            null !== this._hand && (this._hand.visible = !1),
            this
        }
    }, {
        key: "update",
        value: function(e, t, r) {
            var i = null
              , n = null
              , a = null
              , o = this._targetRay
              , s = this._grip
              , l = this._hand;
            if (e && "visible-blurred" !== t.session.visibilityState)
                if (null !== o && null !== (i = t.getPose(e.targetRaySpace, r)) && (o.matrix.fromArray(i.transform.matrix),
                o.matrix.decompose(o.position, o.rotation, o.scale),
                i.linearVelocity ? (o.hasLinearVelocity = !0,
                o.linearVelocity.copy(i.linearVelocity)) : o.hasLinearVelocity = !1,
                i.angularVelocity ? (o.hasAngularVelocity = !0,
                o.angularVelocity.copy(i.angularVelocity)) : o.hasAngularVelocity = !1,
                this.dispatchEvent(_moveEvent)),
                l && e.hand) {
                    a = !0;
                    var u, c = _createForOfIteratorHelper(e.hand.values());
                    try {
                        for (c.s(); !(u = c.n()).done; ) {
                            var h = u.value
                              , d = t.getJointPose(h, r);
                            if (void 0 === l.joints[h.jointName]) {
                                var p = new Group;
                                p.matrixAutoUpdate = !1,
                                p.visible = !1,
                                l.joints[h.jointName] = p,
                                l.add(p)
                            }
                            var f = l.joints[h.jointName];
                            null !== d && (f.matrix.fromArray(d.transform.matrix),
                            f.matrix.decompose(f.position, f.rotation, f.scale),
                            f.jointRadius = d.radius),
                            f.visible = null !== d
                        }
                    } catch (_) {
                        c.e(_)
                    } finally {
                        c.f()
                    }
                    var m = l.joints["index-finger-tip"]
                      , v = l.joints["thumb-tip"]
                      , g = m.position.distanceTo(v.position);
                    l.inputState.pinching && g > .025 ? (l.inputState.pinching = !1,
                    this.dispatchEvent({
                        type: "pinchend",
                        handedness: e.handedness,
                        target: this
                    })) : !l.inputState.pinching && g <= .015 && (l.inputState.pinching = !0,
                    this.dispatchEvent({
                        type: "pinchstart",
                        handedness: e.handedness,
                        target: this
                    }))
                } else
                    null !== s && e.gripSpace && null !== (n = t.getPose(e.gripSpace, r)) && (s.matrix.fromArray(n.transform.matrix),
                    s.matrix.decompose(s.position, s.rotation, s.scale),
                    n.linearVelocity ? (s.hasLinearVelocity = !0,
                    s.linearVelocity.copy(n.linearVelocity)) : s.hasLinearVelocity = !1,
                    n.angularVelocity ? (s.hasAngularVelocity = !0,
                    s.angularVelocity.copy(n.angularVelocity)) : s.hasAngularVelocity = !1);
            return null !== o && (o.visible = null !== i),
            null !== s && (s.visible = null !== n),
            null !== l && (l.visible = null !== a),
            this
        }
    }]),
    e
}()
  , DepthTexture = function(e) {
    _inherits(r, Texture);
    var t = _createSuper(r);
    function r(e, i, n, a, o, s, l, u, c, h) {
        var d;
        if (_classCallCheck(this, r),
        (h = void 0 !== h ? h : DepthFormat) !== DepthFormat && h !== DepthStencilFormat)
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        return void 0 === n && h === DepthFormat && (n = UnsignedShortType),
        void 0 === n && h === DepthStencilFormat && (n = UnsignedInt248Type),
        (d = t.call(this, null, a, o, s, l, u, h, n, c)).image = {
            width: e,
            height: i
        },
        d.magFilter = void 0 !== l ? l : NearestFilter,
        d.minFilter = void 0 !== u ? u : NearestFilter,
        d.flipY = !1,
        d.generateMipmaps = !1,
        d
    }
    return _createClass(r)
}();
DepthTexture.prototype.isDepthTexture = !0;
var WebXRManager = function(e) {
    _inherits(r, EventDispatcher);
    var t = _createSuper(r);
    function r(e, i) {
        var n;
        _classCallCheck(this, r);
        var a = _assertThisInitialized(n = t.call(this))
          , o = null
          , s = 1
          , l = null
          , u = "local-floor"
          , c = null
          , h = null
          , d = null
          , p = null
          , f = null
          , m = i.getContextAttributes()
          , v = null
          , g = null
          , _ = []
          , y = new Map
          , x = new PerspectiveCamera;
        x.layers.enable(1),
        x.viewport = new Vector4;
        var b = new PerspectiveCamera;
        b.layers.enable(2),
        b.viewport = new Vector4;
        var S = [x, b]
          , w = new ArrayCamera;
        w.layers.enable(1),
        w.layers.enable(2);
        var M = null
          , T = null;
        function C(e) {
            var t = y.get(e.inputSource);
            t && t.dispatchEvent({
                type: e.type,
                data: e.inputSource
            })
        }
        function E() {
            y.forEach((function(e, t) {
                e.disconnect(t)
            }
            )),
            y.clear(),
            M = null,
            T = null,
            e.setRenderTarget(v),
            p = null,
            d = null,
            h = null,
            o = null,
            g = null,
            D.stop(),
            a.isPresenting = !1,
            a.dispatchEvent({
                type: "sessionend"
            })
        }
        function P(e) {
            for (var t = o.inputSources, r = 0; r < _.length; r++)
                y.set(t[r], _[r]);
            for (var i = 0; i < e.removed.length; i++) {
                var n = e.removed[i]
                  , a = y.get(n);
                a && (a.dispatchEvent({
                    type: "disconnected",
                    data: n
                }),
                y.delete(n))
            }
            for (var s = 0; s < e.added.length; s++) {
                var l = e.added[s]
                  , u = y.get(l);
                u && u.dispatchEvent({
                    type: "connected",
                    data: l
                })
            }
        }
        n.cameraAutoUpdate = !0,
        n.enabled = !1,
        n.isPresenting = !1,
        n.getController = function(e) {
            var t = _[e];
            return void 0 === t && (t = new WebXRController,
            _[e] = t),
            t.getTargetRaySpace()
        }
        ,
        n.getControllerGrip = function(e) {
            var t = _[e];
            return void 0 === t && (t = new WebXRController,
            _[e] = t),
            t.getGripSpace()
        }
        ,
        n.getHand = function(e) {
            var t = _[e];
            return void 0 === t && (t = new WebXRController,
            _[e] = t),
            t.getHandSpace()
        }
        ,
        n.setFramebufferScaleFactor = function(e) {
            s = e,
            !0 === a.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
        }
        ,
        n.setReferenceSpaceType = function(e) {
            u = e,
            !0 === a.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
        }
        ,
        n.getReferenceSpace = function() {
            return l
        }
        ,
        n.getBaseLayer = function() {
            return null !== d ? d : p
        }
        ,
        n.getBinding = function() {
            return h
        }
        ,
        n.getFrame = function() {
            return f
        }
        ,
        n.getSession = function() {
            return o
        }
        ,
        n.setSession = function() {
            var t = _asyncToGenerator(_regeneratorRuntime().mark((function t(r) {
                var n, c, f, _, y;
                return _regeneratorRuntime().wrap((function(t) {
                    for (; ; )
                        switch (t.prev = t.next) {
                        case 0:
                            if (null === (o = r)) {
                                t.next = 24;
                                break
                            }
                            if (v = e.getRenderTarget(),
                            o.addEventListener("select", C),
                            o.addEventListener("selectstart", C),
                            o.addEventListener("selectend", C),
                            o.addEventListener("squeeze", C),
                            o.addEventListener("squeezestart", C),
                            o.addEventListener("squeezeend", C),
                            o.addEventListener("end", E),
                            o.addEventListener("inputsourceschange", P),
                            !0 === m.xrCompatible) {
                                t.next = 14;
                                break
                            }
                            return t.next = 14,
                            i.makeXRCompatible();
                        case 14:
                            return void 0 === o.renderState.layers || !1 === e.capabilities.isWebGL2 ? (n = {
                                antialias: void 0 !== o.renderState.layers || m.antialias,
                                alpha: m.alpha,
                                depth: m.depth,
                                stencil: m.stencil,
                                framebufferScaleFactor: s
                            },
                            p = new XRWebGLLayer(o,i,n),
                            o.updateRenderState({
                                baseLayer: p
                            }),
                            g = new WebGLRenderTarget(p.framebufferWidth,p.framebufferHeight,{
                                format: RGBAFormat,
                                type: UnsignedByteType,
                                encoding: e.outputEncoding
                            })) : (c = null,
                            f = null,
                            _ = null,
                            m.depth && (_ = m.stencil ? 35056 : 33190,
                            c = m.stencil ? DepthStencilFormat : DepthFormat,
                            f = m.stencil ? UnsignedInt248Type : UnsignedShortType),
                            y = {
                                colorFormat: e.outputEncoding === sRGBEncoding ? 35907 : 32856,
                                depthFormat: _,
                                scaleFactor: s
                            },
                            h = new XRWebGLBinding(o,i),
                            d = h.createProjectionLayer(y),
                            o.updateRenderState({
                                layers: [d]
                            }),
                            g = new WebGLRenderTarget(d.textureWidth,d.textureHeight,{
                                format: RGBAFormat,
                                type: UnsignedByteType,
                                depthTexture: new DepthTexture(d.textureWidth,d.textureHeight,f,void 0,void 0,void 0,void 0,void 0,void 0,c),
                                stencilBuffer: m.stencil,
                                encoding: e.outputEncoding,
                                samples: m.antialias ? 4 : 0
                            }),
                            e.properties.get(g).__ignoreDepthValues = d.ignoreDepthValues),
                            g.isXRRenderTarget = !0,
                            this.setFoveation(1),
                            t.next = 19,
                            o.requestReferenceSpace(u);
                        case 19:
                            l = t.sent,
                            D.setContext(o),
                            D.start(),
                            a.isPresenting = !0,
                            a.dispatchEvent({
                                type: "sessionstart"
                            });
                        case 24:
                        case "end":
                            return t.stop()
                        }
                }
                ), t, this)
            }
            )));
            return function(e) {
                return t.apply(this, arguments)
            }
        }();
        var A = new Vector3
          , k = new Vector3;
        function L(e, t) {
            null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix),
            e.matrixWorldInverse.copy(e.matrixWorld).invert()
        }
        n.updateCamera = function(e) {
            if (null !== o) {
                w.near = b.near = x.near = e.near,
                w.far = b.far = x.far = e.far,
                M === w.near && T === w.far || (o.updateRenderState({
                    depthNear: w.near,
                    depthFar: w.far
                }),
                M = w.near,
                T = w.far);
                var t = e.parent
                  , r = w.cameras;
                L(w, t);
                for (var i = 0; i < r.length; i++)
                    L(r[i], t);
                w.matrixWorld.decompose(w.position, w.quaternion, w.scale),
                e.position.copy(w.position),
                e.quaternion.copy(w.quaternion),
                e.scale.copy(w.scale),
                e.matrix.copy(w.matrix),
                e.matrixWorld.copy(w.matrixWorld);
                for (var n = e.children, a = 0, s = n.length; a < s; a++)
                    n[a].updateMatrixWorld(!0);
                2 === r.length ? function(e, t, r) {
                    A.setFromMatrixPosition(t.matrixWorld),
                    k.setFromMatrixPosition(r.matrixWorld);
                    var i = A.distanceTo(k)
                      , n = t.projectionMatrix.elements
                      , a = r.projectionMatrix.elements
                      , o = n[14] / (n[10] - 1)
                      , s = n[14] / (n[10] + 1)
                      , l = (n[9] + 1) / n[5]
                      , u = (n[9] - 1) / n[5]
                      , c = (n[8] - 1) / n[0]
                      , h = (a[8] + 1) / a[0]
                      , d = o * c
                      , p = o * h
                      , f = i / (-c + h)
                      , m = f * -c;
                    t.matrixWorld.decompose(e.position, e.quaternion, e.scale),
                    e.translateX(m),
                    e.translateZ(f),
                    e.matrixWorld.compose(e.position, e.quaternion, e.scale),
                    e.matrixWorldInverse.copy(e.matrixWorld).invert();
                    var v = o + f
                      , g = s + f
                      , _ = d - m
                      , y = p + (i - m)
                      , x = l * s / g * v
                      , b = u * s / g * v;
                    e.projectionMatrix.makePerspective(_, y, x, b, v, g)
                }(w, x, b) : w.projectionMatrix.copy(x.projectionMatrix)
            }
        }
        ,
        n.getCamera = function() {
            return w
        }
        ,
        n.getFoveation = function() {
            return null !== d ? d.fixedFoveation : null !== p ? p.fixedFoveation : void 0
        }
        ,
        n.setFoveation = function(e) {
            null !== d && (d.fixedFoveation = e),
            null !== p && void 0 !== p.fixedFoveation && (p.fixedFoveation = e)
        }
        ;
        var R = null
          , D = new WebGLAnimation;
        return D.setAnimationLoop((function(t, r) {
            if (c = r.getViewerPose(l),
            f = r,
            null !== c) {
                var i = c.views;
                null !== p && (e.setRenderTargetFramebuffer(g, p.framebuffer),
                e.setRenderTarget(g));
                var n = !1;
                i.length !== w.cameras.length && (w.cameras.length = 0,
                n = !0);
                for (var a = 0; a < i.length; a++) {
                    var s = i[a]
                      , u = null;
                    if (null !== p)
                        u = p.getViewport(s);
                    else {
                        var m = h.getViewSubImage(d, s);
                        u = m.viewport,
                        0 === a && (e.setRenderTargetTextures(g, m.colorTexture, d.ignoreDepthValues ? void 0 : m.depthStencilTexture),
                        e.setRenderTarget(g))
                    }
                    var v = S[a];
                    v.matrix.fromArray(s.transform.matrix),
                    v.projectionMatrix.fromArray(s.projectionMatrix),
                    v.viewport.set(u.x, u.y, u.width, u.height),
                    0 === a && w.matrix.copy(v.matrix),
                    !0 === n && w.cameras.push(v)
                }
            }
            for (var y = o.inputSources, x = 0; x < _.length; x++) {
                var b = _[x]
                  , M = y[x];
                b.update(M, r, l)
            }
            R && R(t, r),
            f = null
        }
        )),
        n.setAnimationLoop = function(e) {
            R = e
        }
        ,
        n.dispose = function() {}
        ,
        n
    }
    return _createClass(r)
}();
function WebGLMaterials(e, t) {
    function r(r, i) {
        r.opacity.value = i.opacity,
        i.color && r.diffuse.value.copy(i.color),
        i.emissive && r.emissive.value.copy(i.emissive).multiplyScalar(i.emissiveIntensity),
        i.map && (r.map.value = i.map),
        i.alphaMap && (r.alphaMap.value = i.alphaMap),
        i.bumpMap && (r.bumpMap.value = i.bumpMap,
        r.bumpScale.value = i.bumpScale,
        i.side === BackSide && (r.bumpScale.value *= -1)),
        i.displacementMap && (r.displacementMap.value = i.displacementMap,
        r.displacementScale.value = i.displacementScale,
        r.displacementBias.value = i.displacementBias),
        i.emissiveMap && (r.emissiveMap.value = i.emissiveMap),
        i.normalMap && (r.normalMap.value = i.normalMap,
        r.normalScale.value.copy(i.normalScale),
        i.side === BackSide && r.normalScale.value.negate()),
        i.specularMap && (r.specularMap.value = i.specularMap),
        i.alphaTest > 0 && (r.alphaTest.value = i.alphaTest);
        var n, a, o = t.get(i).envMap;
        if (o && (r.envMap.value = o,
        r.flipEnvMap.value = o.isCubeTexture && !1 === o.isRenderTargetTexture ? -1 : 1,
        r.reflectivity.value = i.reflectivity,
        r.ior.value = i.ior,
        r.refractionRatio.value = i.refractionRatio),
        i.lightMap) {
            r.lightMap.value = i.lightMap;
            var s = !0 !== e.physicallyCorrectLights ? Math.PI : 1;
            r.lightMapIntensity.value = i.lightMapIntensity * s
        }
        i.aoMap && (r.aoMap.value = i.aoMap,
        r.aoMapIntensity.value = i.aoMapIntensity),
        i.map ? n = i.map : i.specularMap ? n = i.specularMap : i.displacementMap ? n = i.displacementMap : i.normalMap ? n = i.normalMap : i.bumpMap ? n = i.bumpMap : i.roughnessMap ? n = i.roughnessMap : i.metalnessMap ? n = i.metalnessMap : i.alphaMap ? n = i.alphaMap : i.emissiveMap ? n = i.emissiveMap : i.clearcoatMap ? n = i.clearcoatMap : i.clearcoatNormalMap ? n = i.clearcoatNormalMap : i.clearcoatRoughnessMap ? n = i.clearcoatRoughnessMap : i.specularIntensityMap ? n = i.specularIntensityMap : i.specularColorMap ? n = i.specularColorMap : i.transmissionMap ? n = i.transmissionMap : i.thicknessMap ? n = i.thicknessMap : i.sheenColorMap ? n = i.sheenColorMap : i.sheenRoughnessMap && (n = i.sheenRoughnessMap),
        void 0 !== n && (n.isWebGLRenderTarget && (n = n.texture),
        !0 === n.matrixAutoUpdate && n.updateMatrix(),
        r.uvTransform.value.copy(n.matrix)),
        i.aoMap ? a = i.aoMap : i.lightMap && (a = i.lightMap),
        void 0 !== a && (a.isWebGLRenderTarget && (a = a.texture),
        !0 === a.matrixAutoUpdate && a.updateMatrix(),
        r.uv2Transform.value.copy(a.matrix))
    }
    return {
        refreshFogUniforms: function(e, t) {
            e.fogColor.value.copy(t.color),
            t.isFog ? (e.fogNear.value = t.near,
            e.fogFar.value = t.far) : t.isFogExp2 && (e.fogDensity.value = t.density)
        },
        refreshMaterialUniforms: function(e, i, n, a, o) {
            i.isMeshBasicMaterial || i.isMeshLambertMaterial ? r(e, i) : i.isMeshToonMaterial ? (r(e, i),
            function(e, t) {
                t.gradientMap && (e.gradientMap.value = t.gradientMap)
            }(e, i)) : i.isMeshPhongMaterial ? (r(e, i),
            function(e, t) {
                e.specular.value.copy(t.specular),
                e.shininess.value = Math.max(t.shininess, 1e-4)
            }(e, i)) : i.isMeshStandardMaterial ? (r(e, i),
            function(e, r) {
                e.roughness.value = r.roughness,
                e.metalness.value = r.metalness,
                r.roughnessMap && (e.roughnessMap.value = r.roughnessMap),
                r.metalnessMap && (e.metalnessMap.value = r.metalnessMap),
                t.get(r).envMap && (e.envMapIntensity.value = r.envMapIntensity)
            }(e, i),
            i.isMeshPhysicalMaterial && function(e, t, r) {
                e.ior.value = t.ior,
                t.sheen > 0 && (e.sheenColor.value.copy(t.sheenColor).multiplyScalar(t.sheen),
                e.sheenRoughness.value = t.sheenRoughness,
                t.sheenColorMap && (e.sheenColorMap.value = t.sheenColorMap),
                t.sheenRoughnessMap && (e.sheenRoughnessMap.value = t.sheenRoughnessMap)),
                t.clearcoat > 0 && (e.clearcoat.value = t.clearcoat,
                e.clearcoatRoughness.value = t.clearcoatRoughness,
                t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap),
                t.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap),
                t.clearcoatNormalMap && (e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale),
                e.clearcoatNormalMap.value = t.clearcoatNormalMap,
                t.side === BackSide && e.clearcoatNormalScale.value.negate())),
                t.transmission > 0 && (e.transmission.value = t.transmission,
                e.transmissionSamplerMap.value = r.texture,
                e.transmissionSamplerSize.value.set(r.width, r.height),
                t.transmissionMap && (e.transmissionMap.value = t.transmissionMap),
                e.thickness.value = t.thickness,
                t.thicknessMap && (e.thicknessMap.value = t.thicknessMap),
                e.attenuationDistance.value = t.attenuationDistance,
                e.attenuationColor.value.copy(t.attenuationColor)),
                e.specularIntensity.value = t.specularIntensity,
                e.specularColor.value.copy(t.specularColor),
                t.specularIntensityMap && (e.specularIntensityMap.value = t.specularIntensityMap),
                t.specularColorMap && (e.specularColorMap.value = t.specularColorMap)
            }(e, i, o)) : i.isMeshMatcapMaterial ? (r(e, i),
            function(e, t) {
                t.matcap && (e.matcap.value = t.matcap)
            }(e, i)) : i.isMeshDepthMaterial ? r(e, i) : i.isMeshDistanceMaterial ? (r(e, i),
            function(e, t) {
                e.referencePosition.value.copy(t.referencePosition),
                e.nearDistance.value = t.nearDistance,
                e.farDistance.value = t.farDistance
            }(e, i)) : i.isMeshNormalMaterial ? r(e, i) : i.isLineBasicMaterial ? (function(e, t) {
                e.diffuse.value.copy(t.color),
                e.opacity.value = t.opacity
            }(e, i),
            i.isLineDashedMaterial && function(e, t) {
                e.dashSize.value = t.dashSize,
                e.totalSize.value = t.dashSize + t.gapSize,
                e.scale.value = t.scale
            }(e, i)) : i.isPointsMaterial ? function(e, t, r, i) {
                var n;
                e.diffuse.value.copy(t.color),
                e.opacity.value = t.opacity,
                e.size.value = t.size * r,
                e.scale.value = .5 * i,
                t.map && (e.map.value = t.map),
                t.alphaMap && (e.alphaMap.value = t.alphaMap),
                t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest),
                t.map ? n = t.map : t.alphaMap && (n = t.alphaMap),
                void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(),
                e.uvTransform.value.copy(n.matrix))
            }(e, i, n, a) : i.isSpriteMaterial ? function(e, t) {
                var r;
                e.diffuse.value.copy(t.color),
                e.opacity.value = t.opacity,
                e.rotation.value = t.rotation,
                t.map && (e.map.value = t.map),
                t.alphaMap && (e.alphaMap.value = t.alphaMap),
                t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest),
                t.map ? r = t.map : t.alphaMap && (r = t.alphaMap),
                void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(),
                e.uvTransform.value.copy(r.matrix))
            }(e, i) : i.isShadowMaterial ? (e.color.value.copy(i.color),
            e.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = !1)
        }
    }
}
function createCanvasElement() {
    var e = createElementNS("canvas");
    return e.style.display = "block",
    e
}
function WebGLRenderer() {
    var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r = void 0 !== t.canvas ? t.canvas : createCanvasElement(), i = void 0 !== t.context ? t.context : null, n = void 0 === t.depth || t.depth, a = void 0 === t.stencil || t.stencil, o = void 0 !== t.antialias && t.antialias, s = void 0 === t.premultipliedAlpha || t.premultipliedAlpha, l = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer, u = void 0 !== t.powerPreference ? t.powerPreference : "default", c = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat;
    e = void 0 !== t.context ? i.getContextAttributes().alpha : void 0 !== t.alpha && t.alpha;
    var h = null
      , d = null
      , p = []
      , f = [];
    this.domElement = r,
    this.debug = {
        checkShaderErrors: !0
    },
    this.autoClear = !0,
    this.autoClearColor = !0,
    this.autoClearDepth = !0,
    this.autoClearStencil = !0,
    this.sortObjects = !0,
    this.clippingPlanes = [],
    this.localClippingEnabled = !1,
    this.outputEncoding = LinearEncoding,
    this.physicallyCorrectLights = !1,
    this.toneMapping = NoToneMapping,
    this.toneMappingExposure = 1;
    var m = this
      , v = !1
      , g = 0
      , _ = 0
      , y = null
      , x = -1
      , b = null
      , S = new Vector4
      , w = new Vector4
      , M = null
      , T = r.width
      , C = r.height
      , E = 1
      , P = null
      , A = null
      , k = new Vector4(0,0,T,C)
      , L = new Vector4(0,0,T,C)
      , R = !1
      , D = new Frustum
      , I = !1
      , O = !1
      , N = null
      , F = new Matrix4
      , B = new Vector2
      , z = new Vector3
      , U = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0
    };
    function V() {
        return null === y ? E : 1
    }
    var G, H, W, $, j, q, X, Y, K, Z, J, Q, ee, te, re, ie, ne, ae, oe, se, le, ue, ce, he = i;
    function de(e, t) {
        for (var i = 0; i < e.length; i++) {
            var n = e[i]
              , a = r.getContext(n, t);
            if (null !== a)
                return a
        }
        return null
    }
    try {
        var pe = {
            alpha: !0,
            depth: n,
            stencil: a,
            antialias: o,
            premultipliedAlpha: s,
            preserveDrawingBuffer: l,
            powerPreference: u,
            failIfMajorPerformanceCaveat: c
        };
        if ("setAttribute"in r && r.setAttribute("data-engine", "three.js r".concat(REVISION)),
        r.addEventListener("webglcontextlost", ge, !1),
        r.addEventListener("webglcontextrestored", _e, !1),
        null === he) {
            var fe = ["webgl2", "webgl", "experimental-webgl"];
            if (!0 === m.isWebGL1Renderer && fe.shift(),
            null === (he = de(fe, pe)))
                throw de(fe) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
        }
        void 0 === he.getShaderPrecisionFormat && (he.getShaderPrecisionFormat = function() {
            return {
                rangeMin: 1,
                rangeMax: 1,
                precision: 1
            }
        }
        )
    } catch (Fe) {
        throw console.error("THREE.WebGLRenderer: " + Fe.message),
        Fe
    }
    function me() {
        G = new WebGLExtensions(he),
        H = new WebGLCapabilities(he,G,t),
        G.init(H),
        ue = new WebGLUtils(he,G,H),
        W = new WebGLState(he,G,H),
        $ = new WebGLInfo,
        j = new WebGLProperties,
        q = new WebGLTextures(he,G,W,j,H,ue,$),
        X = new WebGLCubeMaps(m),
        Y = new WebGLCubeUVMaps(m),
        K = new WebGLAttributes(he,H),
        ce = new WebGLBindingStates(he,G,K,H),
        Z = new WebGLGeometries(he,K,$,ce),
        J = new WebGLObjects(he,Z,K,$),
        oe = new WebGLMorphtargets(he,H,q),
        ie = new WebGLClipping(j),
        Q = new WebGLPrograms(m,X,Y,G,H,ce,ie),
        ee = new WebGLMaterials(m,j),
        te = new WebGLRenderLists,
        re = new WebGLRenderStates(G,H),
        ae = new WebGLBackground(m,X,W,J,e,s),
        ne = new WebGLShadowMap(m,J,H),
        se = new WebGLBufferRenderer(he,G,$,H),
        le = new WebGLIndexedBufferRenderer(he,G,$,H),
        $.programs = Q.programs,
        m.capabilities = H,
        m.extensions = G,
        m.properties = j,
        m.renderLists = te,
        m.shadowMap = ne,
        m.state = W,
        m.info = $
    }
    me();
    var ve = new WebXRManager(m,he);
    function ge(e) {
        e.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        v = !0
    }
    function _e() {
        console.log("THREE.WebGLRenderer: Context Restored."),
        v = !1;
        var e = $.autoReset
          , t = ne.enabled
          , r = ne.autoUpdate
          , i = ne.needsUpdate
          , n = ne.type;
        me(),
        $.autoReset = e,
        ne.enabled = t,
        ne.autoUpdate = r,
        ne.needsUpdate = i,
        ne.type = n
    }
    function ye(e) {
        var t = e.target;
        t.removeEventListener("dispose", ye),
        xe(t)
    }
    function xe(e) {
        be(e),
        j.remove(e)
    }
    function be(e) {
        var t = j.get(e).programs;
        void 0 !== t && (t.forEach((function(e) {
            Q.releaseProgram(e)
        }
        )),
        e.isShaderMaterial && Q.releaseShaderCache(e))
    }
    this.xr = ve,
    this.getContext = function() {
        return he
    }
    ,
    this.getContextAttributes = function() {
        return he.getContextAttributes()
    }
    ,
    this.forceContextLoss = function() {
        var e = G.get("WEBGL_lose_context");
        e && e.loseContext()
    }
    ,
    this.forceContextRestore = function() {
        var e = G.get("WEBGL_lose_context");
        e && e.restoreContext()
    }
    ,
    this.getPixelRatio = function() {
        return E
    }
    ,
    this.setPixelRatio = function(e) {
        void 0 !== e && (E = e,
        this.setSize(T, C, !1))
    }
    ,
    this.getSize = function(e) {
        return e.set(T, C)
    }
    ,
    this.setSize = function(e, t, i) {
        ve.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (T = e,
        C = t,
        r.width = Math.floor(e * E),
        r.height = Math.floor(t * E),
        !1 !== i && (r.style.width = e + "px",
        r.style.height = t + "px"),
        this.setViewport(0, 0, e, t))
    }
    ,
    this.getDrawingBufferSize = function(e) {
        return e.set(T * E, C * E).floor()
    }
    ,
    this.setDrawingBufferSize = function(e, t, i) {
        T = e,
        C = t,
        E = i,
        r.width = Math.floor(e * i),
        r.height = Math.floor(t * i),
        this.setViewport(0, 0, e, t)
    }
    ,
    this.getCurrentViewport = function(e) {
        return e.copy(S)
    }
    ,
    this.getViewport = function(e) {
        return e.copy(k)
    }
    ,
    this.setViewport = function(e, t, r, i) {
        e.isVector4 ? k.set(e.x, e.y, e.z, e.w) : k.set(e, t, r, i),
        W.viewport(S.copy(k).multiplyScalar(E).floor())
    }
    ,
    this.getScissor = function(e) {
        return e.copy(L)
    }
    ,
    this.setScissor = function(e, t, r, i) {
        e.isVector4 ? L.set(e.x, e.y, e.z, e.w) : L.set(e, t, r, i),
        W.scissor(w.copy(L).multiplyScalar(E).floor())
    }
    ,
    this.getScissorTest = function() {
        return R
    }
    ,
    this.setScissorTest = function(e) {
        W.setScissorTest(R = e)
    }
    ,
    this.setOpaqueSort = function(e) {
        P = e
    }
    ,
    this.setTransparentSort = function(e) {
        A = e
    }
    ,
    this.getClearColor = function(e) {
        return e.copy(ae.getClearColor())
    }
    ,
    this.setClearColor = function() {
        ae.setClearColor.apply(ae, arguments)
    }
    ,
    this.getClearAlpha = function() {
        return ae.getClearAlpha()
    }
    ,
    this.setClearAlpha = function() {
        ae.setClearAlpha.apply(ae, arguments)
    }
    ,
    this.clear = function() {
        var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]
          , t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]
          , r = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]
          , i = 0;
        e && (i |= 16384),
        t && (i |= 256),
        r && (i |= 1024),
        he.clear(i)
    }
    ,
    this.clearColor = function() {
        this.clear(!0, !1, !1)
    }
    ,
    this.clearDepth = function() {
        this.clear(!1, !0, !1)
    }
    ,
    this.clearStencil = function() {
        this.clear(!1, !1, !0)
    }
    ,
    this.dispose = function() {
        r.removeEventListener("webglcontextlost", ge, !1),
        r.removeEventListener("webglcontextrestored", _e, !1),
        te.dispose(),
        re.dispose(),
        j.dispose(),
        X.dispose(),
        Y.dispose(),
        J.dispose(),
        ce.dispose(),
        Q.dispose(),
        ve.dispose(),
        ve.removeEventListener("sessionstart", Me),
        ve.removeEventListener("sessionend", Te),
        N && (N.dispose(),
        N = null),
        Ce.stop()
    }
    ,
    this.renderBufferDirect = function(e, t, r, i, n, a) {
        null === t && (t = U);
        var o = n.isMesh && n.matrixWorld.determinant() < 0
          , s = Ie(e, t, r, i, n);
        W.setMaterial(i, o);
        var l = r.index
          , u = r.attributes.position;
        if (null === l) {
            if (void 0 === u || 0 === u.count)
                return
        } else if (0 === l.count)
            return;
        var c, h = 1;
        !0 === i.wireframe && (l = Z.getWireframeAttribute(r),
        h = 2),
        ce.setup(n, i, s, r, l);
        var d = se;
        null !== l && (c = K.get(l),
        (d = le).setIndex(c));
        var p = null !== l ? l.count : u.count
          , f = r.drawRange.start * h
          , m = r.drawRange.count * h
          , v = null !== a ? a.start * h : 0
          , g = null !== a ? a.count * h : 1 / 0
          , _ = Math.max(f, v)
          , y = Math.min(p, f + m, v + g) - 1
          , x = Math.max(0, y - _ + 1);
        if (0 !== x) {
            if (n.isMesh)
                !0 === i.wireframe ? (W.setLineWidth(i.wireframeLinewidth * V()),
                d.setMode(1)) : d.setMode(4);
            else if (n.isLine) {
                var b = i.linewidth;
                void 0 === b && (b = 1),
                W.setLineWidth(b * V()),
                n.isLineSegments ? d.setMode(1) : n.isLineLoop ? d.setMode(2) : d.setMode(3)
            } else
                n.isPoints ? d.setMode(0) : n.isSprite && d.setMode(4);
            if (n.isInstancedMesh)
                d.renderInstances(_, x, n.count);
            else if (r.isInstancedBufferGeometry) {
                var S = Math.min(r.instanceCount, r._maxInstanceCount);
                d.renderInstances(_, x, S)
            } else
                d.render(_, x)
        }
    }
    ,
    this.compile = function(e, t) {
        (d = re.get(e)).init(),
        f.push(d),
        e.traverseVisible((function(e) {
            e.isLight && e.layers.test(t.layers) && (d.pushLight(e),
            e.castShadow && d.pushShadow(e))
        }
        )),
        d.setupLights(m.physicallyCorrectLights),
        e.traverse((function(t) {
            var r = t.material;
            if (r)
                if (Array.isArray(r))
                    for (var i = 0; i < r.length; i++)
                        Re(r[i], e, t);
                else
                    Re(r, e, t)
        }
        )),
        f.pop(),
        d = null
    }
    ;
    var Se = null;
    function we(e) {
        Se && Se(e)
    }
    function Me() {
        Ce.stop()
    }
    function Te() {
        Ce.start()
    }
    var Ce = new WebGLAnimation;
    function Ee(e, t, r, i) {
        if (!1 !== e.visible) {
            if (e.layers.test(t.layers))
                if (e.isGroup)
                    r = e.renderOrder;
                else if (e.isLOD)
                    !0 === e.autoUpdate && e.update(t);
                else if (e.isLight)
                    d.pushLight(e),
                    e.castShadow && d.pushShadow(e);
                else if (e.isSprite) {
                    if (!e.frustumCulled || D.intersectsSprite(e)) {
                        i && z.setFromMatrixPosition(e.matrixWorld).applyMatrix4(F);
                        var n = J.update(e)
                          , a = e.material;
                        a.visible && h.push(e, n, a, r, z.z, null)
                    }
                } else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.frame !== $.render.frame && (e.skeleton.update(),
                e.skeleton.frame = $.render.frame),
                !e.frustumCulled || D.intersectsObject(e))) {
                    i && z.setFromMatrixPosition(e.matrixWorld).applyMatrix4(F);
                    var o = J.update(e)
                      , s = e.material;
                    if (Array.isArray(s))
                        for (var l = o.groups, u = 0, c = l.length; u < c; u++) {
                            var p = l[u]
                              , f = s[p.materialIndex];
                            f && f.visible && h.push(e, o, f, r, z.z, p)
                        }
                    else
                        s.visible && h.push(e, o, s, r, z.z, null)
                }
            for (var m = e.children, v = 0, g = m.length; v < g; v++)
                Ee(m[v], t, r, i)
        }
    }
    function Pe(e, t, r, i) {
        var n = e.opaque
          , a = e.transmissive
          , o = e.transparent;
        d.setupLightsView(r),
        a.length > 0 && Ae(n, t, r),
        i && W.viewport(S.copy(i)),
        n.length > 0 && ke(n, t, r),
        a.length > 0 && ke(a, t, r),
        o.length > 0 && ke(o, t, r),
        W.buffers.depth.setTest(!0),
        W.buffers.depth.setMask(!0),
        W.buffers.color.setMask(!0),
        W.setPolygonOffset(!1)
    }
    function Ae(e, t, r) {
        var i = H.isWebGL2;
        null === N && (N = new WebGLRenderTarget(1,1,{
            generateMipmaps: !0,
            type: null !== ue.convert(HalfFloatType) ? HalfFloatType : UnsignedByteType,
            minFilter: LinearMipmapLinearFilter,
            samples: i && !0 === o ? 4 : 0
        })),
        m.getDrawingBufferSize(B),
        i ? N.setSize(B.x, B.y) : N.setSize(floorPowerOfTwo(B.x), floorPowerOfTwo(B.y));
        var n = m.getRenderTarget();
        m.setRenderTarget(N),
        m.clear();
        var a = m.toneMapping;
        m.toneMapping = NoToneMapping,
        ke(e, t, r),
        m.toneMapping = a,
        q.updateMultisampleRenderTarget(N),
        q.updateRenderTargetMipmap(N),
        m.setRenderTarget(n)
    }
    function ke(e, t, r) {
        for (var i = !0 === t.isScene ? t.overrideMaterial : null, n = 0, a = e.length; n < a; n++) {
            var o = e[n]
              , s = o.object
              , l = o.geometry
              , u = null === i ? o.material : i
              , c = o.group;
            s.layers.test(r.layers) && Le(s, t, r, l, u, c)
        }
    }
    function Le(e, t, r, i, n, a) {
        e.onBeforeRender(m, t, r, i, n, a),
        e.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, e.matrixWorld),
        e.normalMatrix.getNormalMatrix(e.modelViewMatrix),
        n.onBeforeRender(m, t, r, i, e, a),
        !0 === n.transparent && n.side === DoubleSide ? (n.side = BackSide,
        n.needsUpdate = !0,
        m.renderBufferDirect(r, t, i, n, e, a),
        n.side = FrontSide,
        n.needsUpdate = !0,
        m.renderBufferDirect(r, t, i, n, e, a),
        n.side = DoubleSide) : m.renderBufferDirect(r, t, i, n, e, a),
        e.onAfterRender(m, t, r, i, n, a)
    }
    function Re(e, t, r) {
        !0 !== t.isScene && (t = U);
        var i = j.get(e)
          , n = d.state.lights
          , a = d.state.shadowsArray
          , o = n.state.version
          , s = Q.getParameters(e, n.state, a, t, r)
          , l = Q.getProgramCacheKey(s)
          , u = i.programs;
        i.environment = e.isMeshStandardMaterial ? t.environment : null,
        i.fog = t.fog,
        i.envMap = (e.isMeshStandardMaterial ? Y : X).get(e.envMap || i.environment),
        void 0 === u && (e.addEventListener("dispose", ye),
        u = new Map,
        i.programs = u);
        var c = u.get(l);
        if (void 0 !== c) {
            if (i.currentProgram === c && i.lightsStateVersion === o)
                return De(e, s),
                c
        } else
            s.uniforms = Q.getUniforms(e),
            e.onBuild(r, s, m),
            e.onBeforeCompile(s, m),
            c = Q.acquireProgram(s, l),
            u.set(l, c),
            i.uniforms = s.uniforms;
        var h = i.uniforms;
        (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (h.clippingPlanes = ie.uniform),
        De(e, s),
        i.needsLights = Ne(e),
        i.lightsStateVersion = o,
        i.needsLights && (h.ambientLightColor.value = n.state.ambient,
        h.lightProbe.value = n.state.probe,
        h.directionalLights.value = n.state.directional,
        h.directionalLightShadows.value = n.state.directionalShadow,
        h.spotLights.value = n.state.spot,
        h.spotLightShadows.value = n.state.spotShadow,
        h.rectAreaLights.value = n.state.rectArea,
        h.ltc_1.value = n.state.rectAreaLTC1,
        h.ltc_2.value = n.state.rectAreaLTC2,
        h.pointLights.value = n.state.point,
        h.pointLightShadows.value = n.state.pointShadow,
        h.hemisphereLights.value = n.state.hemi,
        h.directionalShadowMap.value = n.state.directionalShadowMap,
        h.directionalShadowMatrix.value = n.state.directionalShadowMatrix,
        h.spotShadowMap.value = n.state.spotShadowMap,
        h.spotShadowMatrix.value = n.state.spotShadowMatrix,
        h.pointShadowMap.value = n.state.pointShadowMap,
        h.pointShadowMatrix.value = n.state.pointShadowMatrix);
        var p = c.getUniforms()
          , f = WebGLUniforms.seqWithValue(p.seq, h);
        return i.currentProgram = c,
        i.uniformsList = f,
        c
    }
    function De(e, t) {
        var r = j.get(e);
        r.outputEncoding = t.outputEncoding,
        r.instancing = t.instancing,
        r.skinning = t.skinning,
        r.morphTargets = t.morphTargets,
        r.morphNormals = t.morphNormals,
        r.morphColors = t.morphColors,
        r.morphTargetsCount = t.morphTargetsCount,
        r.numClippingPlanes = t.numClippingPlanes,
        r.numIntersection = t.numClipIntersection,
        r.vertexAlphas = t.vertexAlphas,
        r.vertexTangents = t.vertexTangents,
        r.toneMapping = t.toneMapping
    }
    function Ie(e, t, r, i, n) {
        !0 !== t.isScene && (t = U),
        q.resetTextureUnits();
        var a = t.fog
          , o = i.isMeshStandardMaterial ? t.environment : null
          , s = null === y ? m.outputEncoding : !0 === y.isXRRenderTarget ? y.texture.encoding : LinearEncoding
          , l = (i.isMeshStandardMaterial ? Y : X).get(i.envMap || o)
          , u = !0 === i.vertexColors && !!r.attributes.color && 4 === r.attributes.color.itemSize
          , c = !!i.normalMap && !!r.attributes.tangent
          , h = !!r.morphAttributes.position
          , p = !!r.morphAttributes.normal
          , f = !!r.morphAttributes.color
          , v = i.toneMapped ? m.toneMapping : NoToneMapping
          , g = r.morphAttributes.position || r.morphAttributes.normal || r.morphAttributes.color
          , _ = void 0 !== g ? g.length : 0
          , S = j.get(i)
          , w = d.state.lights;
        if (!0 === I && (!0 === O || e !== b)) {
            var M = e === b && i.id === x;
            ie.setState(i, e, M)
        }
        var T = !1;
        i.version === S.__version ? S.needsLights && S.lightsStateVersion !== w.state.version || S.outputEncoding !== s || n.isInstancedMesh && !1 === S.instancing ? T = !0 : n.isInstancedMesh || !0 !== S.instancing ? n.isSkinnedMesh && !1 === S.skinning ? T = !0 : n.isSkinnedMesh || !0 !== S.skinning ? S.envMap !== l || i.fog && S.fog !== a ? T = !0 : void 0 === S.numClippingPlanes || S.numClippingPlanes === ie.numPlanes && S.numIntersection === ie.numIntersection ? (S.vertexAlphas !== u || S.vertexTangents !== c || S.morphTargets !== h || S.morphNormals !== p || S.morphColors !== f || S.toneMapping !== v || !0 === H.isWebGL2 && S.morphTargetsCount !== _) && (T = !0) : T = !0 : T = !0 : T = !0 : (T = !0,
        S.__version = i.version);
        var P = S.currentProgram;
        !0 === T && (P = Re(i, t, n));
        var A = !1
          , k = !1
          , L = !1
          , R = P.getUniforms()
          , D = S.uniforms;
        if (W.useProgram(P.program) && (A = !0,
        k = !0,
        L = !0),
        i.id !== x && (x = i.id,
        k = !0),
        A || b !== e) {
            if (R.setValue(he, "projectionMatrix", e.projectionMatrix),
            H.logarithmicDepthBuffer && R.setValue(he, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)),
            b !== e && (b = e,
            k = !0,
            L = !0),
            i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshStandardMaterial || i.envMap) {
                var F = R.map.cameraPosition;
                void 0 !== F && F.setValue(he, z.setFromMatrixPosition(e.matrixWorld))
            }
            (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && R.setValue(he, "isOrthographic", !0 === e.isOrthographicCamera),
            (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.isShadowMaterial || n.isSkinnedMesh) && R.setValue(he, "viewMatrix", e.matrixWorldInverse)
        }
        if (n.isSkinnedMesh) {
            R.setOptional(he, n, "bindMatrix"),
            R.setOptional(he, n, "bindMatrixInverse");
            var B = n.skeleton;
            B && (H.floatVertexTextures ? (null === B.boneTexture && B.computeBoneTexture(),
            R.setValue(he, "boneTexture", B.boneTexture, q),
            R.setValue(he, "boneTextureSize", B.boneTextureSize)) : R.setOptional(he, B, "boneMatrices"))
        }
        var V = r.morphAttributes;
        return (void 0 !== V.position || void 0 !== V.normal || void 0 !== V.color && !0 === H.isWebGL2) && oe.update(n, r, i, P),
        (k || S.receiveShadow !== n.receiveShadow) && (S.receiveShadow = n.receiveShadow,
        R.setValue(he, "receiveShadow", n.receiveShadow)),
        k && (R.setValue(he, "toneMappingExposure", m.toneMappingExposure),
        S.needsLights && Oe(D, L),
        a && i.fog && ee.refreshFogUniforms(D, a),
        ee.refreshMaterialUniforms(D, i, E, C, N),
        WebGLUniforms.upload(he, S.uniformsList, D, q)),
        i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (WebGLUniforms.upload(he, S.uniformsList, D, q),
        i.uniformsNeedUpdate = !1),
        i.isSpriteMaterial && R.setValue(he, "center", n.center),
        R.setValue(he, "modelViewMatrix", n.modelViewMatrix),
        R.setValue(he, "normalMatrix", n.normalMatrix),
        R.setValue(he, "modelMatrix", n.matrixWorld),
        P
    }
    function Oe(e, t) {
        e.ambientLightColor.needsUpdate = t,
        e.lightProbe.needsUpdate = t,
        e.directionalLights.needsUpdate = t,
        e.directionalLightShadows.needsUpdate = t,
        e.pointLights.needsUpdate = t,
        e.pointLightShadows.needsUpdate = t,
        e.spotLights.needsUpdate = t,
        e.spotLightShadows.needsUpdate = t,
        e.rectAreaLights.needsUpdate = t,
        e.hemisphereLights.needsUpdate = t
    }
    function Ne(e) {
        return e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights
    }
    Ce.setAnimationLoop(we),
    "undefined" != typeof self && Ce.setContext(self),
    this.setAnimationLoop = function(e) {
        Se = e,
        ve.setAnimationLoop(e),
        null === e ? Ce.stop() : Ce.start()
    }
    ,
    ve.addEventListener("sessionstart", Me),
    ve.addEventListener("sessionend", Te),
    this.render = function(e, t) {
        if (void 0 === t || !0 === t.isCamera) {
            if (!0 !== v) {
                !0 === e.autoUpdate && e.updateMatrixWorld(),
                null === t.parent && t.updateMatrixWorld(),
                !0 === ve.enabled && !0 === ve.isPresenting && (!0 === ve.cameraAutoUpdate && ve.updateCamera(t),
                t = ve.getCamera()),
                !0 === e.isScene && e.onBeforeRender(m, e, t, y),
                (d = re.get(e, f.length)).init(),
                f.push(d),
                F.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
                D.setFromProjectionMatrix(F),
                O = this.localClippingEnabled,
                I = ie.init(this.clippingPlanes, O, t),
                (h = te.get(e, p.length)).init(),
                p.push(h),
                Ee(e, t, 0, m.sortObjects),
                h.finish(),
                !0 === m.sortObjects && h.sort(P, A),
                !0 === I && ie.beginShadows();
                var r = d.state.shadowsArray;
                if (ne.render(r, e, t),
                !0 === I && ie.endShadows(),
                !0 === this.info.autoReset && this.info.reset(),
                ae.render(h, e),
                d.setupLights(m.physicallyCorrectLights),
                t.isArrayCamera)
                    for (var i = t.cameras, n = 0, a = i.length; n < a; n++) {
                        var o = i[n];
                        Pe(h, e, o, o.viewport)
                    }
                else
                    Pe(h, e, t);
                null !== y && (q.updateMultisampleRenderTarget(y),
                q.updateRenderTargetMipmap(y)),
                !0 === e.isScene && e.onAfterRender(m, e, t),
                ce.resetDefaultState(),
                x = -1,
                b = null,
                f.pop(),
                d = f.length > 0 ? f[f.length - 1] : null,
                p.pop(),
                h = p.length > 0 ? p[p.length - 1] : null
            }
        } else
            console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
    }
    ,
    this.getActiveCubeFace = function() {
        return g
    }
    ,
    this.getActiveMipmapLevel = function() {
        return _
    }
    ,
    this.getRenderTarget = function() {
        return y
    }
    ,
    this.setRenderTargetTextures = function(e, t, r) {
        j.get(e.texture).__webglTexture = t,
        j.get(e.depthTexture).__webglTexture = r;
        var i = j.get(e);
        i.__hasExternalTextures = !0,
        i.__hasExternalTextures && (i.__autoAllocateDepthBuffer = void 0 === r,
        i.__autoAllocateDepthBuffer || !0 === G.has("WEBGL_multisampled_render_to_texture") && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),
        i.__useRenderToTexture = !1))
    }
    ,
    this.setRenderTargetFramebuffer = function(e, t) {
        var r = j.get(e);
        r.__webglFramebuffer = t,
        r.__useDefaultFramebuffer = void 0 === t
    }
    ,
    this.setRenderTarget = function(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
          , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        y = e,
        g = t,
        _ = r;
        var i = !0;
        if (e) {
            var n = j.get(e);
            void 0 !== n.__useDefaultFramebuffer ? (W.bindFramebuffer(36160, null),
            i = !1) : void 0 === n.__webglFramebuffer ? q.setupRenderTarget(e) : n.__hasExternalTextures && q.rebindTextures(e, j.get(e.texture).__webglTexture, j.get(e.depthTexture).__webglTexture)
        }
        var a = null
          , o = !1
          , s = !1;
        if (e) {
            var l = e.texture;
            (l.isData3DTexture || l.isDataArrayTexture) && (s = !0);
            var u = j.get(e).__webglFramebuffer;
            e.isWebGLCubeRenderTarget ? (a = u[t],
            o = !0) : a = H.isWebGL2 && e.samples > 0 && !1 === q.useMultisampledRTT(e) ? j.get(e).__webglMultisampledFramebuffer : u,
            S.copy(e.viewport),
            w.copy(e.scissor),
            M = e.scissorTest
        } else
            S.copy(k).multiplyScalar(E).floor(),
            w.copy(L).multiplyScalar(E).floor(),
            M = R;
        var c = W.bindFramebuffer(36160, a);
        if (c && H.drawBuffers && i && W.drawBuffers(e, a),
        W.viewport(S),
        W.scissor(w),
        W.setScissorTest(M),
        o) {
            var h = j.get(e.texture);
            he.framebufferTexture2D(36160, 36064, 34069 + t, h.__webglTexture, r)
        } else if (s) {
            var d = j.get(e.texture)
              , p = t || 0;
            he.framebufferTextureLayer(36160, 36064, d.__webglTexture, r || 0, p)
        }
        x = -1
    }
    ,
    this.readRenderTargetPixels = function(e, t, r, i, n, a, o) {
        if (e && e.isWebGLRenderTarget) {
            var s = j.get(e).__webglFramebuffer;
            if (e.isWebGLCubeRenderTarget && void 0 !== o && (s = s[o]),
            s) {
                W.bindFramebuffer(36160, s);
                try {
                    var l = e.texture
                      , u = l.format
                      , c = l.type;
                    if (u !== RGBAFormat && ue.convert(u) !== he.getParameter(35739))
                        return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                    var h = c === HalfFloatType && (G.has("EXT_color_buffer_half_float") || H.isWebGL2 && G.has("EXT_color_buffer_float"));
                    if (!(c === UnsignedByteType || ue.convert(c) === he.getParameter(35738) || c === FloatType && (H.isWebGL2 || G.has("OES_texture_float") || G.has("WEBGL_color_buffer_float")) || h))
                        return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                    t >= 0 && t <= e.width - i && r >= 0 && r <= e.height - n && he.readPixels(t, r, i, n, ue.convert(u), ue.convert(c), a)
                } finally {
                    var d = null !== y ? j.get(y).__webglFramebuffer : null;
                    W.bindFramebuffer(36160, d)
                }
            }
        } else
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
    }
    ,
    this.copyFramebufferToTexture = function(e, t) {
        var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        if (!0 === t.isFramebufferTexture) {
            var i = Math.pow(2, -r)
              , n = Math.floor(t.image.width * i)
              , a = Math.floor(t.image.height * i);
            q.setTexture2D(t, 0),
            he.copyTexSubImage2D(3553, r, 0, 0, e.x, e.y, n, a),
            W.unbindTexture()
        } else
            console.error("THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.")
    }
    ,
    this.copyTextureToTexture = function(e, t, r) {
        var i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0
          , n = t.image.width
          , a = t.image.height
          , o = ue.convert(r.format)
          , s = ue.convert(r.type);
        q.setTexture2D(r, 0),
        he.pixelStorei(37440, r.flipY),
        he.pixelStorei(37441, r.premultiplyAlpha),
        he.pixelStorei(3317, r.unpackAlignment),
        t.isDataTexture ? he.texSubImage2D(3553, i, e.x, e.y, n, a, o, s, t.image.data) : t.isCompressedTexture ? he.compressedTexSubImage2D(3553, i, e.x, e.y, t.mipmaps[0].width, t.mipmaps[0].height, o, t.mipmaps[0].data) : he.texSubImage2D(3553, i, e.x, e.y, o, s, t.image),
        0 === i && r.generateMipmaps && he.generateMipmap(3553),
        W.unbindTexture()
    }
    ,
    this.copyTextureToTexture3D = function(e, t, r, i) {
        var n = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
        if (m.isWebGL1Renderer)
            console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
        else {
            var a, o = e.max.x - e.min.x + 1, s = e.max.y - e.min.y + 1, l = e.max.z - e.min.z + 1, u = ue.convert(i.format), c = ue.convert(i.type);
            if (i.isData3DTexture)
                q.setTexture3D(i, 0),
                a = 32879;
            else {
                if (!i.isDataArrayTexture)
                    return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                q.setTexture2DArray(i, 0),
                a = 35866
            }
            he.pixelStorei(37440, i.flipY),
            he.pixelStorei(37441, i.premultiplyAlpha),
            he.pixelStorei(3317, i.unpackAlignment);
            var h = he.getParameter(3314)
              , d = he.getParameter(32878)
              , p = he.getParameter(3316)
              , f = he.getParameter(3315)
              , v = he.getParameter(32877)
              , g = r.isCompressedTexture ? r.mipmaps[0] : r.image;
            he.pixelStorei(3314, g.width),
            he.pixelStorei(32878, g.height),
            he.pixelStorei(3316, e.min.x),
            he.pixelStorei(3315, e.min.y),
            he.pixelStorei(32877, e.min.z),
            r.isDataTexture || r.isData3DTexture ? he.texSubImage3D(a, n, t.x, t.y, t.z, o, s, l, u, c, g.data) : r.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),
            he.compressedTexSubImage3D(a, n, t.x, t.y, t.z, o, s, l, u, g.data)) : he.texSubImage3D(a, n, t.x, t.y, t.z, o, s, l, u, c, g),
            he.pixelStorei(3314, h),
            he.pixelStorei(32878, d),
            he.pixelStorei(3316, p),
            he.pixelStorei(3315, f),
            he.pixelStorei(32877, v),
            0 === n && i.generateMipmaps && he.generateMipmap(a),
            W.unbindTexture()
        }
    }
    ,
    this.initTexture = function(e) {
        q.setTexture2D(e, 0),
        W.unbindTexture()
    }
    ,
    this.resetState = function() {
        g = 0,
        _ = 0,
        y = null,
        W.reset(),
        ce.reset()
    }
    ,
    "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
        detail: this
    }))
}
WebGLRenderer.prototype.isWebGLRenderer = !0;
var WebGL1Renderer = function(e) {
    _inherits(r, WebGLRenderer);
    var t = _createSuper(r);
    function r() {
        return _classCallCheck(this, r),
        t.apply(this, arguments)
    }
    return _createClass(r)
}();
WebGL1Renderer.prototype.isWebGL1Renderer = !0;
var Scene = function(e) {
    _inherits(r, Object3D);
    var t = _createSuper(r);
    function r() {
        var e;
        return _classCallCheck(this, r),
        (e = t.call(this)).type = "Scene",
        e.background = null,
        e.environment = null,
        e.fog = null,
        e.overrideMaterial = null,
        e.autoUpdate = !0,
        "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: _assertThisInitialized(e)
        })),
        e
    }
    return _createClass(r, [{
        key: "copy",
        value: function(e, t) {
            return _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e, t),
            null !== e.background && (this.background = e.background.clone()),
            null !== e.environment && (this.environment = e.environment.clone()),
            null !== e.fog && (this.fog = e.fog.clone()),
            null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()),
            this.autoUpdate = e.autoUpdate,
            this.matrixAutoUpdate = e.matrixAutoUpdate,
            this
        }
    }, {
        key: "toJSON",
        value: function(e) {
            var t = _get(_getPrototypeOf(r.prototype), "toJSON", this).call(this, e);
            return null !== this.fog && (t.object.fog = this.fog.toJSON()),
            t
        }
    }]),
    r
}();
Scene.prototype.isScene = !0;
var InterleavedBuffer = function() {
    function e(t, r) {
        _classCallCheck(this, e),
        this.array = t,
        this.stride = r,
        this.count = void 0 !== t ? t.length / r : 0,
        this.usage = StaticDrawUsage,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.version = 0,
        this.uuid = generateUUID()
    }
    return _createClass(e, [{
        key: "onUploadCallback",
        value: function() {}
    }, {
        key: "needsUpdate",
        set: function(e) {
            !0 === e && this.version++
        }
    }, {
        key: "setUsage",
        value: function(e) {
            return this.usage = e,
            this
        }
    }, {
        key: "copy",
        value: function(e) {
            return this.array = new e.array.constructor(e.array),
            this.count = e.count,
            this.stride = e.stride,
            this.usage = e.usage,
            this
        }
    }, {
        key: "copyAt",
        value: function(e, t, r) {
            e *= this.stride,
            r *= t.stride;
            for (var i = 0, n = this.stride; i < n; i++)
                this.array[e + i] = t.array[r + i];
            return this
        }
    }, {
        key: "set",
        value: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
            return this.array.set(e, t),
            this
        }
    }, {
        key: "clone",
        value: function(e) {
            void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
            void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = generateUUID()),
            void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
            var t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid])
              , r = new this.constructor(t,this.stride);
            return r.setUsage(this.usage),
            r
        }
    }, {
        key: "onUpload",
        value: function(e) {
            return this.onUploadCallback = e,
            this
        }
    }, {
        key: "toJSON",
        value: function(e) {
            return void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
            void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = generateUUID()),
            void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))),
            {
                uuid: this.uuid,
                buffer: this.array.buffer._uuid,
                type: this.array.constructor.name,
                stride: this.stride
            }
        }
    }]),
    e
}();
InterleavedBuffer.prototype.isInterleavedBuffer = !0;
var _vector$6 = new Vector3
  , InterleavedBufferAttribute = function() {
    function e(t, r, i) {
        var n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
        _classCallCheck(this, e),
        this.name = "",
        this.data = t,
        this.itemSize = r,
        this.offset = i,
        this.normalized = !0 === n
    }
    return _createClass(e, [{
        key: "count",
        get: function() {
            return this.data.count
        }
    }, {
        key: "array",
        get: function() {
            return this.data.array
        }
    }, {
        key: "needsUpdate",
        set: function(e) {
            this.data.needsUpdate = e
        }
    }, {
        key: "applyMatrix4",
        value: function(e) {
            for (var t = 0, r = this.data.count; t < r; t++)
                _vector$6.fromBufferAttribute(this, t),
                _vector$6.applyMatrix4(e),
                this.setXYZ(t, _vector$6.x, _vector$6.y, _vector$6.z);
            return this
        }
    }, {
        key: "applyNormalMatrix",
        value: function(e) {
            for (var t = 0, r = this.count; t < r; t++)
                _vector$6.fromBufferAttribute(this, t),
                _vector$6.applyNormalMatrix(e),
                this.setXYZ(t, _vector$6.x, _vector$6.y, _vector$6.z);
            return this
        }
    }, {
        key: "transformDirection",
        value: function(e) {
            for (var t = 0, r = this.count; t < r; t++)
                _vector$6.fromBufferAttribute(this, t),
                _vector$6.transformDirection(e),
                this.setXYZ(t, _vector$6.x, _vector$6.y, _vector$6.z);
            return this
        }
    }, {
        key: "setX",
        value: function(e, t) {
            return this.data.array[e * this.data.stride + this.offset] = t,
            this
        }
    }, {
        key: "setY",
        value: function(e, t) {
            return this.data.array[e * this.data.stride + this.offset + 1] = t,
            this
        }
    }, {
        key: "setZ",
        value: function(e, t) {
            return this.data.array[e * this.data.stride + this.offset + 2] = t,
            this
        }
    }, {
        key: "setW",
        value: function(e, t) {
            return this.data.array[e * this.data.stride + this.offset + 3] = t,
            this
        }
    }, {
        key: "getX",
        value: function(e) {
            return this.data.array[e * this.data.stride + this.offset]
        }
    }, {
        key: "getY",
        value: function(e) {
            return this.data.array[e * this.data.stride + this.offset + 1]
        }
    }, {
        key: "getZ",
        value: function(e) {
            return this.data.array[e * this.data.stride + this.offset + 2]
        }
    }, {
        key: "getW",
        value: function(e) {
            return this.data.array[e * this.data.stride + this.offset + 3]
        }
    }, {
        key: "setXY",
        value: function(e, t, r) {
            return e = e * this.data.stride + this.offset,
            this.data.array[e + 0] = t,
            this.data.array[e + 1] = r,
            this
        }
    }, {
        key: "setXYZ",
        value: function(e, t, r, i) {
            return e = e * this.data.stride + this.offset,
            this.data.array[e + 0] = t,
            this.data.array[e + 1] = r,
            this.data.array[e + 2] = i,
            this
        }
    }, {
        key: "setXYZW",
        value: function(e, t, r, i, n) {
            return e = e * this.data.stride + this.offset,
            this.data.array[e + 0] = t,
            this.data.array[e + 1] = r,
            this.data.array[e + 2] = i,
            this.data.array[e + 3] = n,
            this
        }
    }, {
        key: "clone",
        value: function(t) {
            if (void 0 === t) {
                console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
                for (var r = [], i = 0; i < this.count; i++)
                    for (var n = i * this.data.stride + this.offset, a = 0; a < this.itemSize; a++)
                        r.push(this.data.array[n + a]);
                return new BufferAttribute(new this.array.constructor(r),this.itemSize,this.normalized)
            }
            return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
            void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
            new e(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)
        }
    }, {
        key: "toJSON",
        value: function(e) {
            if (void 0 === e) {
                console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
                for (var t = [], r = 0; r < this.count; r++)
                    for (var i = r * this.data.stride + this.offset, n = 0; n < this.itemSize; n++)
                        t.push(this.data.array[i + n]);
                return {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: t,
                    normalized: this.normalized
                }
            }
            return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
            void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
            {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized
            }
        }
    }]),
    e
}();
InterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = !0;
var SpriteMaterial = function(e) {
    _inherits(r, Material);
    var t = _createSuper(r);
    function r(e) {
        var i;
        return _classCallCheck(this, r),
        (i = t.call(this)).type = "SpriteMaterial",
        i.color = new Color(16777215),
        i.map = null,
        i.alphaMap = null,
        i.rotation = 0,
        i.sizeAttenuation = !0,
        i.transparent = !0,
        i.setValues(e),
        i
    }
    return _createClass(r, [{
        key: "copy",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e),
            this.color.copy(e.color),
            this.map = e.map,
            this.alphaMap = e.alphaMap,
            this.rotation = e.rotation,
            this.sizeAttenuation = e.sizeAttenuation,
            this
        }
    }]),
    r
}(), _geometry;
SpriteMaterial.prototype.isSpriteMaterial = !0;
var _intersectPoint = new Vector3
  , _worldScale = new Vector3
  , _mvPosition = new Vector3
  , _alignedPosition = new Vector2
  , _rotatedPosition = new Vector2
  , _viewWorldMatrix = new Matrix4
  , _vA = new Vector3
  , _vB = new Vector3
  , _vC = new Vector3
  , _uvA = new Vector2
  , _uvB = new Vector2
  , _uvC = new Vector2
  , Sprite = function(e) {
    _inherits(r, Object3D);
    var t = _createSuper(r);
    function r(e) {
        var i;
        if (_classCallCheck(this, r),
        (i = t.call(this)).type = "Sprite",
        void 0 === _geometry) {
            _geometry = new BufferGeometry;
            var n = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1])
              , a = new InterleavedBuffer(n,5);
            _geometry.setIndex([0, 1, 2, 0, 2, 3]),
            _geometry.setAttribute("position", new InterleavedBufferAttribute(a,3,0,!1)),
            _geometry.setAttribute("uv", new InterleavedBufferAttribute(a,2,3,!1))
        }
        return i.geometry = _geometry,
        i.material = void 0 !== e ? e : new SpriteMaterial,
        i.center = new Vector2(.5,.5),
        i
    }
    return _createClass(r, [{
        key: "raycast",
        value: function(e, t) {
            null === e.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),
            _worldScale.setFromMatrixScale(this.matrixWorld),
            _viewWorldMatrix.copy(e.camera.matrixWorld),
            this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld),
            _mvPosition.setFromMatrixPosition(this.modelViewMatrix),
            e.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && _worldScale.multiplyScalar(-_mvPosition.z);
            var r, i, n = this.material.rotation;
            0 !== n && (i = Math.cos(n),
            r = Math.sin(n));
            var a = this.center;
            transformVertex(_vA.set(-.5, -.5, 0), _mvPosition, a, _worldScale, r, i),
            transformVertex(_vB.set(.5, -.5, 0), _mvPosition, a, _worldScale, r, i),
            transformVertex(_vC.set(.5, .5, 0), _mvPosition, a, _worldScale, r, i),
            _uvA.set(0, 0),
            _uvB.set(1, 0),
            _uvC.set(1, 1);
            var o = e.ray.intersectTriangle(_vA, _vB, _vC, !1, _intersectPoint);
            if (null !== o || (transformVertex(_vB.set(-.5, .5, 0), _mvPosition, a, _worldScale, r, i),
            _uvB.set(0, 1),
            null !== (o = e.ray.intersectTriangle(_vA, _vC, _vB, !1, _intersectPoint)))) {
                var s = e.ray.origin.distanceTo(_intersectPoint);
                s < e.near || s > e.far || t.push({
                    distance: s,
                    point: _intersectPoint.clone(),
                    uv: Triangle.getUV(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2),
                    face: null,
                    object: this
                })
            }
        }
    }, {
        key: "copy",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e),
            void 0 !== e.center && this.center.copy(e.center),
            this.material = e.material,
            this
        }
    }]),
    r
}();
function transformVertex(e, t, r, i, n, a) {
    _alignedPosition.subVectors(e, r).addScalar(.5).multiply(i),
    void 0 !== n ? (_rotatedPosition.x = a * _alignedPosition.x - n * _alignedPosition.y,
    _rotatedPosition.y = n * _alignedPosition.x + a * _alignedPosition.y) : _rotatedPosition.copy(_alignedPosition),
    e.copy(t),
    e.x += _rotatedPosition.x,
    e.y += _rotatedPosition.y,
    e.applyMatrix4(_viewWorldMatrix)
}
Sprite.prototype.isSprite = !0;
var _basePosition = new Vector3
  , _skinIndex = new Vector4
  , _skinWeight = new Vector4
  , _vector$5 = new Vector3
  , _matrix = new Matrix4
  , SkinnedMesh = function(e) {
    _inherits(r, Mesh);
    var t = _createSuper(r);
    function r(e, i) {
        var n;
        return _classCallCheck(this, r),
        (n = t.call(this, e, i)).type = "SkinnedMesh",
        n.bindMode = "attached",
        n.bindMatrix = new Matrix4,
        n.bindMatrixInverse = new Matrix4,
        n
    }
    return _createClass(r, [{
        key: "copy",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e),
            this.bindMode = e.bindMode,
            this.bindMatrix.copy(e.bindMatrix),
            this.bindMatrixInverse.copy(e.bindMatrixInverse),
            this.skeleton = e.skeleton,
            this
        }
    }, {
        key: "bind",
        value: function(e, t) {
            this.skeleton = e,
            void 0 === t && (this.updateMatrixWorld(!0),
            this.skeleton.calculateInverses(),
            t = this.matrixWorld),
            this.bindMatrix.copy(t),
            this.bindMatrixInverse.copy(t).invert()
        }
    }, {
        key: "pose",
        value: function() {
            this.skeleton.pose()
        }
    }, {
        key: "normalizeSkinWeights",
        value: function() {
            for (var e = new Vector4, t = this.geometry.attributes.skinWeight, r = 0, i = t.count; r < i; r++) {
                e.fromBufferAttribute(t, r);
                var n = 1 / e.manhattanLength();
                n !== 1 / 0 ? e.multiplyScalar(n) : e.set(1, 0, 0, 0),
                t.setXYZW(r, e.x, e.y, e.z, e.w)
            }
        }
    }, {
        key: "updateMatrixWorld",
        value: function(e) {
            _get(_getPrototypeOf(r.prototype), "updateMatrixWorld", this).call(this, e),
            "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
        }
    }, {
        key: "boneTransform",
        value: function(e, t) {
            var r = this.skeleton
              , i = this.geometry;
            _skinIndex.fromBufferAttribute(i.attributes.skinIndex, e),
            _skinWeight.fromBufferAttribute(i.attributes.skinWeight, e),
            _basePosition.copy(t).applyMatrix4(this.bindMatrix),
            t.set(0, 0, 0);
            for (var n = 0; n < 4; n++) {
                var a = _skinWeight.getComponent(n);
                if (0 !== a) {
                    var o = _skinIndex.getComponent(n);
                    _matrix.multiplyMatrices(r.bones[o].matrixWorld, r.boneInverses[o]),
                    t.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix), a)
                }
            }
            return t.applyMatrix4(this.bindMatrixInverse)
        }
    }]),
    r
}();
SkinnedMesh.prototype.isSkinnedMesh = !0;
var Bone = function(e) {
    _inherits(r, Object3D);
    var t = _createSuper(r);
    function r() {
        var e;
        return _classCallCheck(this, r),
        (e = t.call(this)).type = "Bone",
        e
    }
    return _createClass(r)
}();
Bone.prototype.isBone = !0;
var DataTexture = function(e) {
    _inherits(r, Texture);
    var t = _createSuper(r);
    function r() {
        var e, i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, o = arguments.length > 3 ? arguments[3] : void 0, s = arguments.length > 4 ? arguments[4] : void 0, l = arguments.length > 5 ? arguments[5] : void 0, u = arguments.length > 6 ? arguments[6] : void 0, c = arguments.length > 7 ? arguments[7] : void 0, h = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : NearestFilter, d = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : NearestFilter, p = arguments.length > 10 ? arguments[10] : void 0, f = arguments.length > 11 ? arguments[11] : void 0;
        return _classCallCheck(this, r),
        (e = t.call(this, null, l, u, c, h, d, o, s, p, f)).image = {
            data: i,
            width: n,
            height: a
        },
        e.generateMipmaps = !1,
        e.flipY = !1,
        e.unpackAlignment = 1,
        e
    }
    return _createClass(r)
}();
DataTexture.prototype.isDataTexture = !0;
var InstancedBufferAttribute = function(e) {
    _inherits(r, BufferAttribute);
    var t = _createSuper(r);
    function r(e, i, n) {
        var a, o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
        return _classCallCheck(this, r),
        "number" == typeof n && (o = n,
        n = !1,
        console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),
        (a = t.call(this, e, i, n)).meshPerAttribute = o,
        a
    }
    return _createClass(r, [{
        key: "copy",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e),
            this.meshPerAttribute = e.meshPerAttribute,
            this
        }
    }, {
        key: "toJSON",
        value: function() {
            var e = _get(_getPrototypeOf(r.prototype), "toJSON", this).call(this);
            return e.meshPerAttribute = this.meshPerAttribute,
            e.isInstancedBufferAttribute = !0,
            e
        }
    }]),
    r
}();
InstancedBufferAttribute.prototype.isInstancedBufferAttribute = !0;
var _instanceLocalMatrix = new Matrix4
  , _instanceWorldMatrix = new Matrix4
  , _instanceIntersects = []
  , _mesh = new Mesh
  , InstancedMesh = function(e) {
    _inherits(r, Mesh);
    var t = _createSuper(r);
    function r(e, i, n) {
        var a;
        return _classCallCheck(this, r),
        (a = t.call(this, e, i)).instanceMatrix = new InstancedBufferAttribute(new Float32Array(16 * n),16),
        a.instanceColor = null,
        a.count = n,
        a.frustumCulled = !1,
        a
    }
    return _createClass(r, [{
        key: "copy",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e),
            this.instanceMatrix.copy(e.instanceMatrix),
            null !== e.instanceColor && (this.instanceColor = e.instanceColor.clone()),
            this.count = e.count,
            this
        }
    }, {
        key: "getColorAt",
        value: function(e, t) {
            t.fromArray(this.instanceColor.array, 3 * e)
        }
    }, {
        key: "getMatrixAt",
        value: function(e, t) {
            t.fromArray(this.instanceMatrix.array, 16 * e)
        }
    }, {
        key: "raycast",
        value: function(e, t) {
            var r = this.matrixWorld
              , i = this.count;
            if (_mesh.geometry = this.geometry,
            _mesh.material = this.material,
            void 0 !== _mesh.material)
                for (var n = 0; n < i; n++) {
                    this.getMatrixAt(n, _instanceLocalMatrix),
                    _instanceWorldMatrix.multiplyMatrices(r, _instanceLocalMatrix),
                    _mesh.matrixWorld = _instanceWorldMatrix,
                    _mesh.raycast(e, _instanceIntersects);
                    for (var a = 0, o = _instanceIntersects.length; a < o; a++) {
                        var s = _instanceIntersects[a];
                        s.instanceId = n,
                        s.object = this,
                        t.push(s)
                    }
                    _instanceIntersects.length = 0
                }
        }
    }, {
        key: "setColorAt",
        value: function(e, t) {
            null === this.instanceColor && (this.instanceColor = new InstancedBufferAttribute(new Float32Array(3 * this.instanceMatrix.count),3)),
            t.toArray(this.instanceColor.array, 3 * e)
        }
    }, {
        key: "setMatrixAt",
        value: function(e, t) {
            t.toArray(this.instanceMatrix.array, 16 * e)
        }
    }, {
        key: "updateMorphTargets",
        value: function() {}
    }, {
        key: "dispose",
        value: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }]),
    r
}();
InstancedMesh.prototype.isInstancedMesh = !0;
var LineBasicMaterial = function(e) {
    _inherits(r, Material);
    var t = _createSuper(r);
    function r(e) {
        var i;
        return _classCallCheck(this, r),
        (i = t.call(this)).type = "LineBasicMaterial",
        i.color = new Color(16777215),
        i.linewidth = 1,
        i.linecap = "round",
        i.linejoin = "round",
        i.setValues(e),
        i
    }
    return _createClass(r, [{
        key: "copy",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e),
            this.color.copy(e.color),
            this.linewidth = e.linewidth,
            this.linecap = e.linecap,
            this.linejoin = e.linejoin,
            this
        }
    }]),
    r
}();
LineBasicMaterial.prototype.isLineBasicMaterial = !0;
var _start$1 = new Vector3
  , _end$1 = new Vector3
  , _inverseMatrix$1 = new Matrix4
  , _ray$1 = new Ray
  , _sphere$1 = new Sphere
  , Line = function(e) {
    _inherits(r, Object3D);
    var t = _createSuper(r);
    function r() {
        var e, i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new BufferGeometry, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new LineBasicMaterial;
        return _classCallCheck(this, r),
        (e = t.call(this)).type = "Line",
        e.geometry = i,
        e.material = n,
        e.updateMorphTargets(),
        e
    }
    return _createClass(r, [{
        key: "copy",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e),
            this.material = e.material,
            this.geometry = e.geometry,
            this
        }
    }, {
        key: "computeLineDistances",
        value: function() {
            var e = this.geometry;
            if (e.isBufferGeometry)
                if (null === e.index) {
                    for (var t = e.attributes.position, r = [0], i = 1, n = t.count; i < n; i++)
                        _start$1.fromBufferAttribute(t, i - 1),
                        _end$1.fromBufferAttribute(t, i),
                        r[i] = r[i - 1],
                        r[i] += _start$1.distanceTo(_end$1);
                    e.setAttribute("lineDistance", new Float32BufferAttribute(r,1))
                } else
                    console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            else
                e.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
            return this
        }
    }, {
        key: "raycast",
        value: function(e, t) {
            var r = this.geometry
              , i = this.matrixWorld
              , n = e.params.Line.threshold
              , a = r.drawRange;
            if (null === r.boundingSphere && r.computeBoundingSphere(),
            _sphere$1.copy(r.boundingSphere),
            _sphere$1.applyMatrix4(i),
            _sphere$1.radius += n,
            !1 !== e.ray.intersectsSphere(_sphere$1)) {
                _inverseMatrix$1.copy(i).invert(),
                _ray$1.copy(e.ray).applyMatrix4(_inverseMatrix$1);
                var o = n / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                  , s = o * o
                  , l = new Vector3
                  , u = new Vector3
                  , c = new Vector3
                  , h = new Vector3
                  , d = this.isLineSegments ? 2 : 1;
                if (r.isBufferGeometry) {
                    var p = r.index
                      , f = r.attributes.position;
                    if (null !== p)
                        for (var m = Math.max(0, a.start), v = Math.min(p.count, a.start + a.count) - 1; m < v; m += d) {
                            var g = p.getX(m)
                              , _ = p.getX(m + 1);
                            if (l.fromBufferAttribute(f, g),
                            u.fromBufferAttribute(f, _),
                            !(_ray$1.distanceSqToSegment(l, u, h, c) > s)) {
                                h.applyMatrix4(this.matrixWorld);
                                var y = e.ray.origin.distanceTo(h);
                                y < e.near || y > e.far || t.push({
                                    distance: y,
                                    point: c.clone().applyMatrix4(this.matrixWorld),
                                    index: m,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                            }
                        }
                    else
                        for (var x = Math.max(0, a.start), b = Math.min(f.count, a.start + a.count) - 1; x < b; x += d)
                            if (l.fromBufferAttribute(f, x),
                            u.fromBufferAttribute(f, x + 1),
                            !(_ray$1.distanceSqToSegment(l, u, h, c) > s)) {
                                h.applyMatrix4(this.matrixWorld);
                                var S = e.ray.origin.distanceTo(h);
                                S < e.near || S > e.far || t.push({
                                    distance: S,
                                    point: c.clone().applyMatrix4(this.matrixWorld),
                                    index: x,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                            }
                } else
                    r.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        }
    }, {
        key: "updateMorphTargets",
        value: function() {
            var e = this.geometry;
            if (e.isBufferGeometry) {
                var t = e.morphAttributes
                  , r = Object.keys(t);
                if (r.length > 0) {
                    var i = t[r[0]];
                    if (void 0 !== i) {
                        this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {};
                        for (var n = 0, a = i.length; n < a; n++) {
                            var o = i[n].name || String(n);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[o] = n
                        }
                    }
                }
            } else {
                var s = e.morphTargets;
                void 0 !== s && s.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        }
    }]),
    r
}();
Line.prototype.isLine = !0;
var _start = new Vector3
  , _end = new Vector3
  , LineSegments = function(e) {
    _inherits(r, Line);
    var t = _createSuper(r);
    function r(e, i) {
        var n;
        return _classCallCheck(this, r),
        (n = t.call(this, e, i)).type = "LineSegments",
        n
    }
    return _createClass(r, [{
        key: "computeLineDistances",
        value: function() {
            var e = this.geometry;
            if (e.isBufferGeometry)
                if (null === e.index) {
                    for (var t = e.attributes.position, r = [], i = 0, n = t.count; i < n; i += 2)
                        _start.fromBufferAttribute(t, i),
                        _end.fromBufferAttribute(t, i + 1),
                        r[i] = 0 === i ? 0 : r[i - 1],
                        r[i + 1] = r[i] + _start.distanceTo(_end);
                    e.setAttribute("lineDistance", new Float32BufferAttribute(r,1))
                } else
                    console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            else
                e.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
            return this
        }
    }]),
    r
}();
LineSegments.prototype.isLineSegments = !0;
var LineLoop = function(e) {
    _inherits(r, Line);
    var t = _createSuper(r);
    function r(e, i) {
        var n;
        return _classCallCheck(this, r),
        (n = t.call(this, e, i)).type = "LineLoop",
        n
    }
    return _createClass(r)
}();
LineLoop.prototype.isLineLoop = !0;
var PointsMaterial = function(e) {
    _inherits(r, Material);
    var t = _createSuper(r);
    function r(e) {
        var i;
        return _classCallCheck(this, r),
        (i = t.call(this)).type = "PointsMaterial",
        i.color = new Color(16777215),
        i.map = null,
        i.alphaMap = null,
        i.size = 1,
        i.sizeAttenuation = !0,
        i.setValues(e),
        i
    }
    return _createClass(r, [{
        key: "copy",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e),
            this.color.copy(e.color),
            this.map = e.map,
            this.alphaMap = e.alphaMap,
            this.size = e.size,
            this.sizeAttenuation = e.sizeAttenuation,
            this
        }
    }]),
    r
}();
PointsMaterial.prototype.isPointsMaterial = !0;
var _inverseMatrix = new Matrix4
  , _ray = new Ray
  , _sphere = new Sphere
  , _position$2 = new Vector3
  , Points = function(e) {
    _inherits(r, Object3D);
    var t = _createSuper(r);
    function r() {
        var e, i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new BufferGeometry, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new PointsMaterial;
        return _classCallCheck(this, r),
        (e = t.call(this)).type = "Points",
        e.geometry = i,
        e.material = n,
        e.updateMorphTargets(),
        e
    }
    return _createClass(r, [{
        key: "copy",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e),
            this.material = e.material,
            this.geometry = e.geometry,
            this
        }
    }, {
        key: "raycast",
        value: function(e, t) {
            var r = this.geometry
              , i = this.matrixWorld
              , n = e.params.Points.threshold
              , a = r.drawRange;
            if (null === r.boundingSphere && r.computeBoundingSphere(),
            _sphere.copy(r.boundingSphere),
            _sphere.applyMatrix4(i),
            _sphere.radius += n,
            !1 !== e.ray.intersectsSphere(_sphere)) {
                _inverseMatrix.copy(i).invert(),
                _ray.copy(e.ray).applyMatrix4(_inverseMatrix);
                var o = n / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                  , s = o * o;
                if (r.isBufferGeometry) {
                    var l = r.index
                      , u = r.attributes.position;
                    if (null !== l)
                        for (var c = Math.max(0, a.start), h = Math.min(l.count, a.start + a.count); c < h; c++) {
                            var d = l.getX(c);
                            _position$2.fromBufferAttribute(u, d),
                            testPoint(_position$2, d, s, i, e, t, this)
                        }
                    else
                        for (var p = Math.max(0, a.start), f = Math.min(u.count, a.start + a.count); p < f; p++)
                            _position$2.fromBufferAttribute(u, p),
                            testPoint(_position$2, p, s, i, e, t, this)
                } else
                    console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        }
    }, {
        key: "updateMorphTargets",
        value: function() {
            var e = this.geometry;
            if (e.isBufferGeometry) {
                var t = e.morphAttributes
                  , r = Object.keys(t);
                if (r.length > 0) {
                    var i = t[r[0]];
                    if (void 0 !== i) {
                        this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {};
                        for (var n = 0, a = i.length; n < a; n++) {
                            var o = i[n].name || String(n);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[o] = n
                        }
                    }
                }
            } else {
                var s = e.morphTargets;
                void 0 !== s && s.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        }
    }]),
    r
}();
function testPoint(e, t, r, i, n, a, o) {
    var s = _ray.distanceSqToPoint(e);
    if (s < r) {
        var l = new Vector3;
        _ray.closestPointToPoint(e, l),
        l.applyMatrix4(i);
        var u = n.ray.origin.distanceTo(l);
        if (u < n.near || u > n.far)
            return;
        a.push({
            distance: u,
            distanceToRay: Math.sqrt(s),
            point: l,
            index: t,
            face: null,
            object: o
        })
    }
}
Points.prototype.isPoints = !0;
var VideoTexture = function(e) {
    _inherits(r, Texture);
    var t = _createSuper(r);
    function r(e, i, n, a, o, s, l, u, c) {
        var h;
        _classCallCheck(this, r),
        (h = t.call(this, e, i, n, a, o, s, l, u, c)).minFilter = void 0 !== s ? s : LinearFilter,
        h.magFilter = void 0 !== o ? o : LinearFilter,
        h.generateMipmaps = !1;
        var d = _assertThisInitialized(h);
        return "requestVideoFrameCallback"in e && e.requestVideoFrameCallback((function t() {
            d.needsUpdate = !0,
            e.requestVideoFrameCallback(t)
        }
        )),
        h
    }
    return _createClass(r, [{
        key: "clone",
        value: function() {
            return new this.constructor(this.image).copy(this)
        }
    }, {
        key: "update",
        value: function() {
            var e = this.image;
            !1 == "requestVideoFrameCallback"in e && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
        }
    }]),
    r
}();
VideoTexture.prototype.isVideoTexture = !0;
var FramebufferTexture = function(e) {
    _inherits(r, Texture);
    var t = _createSuper(r);
    function r(e, i, n) {
        var a;
        return _classCallCheck(this, r),
        (a = t.call(this, {
            width: e,
            height: i
        })).format = n,
        a.magFilter = NearestFilter,
        a.minFilter = NearestFilter,
        a.generateMipmaps = !1,
        a.needsUpdate = !0,
        a
    }
    return _createClass(r)
}();
FramebufferTexture.prototype.isFramebufferTexture = !0;
var CompressedTexture = function(e) {
    _inherits(r, Texture);
    var t = _createSuper(r);
    function r(e, i, n, a, o, s, l, u, c, h, d, p) {
        var f;
        return _classCallCheck(this, r),
        (f = t.call(this, null, s, l, u, c, h, a, o, d, p)).image = {
            width: i,
            height: n
        },
        f.mipmaps = e,
        f.flipY = !1,
        f.generateMipmaps = !1,
        f
    }
    return _createClass(r)
}();
CompressedTexture.prototype.isCompressedTexture = !0;
var CanvasTexture = function(e) {
    _inherits(r, Texture);
    var t = _createSuper(r);
    function r(e, i, n, a, o, s, l, u, c) {
        var h;
        return _classCallCheck(this, r),
        (h = t.call(this, e, i, n, a, o, s, l, u, c)).needsUpdate = !0,
        h
    }
    return _createClass(r)
}();
CanvasTexture.prototype.isCanvasTexture = !0;
var Curve = function() {
    function e() {
        _classCallCheck(this, e),
        this.type = "Curve",
        this.arcLengthDivisions = 200
    }
    return _createClass(e, [{
        key: "getPoint",
        value: function() {
            return console.warn("THREE.Curve: .getPoint() not implemented."),
            null
        }
    }, {
        key: "getPointAt",
        value: function(e, t) {
            var r = this.getUtoTmapping(e);
            return this.getPoint(r, t)
        }
    }, {
        key: "getPoints",
        value: function() {
            for (var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 5, t = [], r = 0; r <= e; r++)
                t.push(this.getPoint(r / e));
            return t
        }
    }, {
        key: "getSpacedPoints",
        value: function() {
            for (var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 5, t = [], r = 0; r <= e; r++)
                t.push(this.getPointAt(r / e));
            return t
        }
    }, {
        key: "getLength",
        value: function() {
            var e = this.getLengths();
            return e[e.length - 1]
        }
    }, {
        key: "getLengths",
        value: function() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.arcLengthDivisions;
            if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
                return this.cacheArcLengths;
            this.needsUpdate = !1;
            var t, r = [], i = this.getPoint(0), n = 0;
            r.push(0);
            for (var a = 1; a <= e; a++)
                n += (t = this.getPoint(a / e)).distanceTo(i),
                r.push(n),
                i = t;
            return this.cacheArcLengths = r,
            r
        }
    }, {
        key: "updateArcLengths",
        value: function() {
            this.needsUpdate = !0,
            this.getLengths()
        }
    }, {
        key: "getUtoTmapping",
        value: function(e, t) {
            var r, i = this.getLengths(), n = 0, a = i.length;
            r = t || e * i[a - 1];
            for (var o, s = 0, l = a - 1; s <= l; )
                if ((o = i[n = Math.floor(s + (l - s) / 2)] - r) < 0)
                    s = n + 1;
                else {
                    if (!(o > 0)) {
                        l = n;
                        break
                    }
                    l = n - 1
                }
            if (i[n = l] === r)
                return n / (a - 1);
            var u = i[n];
            return (n + (r - u) / (i[n + 1] - u)) / (a - 1)
        }
    }, {
        key: "getTangent",
        value: function(e, t) {
            var r = 1e-4
              , i = e - r
              , n = e + r;
            i < 0 && (i = 0),
            n > 1 && (n = 1);
            var a = this.getPoint(i)
              , o = this.getPoint(n)
              , s = t || (a.isVector2 ? new Vector2 : new Vector3);
            return s.copy(o).sub(a).normalize(),
            s
        }
    }, {
        key: "getTangentAt",
        value: function(e, t) {
            var r = this.getUtoTmapping(e);
            return this.getTangent(r, t)
        }
    }, {
        key: "computeFrenetFrames",
        value: function(e, t) {
            for (var r = new Vector3, i = [], n = [], a = [], o = new Vector3, s = new Matrix4, l = 0; l <= e; l++) {
                var u = l / e;
                i[l] = this.getTangentAt(u, new Vector3)
            }
            n[0] = new Vector3,
            a[0] = new Vector3;
            var c = Number.MAX_VALUE
              , h = Math.abs(i[0].x)
              , d = Math.abs(i[0].y)
              , p = Math.abs(i[0].z);
            h <= c && (c = h,
            r.set(1, 0, 0)),
            d <= c && (c = d,
            r.set(0, 1, 0)),
            p <= c && r.set(0, 0, 1),
            o.crossVectors(i[0], r).normalize(),
            n[0].crossVectors(i[0], o),
            a[0].crossVectors(i[0], n[0]);
            for (var f = 1; f <= e; f++) {
                if (n[f] = n[f - 1].clone(),
                a[f] = a[f - 1].clone(),
                o.crossVectors(i[f - 1], i[f]),
                o.length() > Number.EPSILON) {
                    o.normalize();
                    var m = Math.acos(clamp(i[f - 1].dot(i[f]), -1, 1));
                    n[f].applyMatrix4(s.makeRotationAxis(o, m))
                }
                a[f].crossVectors(i[f], n[f])
            }
            if (!0 === t) {
                var v = Math.acos(clamp(n[0].dot(n[e]), -1, 1));
                v /= e,
                i[0].dot(o.crossVectors(n[0], n[e])) > 0 && (v = -v);
                for (var g = 1; g <= e; g++)
                    n[g].applyMatrix4(s.makeRotationAxis(i[g], v * g)),
                    a[g].crossVectors(i[g], n[g])
            }
            return {
                tangents: i,
                normals: n,
                binormals: a
            }
        }
    }, {
        key: "clone",
        value: function() {
            return (new this.constructor).copy(this)
        }
    }, {
        key: "copy",
        value: function(e) {
            return this.arcLengthDivisions = e.arcLengthDivisions,
            this
        }
    }, {
        key: "toJSON",
        value: function() {
            var e = {
                metadata: {
                    version: 4.5,
                    type: "Curve",
                    generator: "Curve.toJSON"
                }
            };
            return e.arcLengthDivisions = this.arcLengthDivisions,
            e.type = this.type,
            e
        }
    }, {
        key: "fromJSON",
        value: function(e) {
            return this.arcLengthDivisions = e.arcLengthDivisions,
            this
        }
    }]),
    e
}()
  , EllipseCurve = function(e) {
    _inherits(r, Curve);
    var t = _createSuper(r);
    function r() {
        var e, i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1, s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, l = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 2 * Math.PI, u = arguments.length > 6 && void 0 !== arguments[6] && arguments[6], c = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 0;
        return _classCallCheck(this, r),
        (e = t.call(this)).type = "EllipseCurve",
        e.aX = i,
        e.aY = n,
        e.xRadius = a,
        e.yRadius = o,
        e.aStartAngle = s,
        e.aEndAngle = l,
        e.aClockwise = u,
        e.aRotation = c,
        e
    }
    return _createClass(r, [{
        key: "getPoint",
        value: function(e, t) {
            for (var r = t || new Vector2, i = 2 * Math.PI, n = this.aEndAngle - this.aStartAngle, a = Math.abs(n) < Number.EPSILON; n < 0; )
                n += i;
            for (; n > i; )
                n -= i;
            n < Number.EPSILON && (n = a ? 0 : i),
            !0 !== this.aClockwise || a || (n === i ? n = -i : n -= i);
            var o = this.aStartAngle + e * n
              , s = this.aX + this.xRadius * Math.cos(o)
              , l = this.aY + this.yRadius * Math.sin(o);
            if (0 !== this.aRotation) {
                var u = Math.cos(this.aRotation)
                  , c = Math.sin(this.aRotation)
                  , h = s - this.aX
                  , d = l - this.aY;
                s = h * u - d * c + this.aX,
                l = h * c + d * u + this.aY
            }
            return r.set(s, l)
        }
    }, {
        key: "copy",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e),
            this.aX = e.aX,
            this.aY = e.aY,
            this.xRadius = e.xRadius,
            this.yRadius = e.yRadius,
            this.aStartAngle = e.aStartAngle,
            this.aEndAngle = e.aEndAngle,
            this.aClockwise = e.aClockwise,
            this.aRotation = e.aRotation,
            this
        }
    }, {
        key: "toJSON",
        value: function() {
            var e = _get(_getPrototypeOf(r.prototype), "toJSON", this).call(this);
            return e.aX = this.aX,
            e.aY = this.aY,
            e.xRadius = this.xRadius,
            e.yRadius = this.yRadius,
            e.aStartAngle = this.aStartAngle,
            e.aEndAngle = this.aEndAngle,
            e.aClockwise = this.aClockwise,
            e.aRotation = this.aRotation,
            e
        }
    }, {
        key: "fromJSON",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "fromJSON", this).call(this, e),
            this.aX = e.aX,
            this.aY = e.aY,
            this.xRadius = e.xRadius,
            this.yRadius = e.yRadius,
            this.aStartAngle = e.aStartAngle,
            this.aEndAngle = e.aEndAngle,
            this.aClockwise = e.aClockwise,
            this.aRotation = e.aRotation,
            this
        }
    }]),
    r
}();
EllipseCurve.prototype.isEllipseCurve = !0;
var ArcCurve = function(e) {
    _inherits(r, EllipseCurve);
    var t = _createSuper(r);
    function r(e, i, n, a, o, s) {
        var l;
        return _classCallCheck(this, r),
        (l = t.call(this, e, i, n, n, a, o, s)).type = "ArcCurve",
        l
    }
    return _createClass(r)
}();
function CubicPoly() {
    var e = 0
      , t = 0
      , r = 0
      , i = 0;
    function n(n, a, o, s) {
        e = n,
        t = o,
        r = -3 * n + 3 * a - 2 * o - s,
        i = 2 * n - 2 * a + o + s
    }
    return {
        initCatmullRom: function(e, t, r, i, a) {
            n(t, r, a * (r - e), a * (i - t))
        },
        initNonuniformCatmullRom: function(e, t, r, i, a, o, s) {
            var l = (t - e) / a - (r - e) / (a + o) + (r - t) / o
              , u = (r - t) / o - (i - t) / (o + s) + (i - r) / s;
            n(t, r, l *= o, u *= o)
        },
        calc: function(n) {
            var a = n * n;
            return e + t * n + r * a + i * (a * n)
        }
    }
}
ArcCurve.prototype.isArcCurve = !0;
var tmp = new Vector3
  , px = new CubicPoly
  , py = new CubicPoly
  , pz = new CubicPoly
  , CatmullRomCurve3 = function(e) {
    _inherits(r, Curve);
    var t = _createSuper(r);
    function r() {
        var e, i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "centripetal", o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : .5;
        return _classCallCheck(this, r),
        (e = t.call(this)).type = "CatmullRomCurve3",
        e.points = i,
        e.closed = n,
        e.curveType = a,
        e.tension = o,
        e
    }
    return _createClass(r, [{
        key: "getPoint",
        value: function(e) {
            var t, r, i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Vector3, n = i, a = this.points, o = a.length, s = (o - (this.closed ? 0 : 1)) * e, l = Math.floor(s), u = s - l;
            this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / o) + 1) * o : 0 === u && l === o - 1 && (l = o - 2,
            u = 1),
            this.closed || l > 0 ? t = a[(l - 1) % o] : (tmp.subVectors(a[0], a[1]).add(a[0]),
            t = tmp);
            var c = a[l % o]
              , h = a[(l + 1) % o];
            if (this.closed || l + 2 < o ? r = a[(l + 2) % o] : (tmp.subVectors(a[o - 1], a[o - 2]).add(a[o - 1]),
            r = tmp),
            "centripetal" === this.curveType || "chordal" === this.curveType) {
                var d = "chordal" === this.curveType ? .5 : .25
                  , p = Math.pow(t.distanceToSquared(c), d)
                  , f = Math.pow(c.distanceToSquared(h), d)
                  , m = Math.pow(h.distanceToSquared(r), d);
                f < 1e-4 && (f = 1),
                p < 1e-4 && (p = f),
                m < 1e-4 && (m = f),
                px.initNonuniformCatmullRom(t.x, c.x, h.x, r.x, p, f, m),
                py.initNonuniformCatmullRom(t.y, c.y, h.y, r.y, p, f, m),
                pz.initNonuniformCatmullRom(t.z, c.z, h.z, r.z, p, f, m)
            } else
                "catmullrom" === this.curveType && (px.initCatmullRom(t.x, c.x, h.x, r.x, this.tension),
                py.initCatmullRom(t.y, c.y, h.y, r.y, this.tension),
                pz.initCatmullRom(t.z, c.z, h.z, r.z, this.tension));
            return n.set(px.calc(u), py.calc(u), pz.calc(u)),
            n
        }
    }, {
        key: "copy",
        value: function(e) {
            _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e),
            this.points = [];
            for (var t = 0, i = e.points.length; t < i; t++) {
                var n = e.points[t];
                this.points.push(n.clone())
            }
            return this.closed = e.closed,
            this.curveType = e.curveType,
            this.tension = e.tension,
            this
        }
    }, {
        key: "toJSON",
        value: function() {
            var e = _get(_getPrototypeOf(r.prototype), "toJSON", this).call(this);
            e.points = [];
            for (var t = 0, i = this.points.length; t < i; t++) {
                var n = this.points[t];
                e.points.push(n.toArray())
            }
            return e.closed = this.closed,
            e.curveType = this.curveType,
            e.tension = this.tension,
            e
        }
    }, {
        key: "fromJSON",
        value: function(e) {
            _get(_getPrototypeOf(r.prototype), "fromJSON", this).call(this, e),
            this.points = [];
            for (var t = 0, i = e.points.length; t < i; t++) {
                var n = e.points[t];
                this.points.push((new Vector3).fromArray(n))
            }
            return this.closed = e.closed,
            this.curveType = e.curveType,
            this.tension = e.tension,
            this
        }
    }]),
    r
}();
function CatmullRom(e, t, r, i, n) {
    var a = .5 * (i - t)
      , o = .5 * (n - r)
      , s = e * e;
    return (2 * r - 2 * i + a + o) * (e * s) + (-3 * r + 3 * i - 2 * a - o) * s + a * e + r
}
function QuadraticBezierP0(e, t) {
    var r = 1 - e;
    return r * r * t
}
function QuadraticBezierP1(e, t) {
    return 2 * (1 - e) * e * t
}
function QuadraticBezierP2(e, t) {
    return e * e * t
}
function QuadraticBezier(e, t, r, i) {
    return QuadraticBezierP0(e, t) + QuadraticBezierP1(e, r) + QuadraticBezierP2(e, i)
}
function CubicBezierP0(e, t) {
    var r = 1 - e;
    return r * r * r * t
}
function CubicBezierP1(e, t) {
    var r = 1 - e;
    return 3 * r * r * e * t
}
function CubicBezierP2(e, t) {
    return 3 * (1 - e) * e * e * t
}
function CubicBezierP3(e, t) {
    return e * e * e * t
}
function CubicBezier(e, t, r, i, n) {
    return CubicBezierP0(e, t) + CubicBezierP1(e, r) + CubicBezierP2(e, i) + CubicBezierP3(e, n)
}
CatmullRomCurve3.prototype.isCatmullRomCurve3 = !0;
var CubicBezierCurve = function(e) {
    _inherits(r, Curve);
    var t = _createSuper(r);
    function r() {
        var e, i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Vector2, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Vector2, a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : new Vector2, o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : new Vector2;
        return _classCallCheck(this, r),
        (e = t.call(this)).type = "CubicBezierCurve",
        e.v0 = i,
        e.v1 = n,
        e.v2 = a,
        e.v3 = o,
        e
    }
    return _createClass(r, [{
        key: "getPoint",
        value: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Vector2
              , r = t
              , i = this.v0
              , n = this.v1
              , a = this.v2
              , o = this.v3;
            return r.set(CubicBezier(e, i.x, n.x, a.x, o.x), CubicBezier(e, i.y, n.y, a.y, o.y)),
            r
        }
    }, {
        key: "copy",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this.v3.copy(e.v3),
            this
        }
    }, {
        key: "toJSON",
        value: function() {
            var e = _get(_getPrototypeOf(r.prototype), "toJSON", this).call(this);
            return e.v0 = this.v0.toArray(),
            e.v1 = this.v1.toArray(),
            e.v2 = this.v2.toArray(),
            e.v3 = this.v3.toArray(),
            e
        }
    }, {
        key: "fromJSON",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "fromJSON", this).call(this, e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this.v3.fromArray(e.v3),
            this
        }
    }]),
    r
}();
CubicBezierCurve.prototype.isCubicBezierCurve = !0;
var CubicBezierCurve3 = function(e) {
    _inherits(r, Curve);
    var t = _createSuper(r);
    function r() {
        var e, i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Vector3, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Vector3, a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : new Vector3, o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : new Vector3;
        return _classCallCheck(this, r),
        (e = t.call(this)).type = "CubicBezierCurve3",
        e.v0 = i,
        e.v1 = n,
        e.v2 = a,
        e.v3 = o,
        e
    }
    return _createClass(r, [{
        key: "getPoint",
        value: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Vector3
              , r = t
              , i = this.v0
              , n = this.v1
              , a = this.v2
              , o = this.v3;
            return r.set(CubicBezier(e, i.x, n.x, a.x, o.x), CubicBezier(e, i.y, n.y, a.y, o.y), CubicBezier(e, i.z, n.z, a.z, o.z)),
            r
        }
    }, {
        key: "copy",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this.v3.copy(e.v3),
            this
        }
    }, {
        key: "toJSON",
        value: function() {
            var e = _get(_getPrototypeOf(r.prototype), "toJSON", this).call(this);
            return e.v0 = this.v0.toArray(),
            e.v1 = this.v1.toArray(),
            e.v2 = this.v2.toArray(),
            e.v3 = this.v3.toArray(),
            e
        }
    }, {
        key: "fromJSON",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "fromJSON", this).call(this, e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this.v3.fromArray(e.v3),
            this
        }
    }]),
    r
}();
CubicBezierCurve3.prototype.isCubicBezierCurve3 = !0;
var LineCurve = function(e) {
    _inherits(r, Curve);
    var t = _createSuper(r);
    function r() {
        var e, i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Vector2, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Vector2;
        return _classCallCheck(this, r),
        (e = t.call(this)).type = "LineCurve",
        e.v1 = i,
        e.v2 = n,
        e
    }
    return _createClass(r, [{
        key: "getPoint",
        value: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Vector2
              , r = t;
            return 1 === e ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1),
            r.multiplyScalar(e).add(this.v1)),
            r
        }
    }, {
        key: "getPointAt",
        value: function(e, t) {
            return this.getPoint(e, t)
        }
    }, {
        key: "getTangent",
        value: function(e, t) {
            var r = t || new Vector2;
            return r.copy(this.v2).sub(this.v1).normalize(),
            r
        }
    }, {
        key: "copy",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this
        }
    }, {
        key: "toJSON",
        value: function() {
            var e = _get(_getPrototypeOf(r.prototype), "toJSON", this).call(this);
            return e.v1 = this.v1.toArray(),
            e.v2 = this.v2.toArray(),
            e
        }
    }, {
        key: "fromJSON",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "fromJSON", this).call(this, e),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
        }
    }]),
    r
}();
LineCurve.prototype.isLineCurve = !0;
var LineCurve3 = function(e) {
    _inherits(r, Curve);
    var t = _createSuper(r);
    function r() {
        var e, i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Vector3, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Vector3;
        return _classCallCheck(this, r),
        (e = t.call(this)).type = "LineCurve3",
        e.isLineCurve3 = !0,
        e.v1 = i,
        e.v2 = n,
        e
    }
    return _createClass(r, [{
        key: "getPoint",
        value: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Vector3
              , r = t;
            return 1 === e ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1),
            r.multiplyScalar(e).add(this.v1)),
            r
        }
    }, {
        key: "getPointAt",
        value: function(e, t) {
            return this.getPoint(e, t)
        }
    }, {
        key: "copy",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this
        }
    }, {
        key: "toJSON",
        value: function() {
            var e = _get(_getPrototypeOf(r.prototype), "toJSON", this).call(this);
            return e.v1 = this.v1.toArray(),
            e.v2 = this.v2.toArray(),
            e
        }
    }, {
        key: "fromJSON",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "fromJSON", this).call(this, e),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
        }
    }]),
    r
}()
  , QuadraticBezierCurve = function(e) {
    _inherits(r, Curve);
    var t = _createSuper(r);
    function r() {
        var e, i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Vector2, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Vector2, a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : new Vector2;
        return _classCallCheck(this, r),
        (e = t.call(this)).type = "QuadraticBezierCurve",
        e.v0 = i,
        e.v1 = n,
        e.v2 = a,
        e
    }
    return _createClass(r, [{
        key: "getPoint",
        value: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Vector2
              , r = t
              , i = this.v0
              , n = this.v1
              , a = this.v2;
            return r.set(QuadraticBezier(e, i.x, n.x, a.x), QuadraticBezier(e, i.y, n.y, a.y)),
            r
        }
    }, {
        key: "copy",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this
        }
    }, {
        key: "toJSON",
        value: function() {
            var e = _get(_getPrototypeOf(r.prototype), "toJSON", this).call(this);
            return e.v0 = this.v0.toArray(),
            e.v1 = this.v1.toArray(),
            e.v2 = this.v2.toArray(),
            e
        }
    }, {
        key: "fromJSON",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "fromJSON", this).call(this, e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
        }
    }]),
    r
}();
QuadraticBezierCurve.prototype.isQuadraticBezierCurve = !0;
var QuadraticBezierCurve3 = function(e) {
    _inherits(r, Curve);
    var t = _createSuper(r);
    function r() {
        var e, i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Vector3, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Vector3, a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : new Vector3;
        return _classCallCheck(this, r),
        (e = t.call(this)).type = "QuadraticBezierCurve3",
        e.v0 = i,
        e.v1 = n,
        e.v2 = a,
        e
    }
    return _createClass(r, [{
        key: "getPoint",
        value: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Vector3
              , r = t
              , i = this.v0
              , n = this.v1
              , a = this.v2;
            return r.set(QuadraticBezier(e, i.x, n.x, a.x), QuadraticBezier(e, i.y, n.y, a.y), QuadraticBezier(e, i.z, n.z, a.z)),
            r
        }
    }, {
        key: "copy",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this
        }
    }, {
        key: "toJSON",
        value: function() {
            var e = _get(_getPrototypeOf(r.prototype), "toJSON", this).call(this);
            return e.v0 = this.v0.toArray(),
            e.v1 = this.v1.toArray(),
            e.v2 = this.v2.toArray(),
            e
        }
    }, {
        key: "fromJSON",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "fromJSON", this).call(this, e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
        }
    }]),
    r
}();
QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = !0;
var SplineCurve = function(e) {
    _inherits(r, Curve);
    var t = _createSuper(r);
    function r() {
        var e, i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
        return _classCallCheck(this, r),
        (e = t.call(this)).type = "SplineCurve",
        e.points = i,
        e
    }
    return _createClass(r, [{
        key: "getPoint",
        value: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Vector2
              , r = t
              , i = this.points
              , n = (i.length - 1) * e
              , a = Math.floor(n)
              , o = n - a
              , s = i[0 === a ? a : a - 1]
              , l = i[a]
              , u = i[a > i.length - 2 ? i.length - 1 : a + 1]
              , c = i[a > i.length - 3 ? i.length - 1 : a + 2];
            return r.set(CatmullRom(o, s.x, l.x, u.x, c.x), CatmullRom(o, s.y, l.y, u.y, c.y)),
            r
        }
    }, {
        key: "copy",
        value: function(e) {
            _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e),
            this.points = [];
            for (var t = 0, i = e.points.length; t < i; t++) {
                var n = e.points[t];
                this.points.push(n.clone())
            }
            return this
        }
    }, {
        key: "toJSON",
        value: function() {
            var e = _get(_getPrototypeOf(r.prototype), "toJSON", this).call(this);
            e.points = [];
            for (var t = 0, i = this.points.length; t < i; t++) {
                var n = this.points[t];
                e.points.push(n.toArray())
            }
            return e
        }
    }, {
        key: "fromJSON",
        value: function(e) {
            _get(_getPrototypeOf(r.prototype), "fromJSON", this).call(this, e),
            this.points = [];
            for (var t = 0, i = e.points.length; t < i; t++) {
                var n = e.points[t];
                this.points.push((new Vector2).fromArray(n))
            }
            return this
        }
    }]),
    r
}();
SplineCurve.prototype.isSplineCurve = !0;
var Curves = Object.freeze({
    __proto__: null,
    ArcCurve,
    CatmullRomCurve3,
    CubicBezierCurve,
    CubicBezierCurve3,
    EllipseCurve,
    LineCurve,
    LineCurve3,
    QuadraticBezierCurve,
    QuadraticBezierCurve3,
    SplineCurve
})
  , CurvePath = function(e) {
    _inherits(r, Curve);
    var t = _createSuper(r);
    function r() {
        var e;
        return _classCallCheck(this, r),
        (e = t.call(this)).type = "CurvePath",
        e.curves = [],
        e.autoClose = !1,
        e
    }
    return _createClass(r, [{
        key: "add",
        value: function(e) {
            this.curves.push(e)
        }
    }, {
        key: "closePath",
        value: function() {
            var e = this.curves[0].getPoint(0)
              , t = this.curves[this.curves.length - 1].getPoint(1);
            e.equals(t) || this.curves.push(new LineCurve(t,e))
        }
    }, {
        key: "getPoint",
        value: function(e, t) {
            for (var r = e * this.getLength(), i = this.getCurveLengths(), n = 0; n < i.length; ) {
                if (i[n] >= r) {
                    var a = i[n] - r
                      , o = this.curves[n]
                      , s = o.getLength()
                      , l = 0 === s ? 0 : 1 - a / s;
                    return o.getPointAt(l, t)
                }
                n++
            }
            return null
        }
    }, {
        key: "getLength",
        value: function() {
            var e = this.getCurveLengths();
            return e[e.length - 1]
        }
    }, {
        key: "updateArcLengths",
        value: function() {
            this.needsUpdate = !0,
            this.cacheLengths = null,
            this.getCurveLengths()
        }
    }, {
        key: "getCurveLengths",
        value: function() {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
                return this.cacheLengths;
            for (var e = [], t = 0, r = 0, i = this.curves.length; r < i; r++)
                t += this.curves[r].getLength(),
                e.push(t);
            return this.cacheLengths = e,
            e
        }
    }, {
        key: "getSpacedPoints",
        value: function() {
            for (var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 40, t = [], r = 0; r <= e; r++)
                t.push(this.getPoint(r / e));
            return this.autoClose && t.push(t[0]),
            t
        }
    }, {
        key: "getPoints",
        value: function() {
            for (var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 12, r = [], i = 0, n = this.curves; i < n.length; i++)
                for (var a = n[i], o = a.isEllipseCurve ? 2 * t : a.isLineCurve || a.isLineCurve3 ? 1 : a.isSplineCurve ? t * a.points.length : t, s = a.getPoints(o), l = 0; l < s.length; l++) {
                    var u = s[l];
                    e && e.equals(u) || (r.push(u),
                    e = u)
                }
            return this.autoClose && r.length > 1 && !r[r.length - 1].equals(r[0]) && r.push(r[0]),
            r
        }
    }, {
        key: "copy",
        value: function(e) {
            _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e),
            this.curves = [];
            for (var t = 0, i = e.curves.length; t < i; t++) {
                var n = e.curves[t];
                this.curves.push(n.clone())
            }
            return this.autoClose = e.autoClose,
            this
        }
    }, {
        key: "toJSON",
        value: function() {
            var e = _get(_getPrototypeOf(r.prototype), "toJSON", this).call(this);
            e.autoClose = this.autoClose,
            e.curves = [];
            for (var t = 0, i = this.curves.length; t < i; t++) {
                var n = this.curves[t];
                e.curves.push(n.toJSON())
            }
            return e
        }
    }, {
        key: "fromJSON",
        value: function(e) {
            _get(_getPrototypeOf(r.prototype), "fromJSON", this).call(this, e),
            this.autoClose = e.autoClose,
            this.curves = [];
            for (var t = 0, i = e.curves.length; t < i; t++) {
                var n = e.curves[t];
                this.curves.push((new Curves[n.type]).fromJSON(n))
            }
            return this
        }
    }]),
    r
}()
  , Path = function(e) {
    _inherits(r, CurvePath);
    var t = _createSuper(r);
    function r(e) {
        var i;
        return _classCallCheck(this, r),
        (i = t.call(this)).type = "Path",
        i.currentPoint = new Vector2,
        e && i.setFromPoints(e),
        i
    }
    return _createClass(r, [{
        key: "setFromPoints",
        value: function(e) {
            this.moveTo(e[0].x, e[0].y);
            for (var t = 1, r = e.length; t < r; t++)
                this.lineTo(e[t].x, e[t].y);
            return this
        }
    }, {
        key: "moveTo",
        value: function(e, t) {
            return this.currentPoint.set(e, t),
            this
        }
    }, {
        key: "lineTo",
        value: function(e, t) {
            var r = new LineCurve(this.currentPoint.clone(),new Vector2(e,t));
            return this.curves.push(r),
            this.currentPoint.set(e, t),
            this
        }
    }, {
        key: "quadraticCurveTo",
        value: function(e, t, r, i) {
            var n = new QuadraticBezierCurve(this.currentPoint.clone(),new Vector2(e,t),new Vector2(r,i));
            return this.curves.push(n),
            this.currentPoint.set(r, i),
            this
        }
    }, {
        key: "bezierCurveTo",
        value: function(e, t, r, i, n, a) {
            var o = new CubicBezierCurve(this.currentPoint.clone(),new Vector2(e,t),new Vector2(r,i),new Vector2(n,a));
            return this.curves.push(o),
            this.currentPoint.set(n, a),
            this
        }
    }, {
        key: "splineThru",
        value: function(e) {
            var t = [this.currentPoint.clone()].concat(e)
              , r = new SplineCurve(t);
            return this.curves.push(r),
            this.currentPoint.copy(e[e.length - 1]),
            this
        }
    }, {
        key: "arc",
        value: function(e, t, r, i, n, a) {
            var o = this.currentPoint.x
              , s = this.currentPoint.y;
            return this.absarc(e + o, t + s, r, i, n, a),
            this
        }
    }, {
        key: "absarc",
        value: function(e, t, r, i, n, a) {
            return this.absellipse(e, t, r, r, i, n, a),
            this
        }
    }, {
        key: "ellipse",
        value: function(e, t, r, i, n, a, o, s) {
            var l = this.currentPoint.x
              , u = this.currentPoint.y;
            return this.absellipse(e + l, t + u, r, i, n, a, o, s),
            this
        }
    }, {
        key: "absellipse",
        value: function(e, t, r, i, n, a, o, s) {
            var l = new EllipseCurve(e,t,r,i,n,a,o,s);
            if (this.curves.length > 0) {
                var u = l.getPoint(0);
                u.equals(this.currentPoint) || this.lineTo(u.x, u.y)
            }
            this.curves.push(l);
            var c = l.getPoint(1);
            return this.currentPoint.copy(c),
            this
        }
    }, {
        key: "copy",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e),
            this.currentPoint.copy(e.currentPoint),
            this
        }
    }, {
        key: "toJSON",
        value: function() {
            var e = _get(_getPrototypeOf(r.prototype), "toJSON", this).call(this);
            return e.currentPoint = this.currentPoint.toArray(),
            e
        }
    }, {
        key: "fromJSON",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "fromJSON", this).call(this, e),
            this.currentPoint.fromArray(e.currentPoint),
            this
        }
    }]),
    r
}()
  , CylinderGeometry = function(e) {
    _inherits(r, BufferGeometry);
    var t = _createSuper(r);
    function r() {
        var e, i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 8, s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1, l = arguments.length > 5 && void 0 !== arguments[5] && arguments[5], u = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 0, c = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 2 * Math.PI;
        _classCallCheck(this, r),
        (e = t.call(this)).type = "CylinderGeometry",
        e.parameters = {
            radiusTop: i,
            radiusBottom: n,
            height: a,
            radialSegments: o,
            heightSegments: s,
            openEnded: l,
            thetaStart: u,
            thetaLength: c
        };
        var h = _assertThisInitialized(e);
        o = Math.floor(o),
        s = Math.floor(s);
        var d = []
          , p = []
          , f = []
          , m = []
          , v = 0
          , g = []
          , _ = a / 2
          , y = 0;
        function x() {
            for (var e = new Vector3, t = new Vector3, r = 0, l = (n - i) / a, x = 0; x <= s; x++) {
                for (var b = [], S = x / s, w = S * (n - i) + i, M = 0; M <= o; M++) {
                    var T = M / o
                      , C = T * c + u
                      , E = Math.sin(C)
                      , P = Math.cos(C);
                    t.x = w * E,
                    t.y = -S * a + _,
                    t.z = w * P,
                    p.push(t.x, t.y, t.z),
                    e.set(E, l, P).normalize(),
                    f.push(e.x, e.y, e.z),
                    m.push(T, 1 - S),
                    b.push(v++)
                }
                g.push(b)
            }
            for (var A = 0; A < o; A++)
                for (var k = 0; k < s; k++) {
                    var L = g[k][A]
                      , R = g[k + 1][A]
                      , D = g[k + 1][A + 1]
                      , I = g[k][A + 1];
                    d.push(L, R, I),
                    d.push(R, D, I),
                    r += 6
                }
            h.addGroup(y, r, 0),
            y += r
        }
        function b(e) {
            for (var t = v, r = new Vector2, a = new Vector3, s = 0, l = !0 === e ? i : n, g = !0 === e ? 1 : -1, x = 1; x <= o; x++)
                p.push(0, _ * g, 0),
                f.push(0, g, 0),
                m.push(.5, .5),
                v++;
            for (var b = v, S = 0; S <= o; S++) {
                var w = S / o * c + u
                  , M = Math.cos(w)
                  , T = Math.sin(w);
                a.x = l * T,
                a.y = _ * g,
                a.z = l * M,
                p.push(a.x, a.y, a.z),
                f.push(0, g, 0),
                r.x = .5 * M + .5,
                r.y = .5 * T * g + .5,
                m.push(r.x, r.y),
                v++
            }
            for (var C = 0; C < o; C++) {
                var E = t + C
                  , P = b + C;
                !0 === e ? d.push(P, P + 1, E) : d.push(P + 1, P, E),
                s += 3
            }
            h.addGroup(y, s, !0 === e ? 1 : 2),
            y += s
        }
        return x(),
        !1 === l && (i > 0 && b(!0),
        n > 0 && b(!1)),
        e.setIndex(d),
        e.setAttribute("position", new Float32BufferAttribute(p,3)),
        e.setAttribute("normal", new Float32BufferAttribute(f,3)),
        e.setAttribute("uv", new Float32BufferAttribute(m,2)),
        e
    }
    return _createClass(r, null, [{
        key: "fromJSON",
        value: function(e) {
            return new r(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)
        }
    }]),
    r
}();
new Vector3,
new Vector3,
new Vector3,
new Triangle;
var Shape = function(e) {
    _inherits(r, Path);
    var t = _createSuper(r);
    function r(e) {
        var i;
        return _classCallCheck(this, r),
        (i = t.call(this, e)).uuid = generateUUID(),
        i.type = "Shape",
        i.holes = [],
        i
    }
    return _createClass(r, [{
        key: "getPointsHoles",
        value: function(e) {
            for (var t = [], r = 0, i = this.holes.length; r < i; r++)
                t[r] = this.holes[r].getPoints(e);
            return t
        }
    }, {
        key: "extractPoints",
        value: function(e) {
            return {
                shape: this.getPoints(e),
                holes: this.getPointsHoles(e)
            }
        }
    }, {
        key: "copy",
        value: function(e) {
            _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e),
            this.holes = [];
            for (var t = 0, i = e.holes.length; t < i; t++) {
                var n = e.holes[t];
                this.holes.push(n.clone())
            }
            return this
        }
    }, {
        key: "toJSON",
        value: function() {
            var e = _get(_getPrototypeOf(r.prototype), "toJSON", this).call(this);
            e.uuid = this.uuid,
            e.holes = [];
            for (var t = 0, i = this.holes.length; t < i; t++) {
                var n = this.holes[t];
                e.holes.push(n.toJSON())
            }
            return e
        }
    }, {
        key: "fromJSON",
        value: function(e) {
            _get(_getPrototypeOf(r.prototype), "fromJSON", this).call(this, e),
            this.uuid = e.uuid,
            this.holes = [];
            for (var t = 0, i = e.holes.length; t < i; t++) {
                var n = e.holes[t];
                this.holes.push((new Path).fromJSON(n))
            }
            return this
        }
    }]),
    r
}()
  , Earcut = {
    triangulate: function(e, t) {
        var r, i, n, a, o, s, l, u = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 2, c = t && t.length, h = c ? t[0] * u : e.length, d = linkedList(e, 0, h, u, !0), p = [];
        if (!d || d.next === d.prev)
            return p;
        if (c && (d = eliminateHoles(e, t, d, u)),
        e.length > 80 * u) {
            r = n = e[0],
            i = a = e[1];
            for (var f = u; f < h; f += u)
                (o = e[f]) < r && (r = o),
                (s = e[f + 1]) < i && (i = s),
                o > n && (n = o),
                s > a && (a = s);
            l = 0 !== (l = Math.max(n - r, a - i)) ? 1 / l : 0
        }
        return earcutLinked(d, p, u, r, i, l),
        p
    }
};
function linkedList(e, t, r, i, n) {
    var a, o;
    if (n === signedArea(e, t, r, i) > 0)
        for (a = t; a < r; a += i)
            o = insertNode(a, e[a], e[a + 1], o);
    else
        for (a = r - i; a >= t; a -= i)
            o = insertNode(a, e[a], e[a + 1], o);
    return o && equals(o, o.next) && (removeNode(o),
    o = o.next),
    o
}
function filterPoints(e, t) {
    if (!e)
        return e;
    t || (t = e);
    var r, i = e;
    do {
        if (r = !1,
        i.steiner || !equals(i, i.next) && 0 !== area(i.prev, i, i.next))
            i = i.next;
        else {
            if (removeNode(i),
            (i = t = i.prev) === i.next)
                break;
            r = !0
        }
    } while (r || i !== t);
    return t
}
function earcutLinked(e, t, r, i, n, a, o) {
    if (e) {
        !o && a && indexCurve(e, i, n, a);
        for (var s, l, u = e; e.prev !== e.next; )
            if (s = e.prev,
            l = e.next,
            a ? isEarHashed(e, i, n, a) : isEar(e))
                t.push(s.i / r),
                t.push(e.i / r),
                t.push(l.i / r),
                removeNode(e),
                e = l.next,
                u = l.next;
            else if ((e = l) === u) {
                o ? 1 === o ? earcutLinked(e = cureLocalIntersections(filterPoints(e), t, r), t, r, i, n, a, 2) : 2 === o && splitEarcut(e, t, r, i, n, a) : earcutLinked(filterPoints(e), t, r, i, n, a, 1);
                break
            }
    }
}
function isEar(e) {
    var t = e.prev
      , r = e
      , i = e.next;
    if (area(t, r, i) >= 0)
        return !1;
    for (var n = e.next.next; n !== e.prev; ) {
        if (pointInTriangle(t.x, t.y, r.x, r.y, i.x, i.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)
            return !1;
        n = n.next
    }
    return !0
}
function isEarHashed(e, t, r, i) {
    var n = e.prev
      , a = e
      , o = e.next;
    if (area(n, a, o) >= 0)
        return !1;
    for (var s = n.x < a.x ? n.x < o.x ? n.x : o.x : a.x < o.x ? a.x : o.x, l = n.y < a.y ? n.y < o.y ? n.y : o.y : a.y < o.y ? a.y : o.y, u = n.x > a.x ? n.x > o.x ? n.x : o.x : a.x > o.x ? a.x : o.x, c = n.y > a.y ? n.y > o.y ? n.y : o.y : a.y > o.y ? a.y : o.y, h = zOrder(s, l, t, r, i), d = zOrder(u, c, t, r, i), p = e.prevZ, f = e.nextZ; p && p.z >= h && f && f.z <= d; ) {
        if (p !== e.prev && p !== e.next && pointInTriangle(n.x, n.y, a.x, a.y, o.x, o.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
            return !1;
        if (p = p.prevZ,
        f !== e.prev && f !== e.next && pointInTriangle(n.x, n.y, a.x, a.y, o.x, o.y, f.x, f.y) && area(f.prev, f, f.next) >= 0)
            return !1;
        f = f.nextZ
    }
    for (; p && p.z >= h; ) {
        if (p !== e.prev && p !== e.next && pointInTriangle(n.x, n.y, a.x, a.y, o.x, o.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
            return !1;
        p = p.prevZ
    }
    for (; f && f.z <= d; ) {
        if (f !== e.prev && f !== e.next && pointInTriangle(n.x, n.y, a.x, a.y, o.x, o.y, f.x, f.y) && area(f.prev, f, f.next) >= 0)
            return !1;
        f = f.nextZ
    }
    return !0
}
function cureLocalIntersections(e, t, r) {
    var i = e;
    do {
        var n = i.prev
          , a = i.next.next;
        !equals(n, a) && intersects(n, i, i.next, a) && locallyInside(n, a) && locallyInside(a, n) && (t.push(n.i / r),
        t.push(i.i / r),
        t.push(a.i / r),
        removeNode(i),
        removeNode(i.next),
        i = e = a),
        i = i.next
    } while (i !== e);
    return filterPoints(i)
}
function splitEarcut(e, t, r, i, n, a) {
    var o = e;
    do {
        for (var s = o.next.next; s !== o.prev; ) {
            if (o.i !== s.i && isValidDiagonal(o, s)) {
                var l = splitPolygon(o, s);
                return o = filterPoints(o, o.next),
                l = filterPoints(l, l.next),
                earcutLinked(o, t, r, i, n, a),
                void earcutLinked(l, t, r, i, n, a)
            }
            s = s.next
        }
        o = o.next
    } while (o !== e)
}
function eliminateHoles(e, t, r, i) {
    var n, a, o, s = [];
    for (n = 0,
    a = t.length; n < a; n++)
        (o = linkedList(e, t[n] * i, n < a - 1 ? t[n + 1] * i : e.length, i, !1)) === o.next && (o.steiner = !0),
        s.push(getLeftmost(o));
    for (s.sort(compareX),
    n = 0; n < s.length; n++)
        eliminateHole(s[n], r),
        r = filterPoints(r, r.next);
    return r
}
function compareX(e, t) {
    return e.x - t.x
}
function eliminateHole(e, t) {
    if (t = findHoleBridge(e, t)) {
        var r = splitPolygon(t, e);
        filterPoints(t, t.next),
        filterPoints(r, r.next)
    }
}
function findHoleBridge(e, t) {
    var r, i = t, n = e.x, a = e.y, o = -1 / 0;
    do {
        if (a <= i.y && a >= i.next.y && i.next.y !== i.y) {
            var s = i.x + (a - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
            if (s <= n && s > o) {
                if (o = s,
                s === n) {
                    if (a === i.y)
                        return i;
                    if (a === i.next.y)
                        return i.next
                }
                r = i.x < i.next.x ? i : i.next
            }
        }
        i = i.next
    } while (i !== t);
    if (!r)
        return null;
    if (n === o)
        return r;
    var l, u = r, c = r.x, h = r.y, d = 1 / 0;
    i = r;
    do {
        n >= i.x && i.x >= c && n !== i.x && pointInTriangle(a < h ? n : o, a, c, h, a < h ? o : n, a, i.x, i.y) && (l = Math.abs(a - i.y) / (n - i.x),
        locallyInside(i, e) && (l < d || l === d && (i.x > r.x || i.x === r.x && sectorContainsSector(r, i))) && (r = i,
        d = l)),
        i = i.next
    } while (i !== u);
    return r
}
function sectorContainsSector(e, t) {
    return area(e.prev, e, t.prev) < 0 && area(t.next, e, e.next) < 0
}
function indexCurve(e, t, r, i) {
    var n = e;
    do {
        null === n.z && (n.z = zOrder(n.x, n.y, t, r, i)),
        n.prevZ = n.prev,
        n.nextZ = n.next,
        n = n.next
    } while (n !== e);
    n.prevZ.nextZ = null,
    n.prevZ = null,
    sortLinked(n)
}
function sortLinked(e) {
    var t, r, i, n, a, o, s, l, u = 1;
    do {
        for (r = e,
        e = null,
        a = null,
        o = 0; r; ) {
            for (o++,
            i = r,
            s = 0,
            t = 0; t < u && (s++,
            i = i.nextZ); t++)
                ;
            for (l = u; s > 0 || l > 0 && i; )
                0 !== s && (0 === l || !i || r.z <= i.z) ? (n = r,
                r = r.nextZ,
                s--) : (n = i,
                i = i.nextZ,
                l--),
                a ? a.nextZ = n : e = n,
                n.prevZ = a,
                a = n;
            r = i
        }
        a.nextZ = null,
        u *= 2
    } while (o > 1);
    return e
}
function zOrder(e, t, r, i, n) {
    return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - r) * n) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) * n) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
}
function getLeftmost(e) {
    var t = e
      , r = e;
    do {
        (t.x < r.x || t.x === r.x && t.y < r.y) && (r = t),
        t = t.next
    } while (t !== e);
    return r
}
function pointInTriangle(e, t, r, i, n, a, o, s) {
    return (n - o) * (t - s) - (e - o) * (a - s) >= 0 && (e - o) * (i - s) - (r - o) * (t - s) >= 0 && (r - o) * (a - s) - (n - o) * (i - s) >= 0
}
function isValidDiagonal(e, t) {
    return e.next.i !== t.i && e.prev.i !== t.i && !intersectsPolygon(e, t) && (locallyInside(e, t) && locallyInside(t, e) && middleInside(e, t) && (area(e.prev, e, t.prev) || area(e, t.prev, t)) || equals(e, t) && area(e.prev, e, e.next) > 0 && area(t.prev, t, t.next) > 0)
}
function area(e, t, r) {
    return (t.y - e.y) * (r.x - t.x) - (t.x - e.x) * (r.y - t.y)
}
function equals(e, t) {
    return e.x === t.x && e.y === t.y
}
function intersects(e, t, r, i) {
    var n = sign(area(e, t, r))
      , a = sign(area(e, t, i))
      , o = sign(area(r, i, e))
      , s = sign(area(r, i, t));
    return n !== a && o !== s || !(0 !== n || !onSegment(e, r, t)) || !(0 !== a || !onSegment(e, i, t)) || !(0 !== o || !onSegment(r, e, i)) || !(0 !== s || !onSegment(r, t, i))
}
function onSegment(e, t, r) {
    return t.x <= Math.max(e.x, r.x) && t.x >= Math.min(e.x, r.x) && t.y <= Math.max(e.y, r.y) && t.y >= Math.min(e.y, r.y)
}
function sign(e) {
    return e > 0 ? 1 : e < 0 ? -1 : 0
}
function intersectsPolygon(e, t) {
    var r = e;
    do {
        if (r.i !== e.i && r.next.i !== e.i && r.i !== t.i && r.next.i !== t.i && intersects(r, r.next, e, t))
            return !0;
        r = r.next
    } while (r !== e);
    return !1
}
function locallyInside(e, t) {
    return area(e.prev, e, e.next) < 0 ? area(e, t, e.next) >= 0 && area(e, e.prev, t) >= 0 : area(e, t, e.prev) < 0 || area(e, e.next, t) < 0
}
function middleInside(e, t) {
    var r = e
      , i = !1
      , n = (e.x + t.x) / 2
      , a = (e.y + t.y) / 2;
    do {
        r.y > a != r.next.y > a && r.next.y !== r.y && n < (r.next.x - r.x) * (a - r.y) / (r.next.y - r.y) + r.x && (i = !i),
        r = r.next
    } while (r !== e);
    return i
}
function splitPolygon(e, t) {
    var r = new Node(e.i,e.x,e.y)
      , i = new Node(t.i,t.x,t.y)
      , n = e.next
      , a = t.prev;
    return e.next = t,
    t.prev = e,
    r.next = n,
    n.prev = r,
    i.next = r,
    r.prev = i,
    a.next = i,
    i.prev = a,
    i
}
function insertNode(e, t, r, i) {
    var n = new Node(e,t,r);
    return i ? (n.next = i.next,
    n.prev = i,
    i.next.prev = n,
    i.next = n) : (n.prev = n,
    n.next = n),
    n
}
function removeNode(e) {
    e.next.prev = e.prev,
    e.prev.next = e.next,
    e.prevZ && (e.prevZ.nextZ = e.nextZ),
    e.nextZ && (e.nextZ.prevZ = e.prevZ)
}
function Node(e, t, r) {
    this.i = e,
    this.x = t,
    this.y = r,
    this.prev = null,
    this.next = null,
    this.z = null,
    this.prevZ = null,
    this.nextZ = null,
    this.steiner = !1
}
function signedArea(e, t, r, i) {
    for (var n = 0, a = t, o = r - i; a < r; a += i)
        n += (e[o] - e[a]) * (e[a + 1] + e[o + 1]),
        o = a;
    return n
}
var ShapeUtils = function() {
    function e() {
        _classCallCheck(this, e)
    }
    return _createClass(e, null, [{
        key: "area",
        value: function(e) {
            for (var t = e.length, r = 0, i = t - 1, n = 0; n < t; i = n++)
                r += e[i].x * e[n].y - e[n].x * e[i].y;
            return .5 * r
        }
    }, {
        key: "isClockWise",
        value: function(t) {
            return e.area(t) < 0
        }
    }, {
        key: "triangulateShape",
        value: function(e, t) {
            var r = []
              , i = []
              , n = [];
            removeDupEndPts(e),
            addContour(r, e);
            var a = e.length;
            t.forEach(removeDupEndPts);
            for (var o = 0; o < t.length; o++)
                i.push(a),
                a += t[o].length,
                addContour(r, t[o]);
            for (var s = Earcut.triangulate(r, i), l = 0; l < s.length; l += 3)
                n.push(s.slice(l, l + 3));
            return n
        }
    }]),
    e
}();
function removeDupEndPts(e) {
    var t = e.length;
    t > 2 && e[t - 1].equals(e[0]) && e.pop()
}
function addContour(e, t) {
    for (var r = 0; r < t.length; r++)
        e.push(t[r].x),
        e.push(t[r].y)
}
var ExtrudeGeometry = function(e) {
    _inherits(r, BufferGeometry);
    var t = _createSuper(r);
    function r() {
        var e, i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Shape([new Vector2(.5,.5), new Vector2(-.5,.5), new Vector2(-.5,-.5), new Vector2(.5,-.5)]), n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        _classCallCheck(this, r),
        (e = t.call(this)).type = "ExtrudeGeometry",
        e.parameters = {
            shapes: i,
            options: n
        },
        i = Array.isArray(i) ? i : [i];
        for (var a = _assertThisInitialized(e), o = [], s = [], l = 0, u = i.length; l < u; l++) {
            var c = i[l];
            h(c)
        }
        function h(e) {
            var t = []
              , r = void 0 !== n.curveSegments ? n.curveSegments : 12
              , i = void 0 !== n.steps ? n.steps : 1
              , l = void 0 !== n.depth ? n.depth : 1
              , u = void 0 === n.bevelEnabled || n.bevelEnabled
              , c = void 0 !== n.bevelThickness ? n.bevelThickness : .2
              , h = void 0 !== n.bevelSize ? n.bevelSize : c - .1
              , d = void 0 !== n.bevelOffset ? n.bevelOffset : 0
              , p = void 0 !== n.bevelSegments ? n.bevelSegments : 3
              , f = n.extrudePath
              , m = void 0 !== n.UVGenerator ? n.UVGenerator : WorldUVGenerator;
            void 0 !== n.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),
            l = n.amount);
            var v, g, _, y, x, b = !1;
            f && (v = f.getSpacedPoints(i),
            b = !0,
            u = !1,
            g = f.computeFrenetFrames(i, !1),
            _ = new Vector3,
            y = new Vector3,
            x = new Vector3),
            u || (p = 0,
            c = 0,
            h = 0,
            d = 0);
            var S = e.extractPoints(r)
              , w = S.shape
              , M = S.holes;
            if (!ShapeUtils.isClockWise(w)) {
                w = w.reverse();
                for (var T = 0, C = M.length; T < C; T++) {
                    var E = M[T];
                    ShapeUtils.isClockWise(E) && (M[T] = E.reverse())
                }
            }
            for (var P = ShapeUtils.triangulateShape(w, M), A = w, k = 0, L = M.length; k < L; k++) {
                var R = M[k];
                w = w.concat(R)
            }
            function D(e, t, r) {
                return t || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                t.clone().multiplyScalar(r).add(e)
            }
            var I = w.length
              , O = P.length;
            function N(e, t, r) {
                var i, n, a, o = e.x - t.x, s = e.y - t.y, l = r.x - e.x, u = r.y - e.y, c = o * o + s * s, h = o * u - s * l;
                if (Math.abs(h) > Number.EPSILON) {
                    var d = Math.sqrt(c)
                      , p = Math.sqrt(l * l + u * u)
                      , f = t.x - s / d
                      , m = t.y + o / d
                      , v = ((r.x - u / p - f) * u - (r.y + l / p - m) * l) / (o * u - s * l)
                      , g = (i = f + o * v - e.x) * i + (n = m + s * v - e.y) * n;
                    if (g <= 2)
                        return new Vector2(i,n);
                    a = Math.sqrt(g / 2)
                } else {
                    var _ = !1;
                    o > Number.EPSILON ? l > Number.EPSILON && (_ = !0) : o < -Number.EPSILON ? l < -Number.EPSILON && (_ = !0) : Math.sign(s) === Math.sign(u) && (_ = !0),
                    _ ? (i = -s,
                    n = o,
                    a = Math.sqrt(c)) : (i = o,
                    n = s,
                    a = Math.sqrt(c / 2))
                }
                return new Vector2(i / a,n / a)
            }
            for (var F = [], B = 0, z = A.length, U = z - 1, V = B + 1; B < z; B++,
            U++,
            V++)
                U === z && (U = 0),
                V === z && (V = 0),
                F[B] = N(A[B], A[U], A[V]);
            for (var G, H = [], W = F.concat(), $ = 0, j = M.length; $ < j; $++) {
                var q = M[$];
                G = [];
                for (var X = 0, Y = q.length, K = Y - 1, Z = X + 1; X < Y; X++,
                K++,
                Z++)
                    K === Y && (K = 0),
                    Z === Y && (Z = 0),
                    G[X] = N(q[X], q[K], q[Z]);
                H.push(G),
                W = W.concat(G)
            }
            for (var J = 0; J < p; J++) {
                for (var Q = J / p, ee = c * Math.cos(Q * Math.PI / 2), te = h * Math.sin(Q * Math.PI / 2) + d, re = 0, ie = A.length; re < ie; re++) {
                    var ne = D(A[re], F[re], te);
                    Le(ne.x, ne.y, -ee)
                }
                for (var ae = 0, oe = M.length; ae < oe; ae++) {
                    var se = M[ae];
                    G = H[ae];
                    for (var le = 0, ue = se.length; le < ue; le++) {
                        var ce = D(se[le], G[le], te);
                        Le(ce.x, ce.y, -ee)
                    }
                }
            }
            for (var he = h + d, de = 0; de < I; de++) {
                var pe = u ? D(w[de], W[de], he) : w[de];
                b ? (y.copy(g.normals[0]).multiplyScalar(pe.x),
                _.copy(g.binormals[0]).multiplyScalar(pe.y),
                x.copy(v[0]).add(y).add(_),
                Le(x.x, x.y, x.z)) : Le(pe.x, pe.y, 0)
            }
            for (var fe = 1; fe <= i; fe++)
                for (var me = 0; me < I; me++) {
                    var ve = u ? D(w[me], W[me], he) : w[me];
                    b ? (y.copy(g.normals[fe]).multiplyScalar(ve.x),
                    _.copy(g.binormals[fe]).multiplyScalar(ve.y),
                    x.copy(v[fe]).add(y).add(_),
                    Le(x.x, x.y, x.z)) : Le(ve.x, ve.y, l / i * fe)
                }
            for (var ge = p - 1; ge >= 0; ge--) {
                for (var _e = ge / p, ye = c * Math.cos(_e * Math.PI / 2), xe = h * Math.sin(_e * Math.PI / 2) + d, be = 0, Se = A.length; be < Se; be++) {
                    var we = D(A[be], F[be], xe);
                    Le(we.x, we.y, l + ye)
                }
                for (var Me = 0, Te = M.length; Me < Te; Me++) {
                    var Ce = M[Me];
                    G = H[Me];
                    for (var Ee = 0, Pe = Ce.length; Ee < Pe; Ee++) {
                        var Ae = D(Ce[Ee], G[Ee], xe);
                        b ? Le(Ae.x, Ae.y + v[i - 1].y, v[i - 1].x + ye) : Le(Ae.x, Ae.y, l + ye)
                    }
                }
            }
            function ke(e, t) {
                for (var r = e.length; --r >= 0; ) {
                    var n = r
                      , a = r - 1;
                    a < 0 && (a = e.length - 1);
                    for (var o = 0, s = i + 2 * p; o < s; o++) {
                        var l = I * o
                          , u = I * (o + 1);
                        De(t + n + l, t + a + l, t + a + u, t + n + u)
                    }
                }
            }
            function Le(e, r, i) {
                t.push(e),
                t.push(r),
                t.push(i)
            }
            function Re(e, t, r) {
                Ie(e),
                Ie(t),
                Ie(r);
                var i = o.length / 3
                  , n = m.generateTopUV(a, o, i - 3, i - 2, i - 1);
                Oe(n[0]),
                Oe(n[1]),
                Oe(n[2])
            }
            function De(e, t, r, i) {
                Ie(e),
                Ie(t),
                Ie(i),
                Ie(t),
                Ie(r),
                Ie(i);
                var n = o.length / 3
                  , s = m.generateSideWallUV(a, o, n - 6, n - 3, n - 2, n - 1);
                Oe(s[0]),
                Oe(s[1]),
                Oe(s[3]),
                Oe(s[1]),
                Oe(s[2]),
                Oe(s[3])
            }
            function Ie(e) {
                o.push(t[3 * e + 0]),
                o.push(t[3 * e + 1]),
                o.push(t[3 * e + 2])
            }
            function Oe(e) {
                s.push(e.x),
                s.push(e.y)
            }
            !function() {
                var e = o.length / 3;
                if (u) {
                    for (var t = 0, r = I * t, n = 0; n < O; n++) {
                        var s = P[n];
                        Re(s[2] + r, s[1] + r, s[0] + r)
                    }
                    r = I * (t = i + 2 * p);
                    for (var l = 0; l < O; l++) {
                        var c = P[l];
                        Re(c[0] + r, c[1] + r, c[2] + r)
                    }
                } else {
                    for (var h = 0; h < O; h++) {
                        var d = P[h];
                        Re(d[2], d[1], d[0])
                    }
                    for (var f = 0; f < O; f++) {
                        var m = P[f];
                        Re(m[0] + I * i, m[1] + I * i, m[2] + I * i)
                    }
                }
                a.addGroup(e, o.length / 3 - e, 0)
            }(),
            function() {
                var e = o.length / 3
                  , t = 0;
                ke(A, t),
                t += A.length;
                for (var r = 0, i = M.length; r < i; r++) {
                    var n = M[r];
                    ke(n, t),
                    t += n.length
                }
                a.addGroup(e, o.length / 3 - e, 1)
            }()
        }
        return e.setAttribute("position", new Float32BufferAttribute(o,3)),
        e.setAttribute("uv", new Float32BufferAttribute(s,2)),
        e.computeVertexNormals(),
        e
    }
    return _createClass(r, [{
        key: "toJSON",
        value: function() {
            var e = _get(_getPrototypeOf(r.prototype), "toJSON", this).call(this);
            return toJSON$1(this.parameters.shapes, this.parameters.options, e)
        }
    }], [{
        key: "fromJSON",
        value: function(e, t) {
            for (var i = [], n = 0, a = e.shapes.length; n < a; n++) {
                var o = t[e.shapes[n]];
                i.push(o)
            }
            var s = e.options.extrudePath;
            return void 0 !== s && (e.options.extrudePath = (new Curves[s.type]).fromJSON(s)),
            new r(i,e.options)
        }
    }]),
    r
}()
  , WorldUVGenerator = {
    generateTopUV: function(e, t, r, i, n) {
        var a = t[3 * r]
          , o = t[3 * r + 1]
          , s = t[3 * i]
          , l = t[3 * i + 1]
          , u = t[3 * n]
          , c = t[3 * n + 1];
        return [new Vector2(a,o), new Vector2(s,l), new Vector2(u,c)]
    },
    generateSideWallUV: function(e, t, r, i, n, a) {
        var o = t[3 * r]
          , s = t[3 * r + 1]
          , l = t[3 * r + 2]
          , u = t[3 * i]
          , c = t[3 * i + 1]
          , h = t[3 * i + 2]
          , d = t[3 * n]
          , p = t[3 * n + 1]
          , f = t[3 * n + 2]
          , m = t[3 * a]
          , v = t[3 * a + 1]
          , g = t[3 * a + 2];
        return Math.abs(s - c) < Math.abs(o - u) ? [new Vector2(o,1 - l), new Vector2(u,1 - h), new Vector2(d,1 - f), new Vector2(m,1 - g)] : [new Vector2(s,1 - l), new Vector2(c,1 - h), new Vector2(p,1 - f), new Vector2(v,1 - g)]
    }
};
function toJSON$1(e, t, r) {
    if (r.shapes = [],
    Array.isArray(e))
        for (var i = 0, n = e.length; i < n; i++) {
            var a = e[i];
            r.shapes.push(a.uuid)
        }
    else
        r.shapes.push(e.uuid);
    return void 0 !== t.extrudePath && (r.options.extrudePath = t.extrudePath.toJSON()),
    r
}
var ShapeGeometry = function(e) {
    _inherits(r, BufferGeometry);
    var t = _createSuper(r);
    function r() {
        var e, i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Shape([new Vector2(0,.5), new Vector2(-.5,-.5), new Vector2(.5,-.5)]), n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 12;
        _classCallCheck(this, r),
        (e = t.call(this)).type = "ShapeGeometry",
        e.parameters = {
            shapes: i,
            curveSegments: n
        };
        var a = []
          , o = []
          , s = []
          , l = []
          , u = 0
          , c = 0;
        if (!1 === Array.isArray(i))
            d(i);
        else
            for (var h = 0; h < i.length; h++)
                d(i[h]),
                e.addGroup(u, c, h),
                u += c,
                c = 0;
        function d(e) {
            var t = o.length / 3
              , r = e.extractPoints(n)
              , i = r.shape
              , u = r.holes;
            !1 === ShapeUtils.isClockWise(i) && (i = i.reverse());
            for (var h = 0, d = u.length; h < d; h++) {
                var p = u[h];
                !0 === ShapeUtils.isClockWise(p) && (u[h] = p.reverse())
            }
            for (var f = ShapeUtils.triangulateShape(i, u), m = 0, v = u.length; m < v; m++) {
                var g = u[m];
                i = i.concat(g)
            }
            for (var _ = 0, y = i.length; _ < y; _++) {
                var x = i[_];
                o.push(x.x, x.y, 0),
                s.push(0, 0, 1),
                l.push(x.x, x.y)
            }
            for (var b = 0, S = f.length; b < S; b++) {
                var w = f[b]
                  , M = w[0] + t
                  , T = w[1] + t
                  , C = w[2] + t;
                a.push(M, T, C),
                c += 3
            }
        }
        return e.setIndex(a),
        e.setAttribute("position", new Float32BufferAttribute(o,3)),
        e.setAttribute("normal", new Float32BufferAttribute(s,3)),
        e.setAttribute("uv", new Float32BufferAttribute(l,2)),
        e
    }
    return _createClass(r, [{
        key: "toJSON",
        value: function() {
            var e = _get(_getPrototypeOf(r.prototype), "toJSON", this).call(this);
            return _toJSON(this.parameters.shapes, e)
        }
    }], [{
        key: "fromJSON",
        value: function(e, t) {
            for (var i = [], n = 0, a = e.shapes.length; n < a; n++) {
                var o = t[e.shapes[n]];
                i.push(o)
            }
            return new r(i,e.curveSegments)
        }
    }]),
    r
}();
function _toJSON(e, t) {
    if (t.shapes = [],
    Array.isArray(e))
        for (var r = 0, i = e.length; r < i; r++) {
            var n = e[r];
            t.shapes.push(n.uuid)
        }
    else
        t.shapes.push(e.uuid);
    return t
}
var ShadowMaterial = function(e) {
    _inherits(r, Material);
    var t = _createSuper(r);
    function r(e) {
        var i;
        return _classCallCheck(this, r),
        (i = t.call(this)).type = "ShadowMaterial",
        i.color = new Color(0),
        i.transparent = !0,
        i.setValues(e),
        i
    }
    return _createClass(r, [{
        key: "copy",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e),
            this.color.copy(e.color),
            this
        }
    }]),
    r
}();
ShadowMaterial.prototype.isShadowMaterial = !0;
var RawShaderMaterial = function(e) {
    _inherits(r, ShaderMaterial);
    var t = _createSuper(r);
    function r(e) {
        var i;
        return _classCallCheck(this, r),
        (i = t.call(this, e)).type = "RawShaderMaterial",
        i
    }
    return _createClass(r)
}();
RawShaderMaterial.prototype.isRawShaderMaterial = !0;
var MeshStandardMaterial = function(e) {
    _inherits(r, Material);
    var t = _createSuper(r);
    function r(e) {
        var i;
        return _classCallCheck(this, r),
        (i = t.call(this)).defines = {
            STANDARD: ""
        },
        i.type = "MeshStandardMaterial",
        i.color = new Color(16777215),
        i.roughness = 1,
        i.metalness = 0,
        i.map = null,
        i.lightMap = null,
        i.lightMapIntensity = 1,
        i.aoMap = null,
        i.aoMapIntensity = 1,
        i.emissive = new Color(0),
        i.emissiveIntensity = 1,
        i.emissiveMap = null,
        i.bumpMap = null,
        i.bumpScale = 1,
        i.normalMap = null,
        i.normalMapType = TangentSpaceNormalMap,
        i.normalScale = new Vector2(1,1),
        i.displacementMap = null,
        i.displacementScale = 1,
        i.displacementBias = 0,
        i.roughnessMap = null,
        i.metalnessMap = null,
        i.alphaMap = null,
        i.envMap = null,
        i.envMapIntensity = 1,
        i.wireframe = !1,
        i.wireframeLinewidth = 1,
        i.wireframeLinecap = "round",
        i.wireframeLinejoin = "round",
        i.flatShading = !1,
        i.setValues(e),
        i
    }
    return _createClass(r, [{
        key: "copy",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e),
            this.defines = {
                STANDARD: ""
            },
            this.color.copy(e.color),
            this.roughness = e.roughness,
            this.metalness = e.metalness,
            this.map = e.map,
            this.lightMap = e.lightMap,
            this.lightMapIntensity = e.lightMapIntensity,
            this.aoMap = e.aoMap,
            this.aoMapIntensity = e.aoMapIntensity,
            this.emissive.copy(e.emissive),
            this.emissiveMap = e.emissiveMap,
            this.emissiveIntensity = e.emissiveIntensity,
            this.bumpMap = e.bumpMap,
            this.bumpScale = e.bumpScale,
            this.normalMap = e.normalMap,
            this.normalMapType = e.normalMapType,
            this.normalScale.copy(e.normalScale),
            this.displacementMap = e.displacementMap,
            this.displacementScale = e.displacementScale,
            this.displacementBias = e.displacementBias,
            this.roughnessMap = e.roughnessMap,
            this.metalnessMap = e.metalnessMap,
            this.alphaMap = e.alphaMap,
            this.envMap = e.envMap,
            this.envMapIntensity = e.envMapIntensity,
            this.wireframe = e.wireframe,
            this.wireframeLinewidth = e.wireframeLinewidth,
            this.wireframeLinecap = e.wireframeLinecap,
            this.wireframeLinejoin = e.wireframeLinejoin,
            this.flatShading = e.flatShading,
            this
        }
    }]),
    r
}();
MeshStandardMaterial.prototype.isMeshStandardMaterial = !0;
var MeshPhysicalMaterial = function(e) {
    _inherits(r, MeshStandardMaterial);
    var t = _createSuper(r);
    function r(e) {
        var i;
        return _classCallCheck(this, r),
        (i = t.call(this)).defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        i.type = "MeshPhysicalMaterial",
        i.clearcoatMap = null,
        i.clearcoatRoughness = 0,
        i.clearcoatRoughnessMap = null,
        i.clearcoatNormalScale = new Vector2(1,1),
        i.clearcoatNormalMap = null,
        i.ior = 1.5,
        Object.defineProperty(_assertThisInitialized(i), "reflectivity", {
            get: function() {
                return clamp(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
            },
            set: function(e) {
                this.ior = (1 + .4 * e) / (1 - .4 * e)
            }
        }),
        i.sheenColor = new Color(0),
        i.sheenColorMap = null,
        i.sheenRoughness = 1,
        i.sheenRoughnessMap = null,
        i.transmissionMap = null,
        i.thickness = 0,
        i.thicknessMap = null,
        i.attenuationDistance = 0,
        i.attenuationColor = new Color(1,1,1),
        i.specularIntensity = 1,
        i.specularIntensityMap = null,
        i.specularColor = new Color(1,1,1),
        i.specularColorMap = null,
        i._sheen = 0,
        i._clearcoat = 0,
        i._transmission = 0,
        i.setValues(e),
        i
    }
    return _createClass(r, [{
        key: "sheen",
        get: function() {
            return this._sheen
        },
        set: function(e) {
            this._sheen > 0 != e > 0 && this.version++,
            this._sheen = e
        }
    }, {
        key: "clearcoat",
        get: function() {
            return this._clearcoat
        },
        set: function(e) {
            this._clearcoat > 0 != e > 0 && this.version++,
            this._clearcoat = e
        }
    }, {
        key: "transmission",
        get: function() {
            return this._transmission
        },
        set: function(e) {
            this._transmission > 0 != e > 0 && this.version++,
            this._transmission = e
        }
    }, {
        key: "copy",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e),
            this.defines = {
                STANDARD: "",
                PHYSICAL: ""
            },
            this.clearcoat = e.clearcoat,
            this.clearcoatMap = e.clearcoatMap,
            this.clearcoatRoughness = e.clearcoatRoughness,
            this.clearcoatRoughnessMap = e.clearcoatRoughnessMap,
            this.clearcoatNormalMap = e.clearcoatNormalMap,
            this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
            this.ior = e.ior,
            this.sheen = e.sheen,
            this.sheenColor.copy(e.sheenColor),
            this.sheenColorMap = e.sheenColorMap,
            this.sheenRoughness = e.sheenRoughness,
            this.sheenRoughnessMap = e.sheenRoughnessMap,
            this.transmission = e.transmission,
            this.transmissionMap = e.transmissionMap,
            this.thickness = e.thickness,
            this.thicknessMap = e.thicknessMap,
            this.attenuationDistance = e.attenuationDistance,
            this.attenuationColor.copy(e.attenuationColor),
            this.specularIntensity = e.specularIntensity,
            this.specularIntensityMap = e.specularIntensityMap,
            this.specularColor.copy(e.specularColor),
            this.specularColorMap = e.specularColorMap,
            this
        }
    }]),
    r
}();
MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = !0;
var MeshPhongMaterial = function(e) {
    _inherits(r, Material);
    var t = _createSuper(r);
    function r(e) {
        var i;
        return _classCallCheck(this, r),
        (i = t.call(this)).type = "MeshPhongMaterial",
        i.color = new Color(16777215),
        i.specular = new Color(1118481),
        i.shininess = 30,
        i.map = null,
        i.lightMap = null,
        i.lightMapIntensity = 1,
        i.aoMap = null,
        i.aoMapIntensity = 1,
        i.emissive = new Color(0),
        i.emissiveIntensity = 1,
        i.emissiveMap = null,
        i.bumpMap = null,
        i.bumpScale = 1,
        i.normalMap = null,
        i.normalMapType = TangentSpaceNormalMap,
        i.normalScale = new Vector2(1,1),
        i.displacementMap = null,
        i.displacementScale = 1,
        i.displacementBias = 0,
        i.specularMap = null,
        i.alphaMap = null,
        i.envMap = null,
        i.combine = MultiplyOperation,
        i.reflectivity = 1,
        i.refractionRatio = .98,
        i.wireframe = !1,
        i.wireframeLinewidth = 1,
        i.wireframeLinecap = "round",
        i.wireframeLinejoin = "round",
        i.flatShading = !1,
        i.setValues(e),
        i
    }
    return _createClass(r, [{
        key: "copy",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e),
            this.color.copy(e.color),
            this.specular.copy(e.specular),
            this.shininess = e.shininess,
            this.map = e.map,
            this.lightMap = e.lightMap,
            this.lightMapIntensity = e.lightMapIntensity,
            this.aoMap = e.aoMap,
            this.aoMapIntensity = e.aoMapIntensity,
            this.emissive.copy(e.emissive),
            this.emissiveMap = e.emissiveMap,
            this.emissiveIntensity = e.emissiveIntensity,
            this.bumpMap = e.bumpMap,
            this.bumpScale = e.bumpScale,
            this.normalMap = e.normalMap,
            this.normalMapType = e.normalMapType,
            this.normalScale.copy(e.normalScale),
            this.displacementMap = e.displacementMap,
            this.displacementScale = e.displacementScale,
            this.displacementBias = e.displacementBias,
            this.specularMap = e.specularMap,
            this.alphaMap = e.alphaMap,
            this.envMap = e.envMap,
            this.combine = e.combine,
            this.reflectivity = e.reflectivity,
            this.refractionRatio = e.refractionRatio,
            this.wireframe = e.wireframe,
            this.wireframeLinewidth = e.wireframeLinewidth,
            this.wireframeLinecap = e.wireframeLinecap,
            this.wireframeLinejoin = e.wireframeLinejoin,
            this.flatShading = e.flatShading,
            this
        }
    }]),
    r
}();
MeshPhongMaterial.prototype.isMeshPhongMaterial = !0;
var MeshToonMaterial = function(e) {
    _inherits(r, Material);
    var t = _createSuper(r);
    function r(e) {
        var i;
        return _classCallCheck(this, r),
        (i = t.call(this)).defines = {
            TOON: ""
        },
        i.type = "MeshToonMaterial",
        i.color = new Color(16777215),
        i.map = null,
        i.gradientMap = null,
        i.lightMap = null,
        i.lightMapIntensity = 1,
        i.aoMap = null,
        i.aoMapIntensity = 1,
        i.emissive = new Color(0),
        i.emissiveIntensity = 1,
        i.emissiveMap = null,
        i.bumpMap = null,
        i.bumpScale = 1,
        i.normalMap = null,
        i.normalMapType = TangentSpaceNormalMap,
        i.normalScale = new Vector2(1,1),
        i.displacementMap = null,
        i.displacementScale = 1,
        i.displacementBias = 0,
        i.alphaMap = null,
        i.wireframe = !1,
        i.wireframeLinewidth = 1,
        i.wireframeLinecap = "round",
        i.wireframeLinejoin = "round",
        i.setValues(e),
        i
    }
    return _createClass(r, [{
        key: "copy",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e),
            this.color.copy(e.color),
            this.map = e.map,
            this.gradientMap = e.gradientMap,
            this.lightMap = e.lightMap,
            this.lightMapIntensity = e.lightMapIntensity,
            this.aoMap = e.aoMap,
            this.aoMapIntensity = e.aoMapIntensity,
            this.emissive.copy(e.emissive),
            this.emissiveMap = e.emissiveMap,
            this.emissiveIntensity = e.emissiveIntensity,
            this.bumpMap = e.bumpMap,
            this.bumpScale = e.bumpScale,
            this.normalMap = e.normalMap,
            this.normalMapType = e.normalMapType,
            this.normalScale.copy(e.normalScale),
            this.displacementMap = e.displacementMap,
            this.displacementScale = e.displacementScale,
            this.displacementBias = e.displacementBias,
            this.alphaMap = e.alphaMap,
            this.wireframe = e.wireframe,
            this.wireframeLinewidth = e.wireframeLinewidth,
            this.wireframeLinecap = e.wireframeLinecap,
            this.wireframeLinejoin = e.wireframeLinejoin,
            this
        }
    }]),
    r
}();
MeshToonMaterial.prototype.isMeshToonMaterial = !0;
var MeshNormalMaterial = function(e) {
    _inherits(r, Material);
    var t = _createSuper(r);
    function r(e) {
        var i;
        return _classCallCheck(this, r),
        (i = t.call(this)).type = "MeshNormalMaterial",
        i.bumpMap = null,
        i.bumpScale = 1,
        i.normalMap = null,
        i.normalMapType = TangentSpaceNormalMap,
        i.normalScale = new Vector2(1,1),
        i.displacementMap = null,
        i.displacementScale = 1,
        i.displacementBias = 0,
        i.wireframe = !1,
        i.wireframeLinewidth = 1,
        i.fog = !1,
        i.flatShading = !1,
        i.setValues(e),
        i
    }
    return _createClass(r, [{
        key: "copy",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e),
            this.bumpMap = e.bumpMap,
            this.bumpScale = e.bumpScale,
            this.normalMap = e.normalMap,
            this.normalMapType = e.normalMapType,
            this.normalScale.copy(e.normalScale),
            this.displacementMap = e.displacementMap,
            this.displacementScale = e.displacementScale,
            this.displacementBias = e.displacementBias,
            this.wireframe = e.wireframe,
            this.wireframeLinewidth = e.wireframeLinewidth,
            this.flatShading = e.flatShading,
            this
        }
    }]),
    r
}();
MeshNormalMaterial.prototype.isMeshNormalMaterial = !0;
var MeshLambertMaterial = function(e) {
    _inherits(r, Material);
    var t = _createSuper(r);
    function r(e) {
        var i;
        return _classCallCheck(this, r),
        (i = t.call(this)).type = "MeshLambertMaterial",
        i.color = new Color(16777215),
        i.map = null,
        i.lightMap = null,
        i.lightMapIntensity = 1,
        i.aoMap = null,
        i.aoMapIntensity = 1,
        i.emissive = new Color(0),
        i.emissiveIntensity = 1,
        i.emissiveMap = null,
        i.specularMap = null,
        i.alphaMap = null,
        i.envMap = null,
        i.combine = MultiplyOperation,
        i.reflectivity = 1,
        i.refractionRatio = .98,
        i.wireframe = !1,
        i.wireframeLinewidth = 1,
        i.wireframeLinecap = "round",
        i.wireframeLinejoin = "round",
        i.setValues(e),
        i
    }
    return _createClass(r, [{
        key: "copy",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e),
            this.color.copy(e.color),
            this.map = e.map,
            this.lightMap = e.lightMap,
            this.lightMapIntensity = e.lightMapIntensity,
            this.aoMap = e.aoMap,
            this.aoMapIntensity = e.aoMapIntensity,
            this.emissive.copy(e.emissive),
            this.emissiveMap = e.emissiveMap,
            this.emissiveIntensity = e.emissiveIntensity,
            this.specularMap = e.specularMap,
            this.alphaMap = e.alphaMap,
            this.envMap = e.envMap,
            this.combine = e.combine,
            this.reflectivity = e.reflectivity,
            this.refractionRatio = e.refractionRatio,
            this.wireframe = e.wireframe,
            this.wireframeLinewidth = e.wireframeLinewidth,
            this.wireframeLinecap = e.wireframeLinecap,
            this.wireframeLinejoin = e.wireframeLinejoin,
            this
        }
    }]),
    r
}();
MeshLambertMaterial.prototype.isMeshLambertMaterial = !0;
var MeshMatcapMaterial = function(e) {
    _inherits(r, Material);
    var t = _createSuper(r);
    function r(e) {
        var i;
        return _classCallCheck(this, r),
        (i = t.call(this)).defines = {
            MATCAP: ""
        },
        i.type = "MeshMatcapMaterial",
        i.color = new Color(16777215),
        i.matcap = null,
        i.map = null,
        i.bumpMap = null,
        i.bumpScale = 1,
        i.normalMap = null,
        i.normalMapType = TangentSpaceNormalMap,
        i.normalScale = new Vector2(1,1),
        i.displacementMap = null,
        i.displacementScale = 1,
        i.displacementBias = 0,
        i.alphaMap = null,
        i.flatShading = !1,
        i.setValues(e),
        i
    }
    return _createClass(r, [{
        key: "copy",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e),
            this.defines = {
                MATCAP: ""
            },
            this.color.copy(e.color),
            this.matcap = e.matcap,
            this.map = e.map,
            this.bumpMap = e.bumpMap,
            this.bumpScale = e.bumpScale,
            this.normalMap = e.normalMap,
            this.normalMapType = e.normalMapType,
            this.normalScale.copy(e.normalScale),
            this.displacementMap = e.displacementMap,
            this.displacementScale = e.displacementScale,
            this.displacementBias = e.displacementBias,
            this.alphaMap = e.alphaMap,
            this.flatShading = e.flatShading,
            this
        }
    }]),
    r
}();
MeshMatcapMaterial.prototype.isMeshMatcapMaterial = !0;
var LineDashedMaterial = function(e) {
    _inherits(r, LineBasicMaterial);
    var t = _createSuper(r);
    function r(e) {
        var i;
        return _classCallCheck(this, r),
        (i = t.call(this)).type = "LineDashedMaterial",
        i.scale = 1,
        i.dashSize = 3,
        i.gapSize = 1,
        i.setValues(e),
        i
    }
    return _createClass(r, [{
        key: "copy",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e),
            this.scale = e.scale,
            this.dashSize = e.dashSize,
            this.gapSize = e.gapSize,
            this
        }
    }]),
    r
}();
LineDashedMaterial.prototype.isLineDashedMaterial = !0;
var materialLib = {
    ShadowMaterial,
    SpriteMaterial,
    RawShaderMaterial,
    ShaderMaterial,
    PointsMaterial,
    MeshPhysicalMaterial,
    MeshStandardMaterial,
    MeshPhongMaterial,
    MeshToonMaterial,
    MeshNormalMaterial,
    MeshLambertMaterial,
    MeshDepthMaterial,
    MeshDistanceMaterial,
    MeshBasicMaterial,
    MeshMatcapMaterial,
    LineDashedMaterial,
    LineBasicMaterial,
    Material
};
Material.fromType = function(e) {
    return new materialLib[e]
}
;
var AnimationUtils = {
    arraySlice: function(e, t, r) {
        return AnimationUtils.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== r ? r : e.length)) : e.slice(t, r)
    },
    convertArray: function(e, t, r) {
        return !e || !r && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
    },
    isTypedArray: function(e) {
        return ArrayBuffer.isView(e) && !(e instanceof DataView)
    },
    getKeyframeOrder: function(e) {
        for (var t = e.length, r = new Array(t), i = 0; i !== t; ++i)
            r[i] = i;
        return r.sort((function(t, r) {
            return e[t] - e[r]
        }
        )),
        r
    },
    sortedArray: function(e, t, r) {
        for (var i = e.length, n = new e.constructor(i), a = 0, o = 0; o !== i; ++a)
            for (var s = r[a] * t, l = 0; l !== t; ++l)
                n[o++] = e[s + l];
        return n
    },
    flattenJSON: function(e, t, r, i) {
        for (var n = 1, a = e[0]; void 0 !== a && void 0 === a[i]; )
            a = e[n++];
        if (void 0 !== a) {
            var o = a[i];
            if (void 0 !== o)
                if (Array.isArray(o))
                    do {
                        void 0 !== (o = a[i]) && (t.push(a.time),
                        r.push.apply(r, o)),
                        a = e[n++]
                    } while (void 0 !== a);
                else if (void 0 !== o.toArray)
                    do {
                        void 0 !== (o = a[i]) && (t.push(a.time),
                        o.toArray(r, r.length)),
                        a = e[n++]
                    } while (void 0 !== a);
                else
                    do {
                        void 0 !== (o = a[i]) && (t.push(a.time),
                        r.push(o)),
                        a = e[n++]
                    } while (void 0 !== a)
        }
    },
    subclip: function(e, t, r, i) {
        var n = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 30
          , a = e.clone();
        a.name = t;
        for (var o = [], s = 0; s < a.tracks.length; ++s) {
            for (var l = a.tracks[s], u = l.getValueSize(), c = [], h = [], d = 0; d < l.times.length; ++d) {
                var p = l.times[d] * n;
                if (!(p < r || p >= i)) {
                    c.push(l.times[d]);
                    for (var f = 0; f < u; ++f)
                        h.push(l.values[d * u + f])
                }
            }
            0 !== c.length && (l.times = AnimationUtils.convertArray(c, l.times.constructor),
            l.values = AnimationUtils.convertArray(h, l.values.constructor),
            o.push(l))
        }
        a.tracks = o;
        for (var m = 1 / 0, v = 0; v < a.tracks.length; ++v)
            m > a.tracks[v].times[0] && (m = a.tracks[v].times[0]);
        for (var g = 0; g < a.tracks.length; ++g)
            a.tracks[g].shift(-1 * m);
        return a.resetDuration(),
        a
    },
    makeClipAdditive: function(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
          , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e
          , i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 30;
        i <= 0 && (i = 30);
        for (var n = r.tracks.length, a = t / i, o = function(t) {
            var i = r.tracks[t]
              , n = i.ValueTypeName;
            if ("bool" === n || "string" === n)
                return "continue";
            var o = e.tracks.find((function(e) {
                return e.name === i.name && e.ValueTypeName === n
            }
            ));
            if (void 0 === o)
                return "continue";
            var s = 0
              , l = i.getValueSize();
            i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (s = l / 3);
            var u = 0
              , c = o.getValueSize();
            o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (u = c / 3);
            var h = i.times.length - 1
              , d = void 0;
            if (a <= i.times[0]) {
                var p = s
                  , f = l - s;
                d = AnimationUtils.arraySlice(i.values, p, f)
            } else if (a >= i.times[h]) {
                var m = h * l + s
                  , v = m + l - s;
                d = AnimationUtils.arraySlice(i.values, m, v)
            } else {
                var g = i.createInterpolant()
                  , _ = s
                  , y = l - s;
                g.evaluate(a),
                d = AnimationUtils.arraySlice(g.resultBuffer, _, y)
            }
            "quaternion" === n && (new Quaternion).fromArray(d).normalize().conjugate().toArray(d);
            for (var x = o.times.length, b = 0; b < x; ++b) {
                var S = b * c + u;
                if ("quaternion" === n)
                    Quaternion.multiplyQuaternionsFlat(o.values, S, d, 0, o.values, S);
                else
                    for (var w = c - 2 * u, M = 0; M < w; ++M)
                        o.values[S + M] -= d[M]
            }
        }, s = 0; s < n; ++s)
            o(s);
        return e.blendMode = AdditiveAnimationBlendMode,
        e
    }
}
  , Interpolant = function() {
    function e(t, r, i, n) {
        _classCallCheck(this, e),
        this.parameterPositions = t,
        this._cachedIndex = 0,
        this.resultBuffer = void 0 !== n ? n : new r.constructor(i),
        this.sampleValues = r,
        this.valueSize = i,
        this.settings = null,
        this.DefaultSettings_ = {}
    }
    return _createClass(e, [{
        key: "evaluate",
        value: function(e) {
            var t = this.parameterPositions
              , r = this._cachedIndex
              , i = t[r]
              , n = t[r - 1];
            e: {
                t: {
                    var a;
                    r: {
                        i: if (!(e < i)) {
                            for (var o = r + 2; ; ) {
                                if (void 0 === i) {
                                    if (e < n)
                                        break i;
                                    return r = t.length,
                                    this._cachedIndex = r,
                                    this.afterEnd_(r - 1, e, n)
                                }
                                if (r === o)
                                    break;
                                if (n = i,
                                e < (i = t[++r]))
                                    break t
                            }
                            a = t.length;
                            break r
                        }
                        if (e >= n)
                            break e;
                        var s = t[1];
                        e < s && (r = 2,
                        n = s);
                        for (var l = r - 2; ; ) {
                            if (void 0 === n)
                                return this._cachedIndex = 0,
                                this.beforeStart_(0, e, i);
                            if (r === l)
                                break;
                            if (i = n,
                            e >= (n = t[--r - 1]))
                                break t
                        }
                        a = r,
                        r = 0
                    }
                    for (; r < a; ) {
                        var u = r + a >>> 1;
                        e < t[u] ? a = u : r = u + 1
                    }
                    if (i = t[r],
                    void 0 === (n = t[r - 1]))
                        return this._cachedIndex = 0,
                        this.beforeStart_(0, e, i);
                    if (void 0 === i)
                        return r = t.length,
                        this._cachedIndex = r,
                        this.afterEnd_(r - 1, n, e)
                }
                this._cachedIndex = r,
                this.intervalChanged_(r, n, i)
            }
            return this.interpolate_(r, n, e, i)
        }
    }, {
        key: "getSettings_",
        value: function() {
            return this.settings || this.DefaultSettings_
        }
    }, {
        key: "copySampleValue_",
        value: function(e) {
            for (var t = this.resultBuffer, r = this.sampleValues, i = this.valueSize, n = e * i, a = 0; a !== i; ++a)
                t[a] = r[n + a];
            return t
        }
    }, {
        key: "interpolate_",
        value: function() {
            throw new Error("call to abstract method")
        }
    }, {
        key: "intervalChanged_",
        value: function() {}
    }]),
    e
}();
Interpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_,
Interpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;
var CubicInterpolant = function(e) {
    _inherits(r, Interpolant);
    var t = _createSuper(r);
    function r(e, i, n, a) {
        var o;
        return _classCallCheck(this, r),
        (o = t.call(this, e, i, n, a))._weightPrev = -0,
        o._offsetPrev = -0,
        o._weightNext = -0,
        o._offsetNext = -0,
        o.DefaultSettings_ = {
            endingStart: ZeroCurvatureEnding,
            endingEnd: ZeroCurvatureEnding
        },
        o
    }
    return _createClass(r, [{
        key: "intervalChanged_",
        value: function(e, t, r) {
            var i = this.parameterPositions
              , n = e - 2
              , a = e + 1
              , o = i[n]
              , s = i[a];
            if (void 0 === o)
                switch (this.getSettings_().endingStart) {
                case ZeroSlopeEnding:
                    n = e,
                    o = 2 * t - r;
                    break;
                case WrapAroundEnding:
                    o = t + i[n = i.length - 2] - i[n + 1];
                    break;
                default:
                    n = e,
                    o = r
                }
            if (void 0 === s)
                switch (this.getSettings_().endingEnd) {
                case ZeroSlopeEnding:
                    a = e,
                    s = 2 * r - t;
                    break;
                case WrapAroundEnding:
                    a = 1,
                    s = r + i[1] - i[0];
                    break;
                default:
                    a = e - 1,
                    s = t
                }
            var l = .5 * (r - t)
              , u = this.valueSize;
            this._weightPrev = l / (t - o),
            this._weightNext = l / (s - r),
            this._offsetPrev = n * u,
            this._offsetNext = a * u
        }
    }, {
        key: "interpolate_",
        value: function(e, t, r, i) {
            for (var n = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = e * o, l = s - o, u = this._offsetPrev, c = this._offsetNext, h = this._weightPrev, d = this._weightNext, p = (r - t) / (i - t), f = p * p, m = f * p, v = -h * m + 2 * h * f - h * p, g = (1 + h) * m + (-1.5 - 2 * h) * f + (-.5 + h) * p + 1, _ = (-1 - d) * m + (1.5 + d) * f + .5 * p, y = d * m - d * f, x = 0; x !== o; ++x)
                n[x] = v * a[u + x] + g * a[l + x] + _ * a[s + x] + y * a[c + x];
            return n
        }
    }]),
    r
}()
  , LinearInterpolant = function(e) {
    _inherits(r, Interpolant);
    var t = _createSuper(r);
    function r(e, i, n, a) {
        return _classCallCheck(this, r),
        t.call(this, e, i, n, a)
    }
    return _createClass(r, [{
        key: "interpolate_",
        value: function(e, t, r, i) {
            for (var n = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = e * o, l = s - o, u = (r - t) / (i - t), c = 1 - u, h = 0; h !== o; ++h)
                n[h] = a[l + h] * c + a[s + h] * u;
            return n
        }
    }]),
    r
}()
  , DiscreteInterpolant = function(e) {
    _inherits(r, Interpolant);
    var t = _createSuper(r);
    function r(e, i, n, a) {
        return _classCallCheck(this, r),
        t.call(this, e, i, n, a)
    }
    return _createClass(r, [{
        key: "interpolate_",
        value: function(e) {
            return this.copySampleValue_(e - 1)
        }
    }]),
    r
}()
  , KeyframeTrack = function() {
    function e(t, r, i, n) {
        if (_classCallCheck(this, e),
        void 0 === t)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (void 0 === r || 0 === r.length)
            throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
        this.name = t,
        this.times = AnimationUtils.convertArray(r, this.TimeBufferType),
        this.values = AnimationUtils.convertArray(i, this.ValueBufferType),
        this.setInterpolation(n || this.DefaultInterpolation)
    }
    return _createClass(e, [{
        key: "InterpolantFactoryMethodDiscrete",
        value: function(e) {
            return new DiscreteInterpolant(this.times,this.values,this.getValueSize(),e)
        }
    }, {
        key: "InterpolantFactoryMethodLinear",
        value: function(e) {
            return new LinearInterpolant(this.times,this.values,this.getValueSize(),e)
        }
    }, {
        key: "InterpolantFactoryMethodSmooth",
        value: function(e) {
            return new CubicInterpolant(this.times,this.values,this.getValueSize(),e)
        }
    }, {
        key: "setInterpolation",
        value: function(e) {
            var t;
            switch (e) {
            case InterpolateDiscrete:
                t = this.InterpolantFactoryMethodDiscrete;
                break;
            case InterpolateLinear:
                t = this.InterpolantFactoryMethodLinear;
                break;
            case InterpolateSmooth:
                t = this.InterpolantFactoryMethodSmooth
            }
            if (void 0 === t) {
                var r = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                if (void 0 === this.createInterpolant) {
                    if (e === this.DefaultInterpolation)
                        throw new Error(r);
                    this.setInterpolation(this.DefaultInterpolation)
                }
                return console.warn("THREE.KeyframeTrack:", r),
                this
            }
            return this.createInterpolant = t,
            this
        }
    }, {
        key: "getInterpolation",
        value: function() {
            switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
                return InterpolateDiscrete;
            case this.InterpolantFactoryMethodLinear:
                return InterpolateLinear;
            case this.InterpolantFactoryMethodSmooth:
                return InterpolateSmooth
            }
        }
    }, {
        key: "getValueSize",
        value: function() {
            return this.values.length / this.times.length
        }
    }, {
        key: "shift",
        value: function(e) {
            if (0 !== e)
                for (var t = this.times, r = 0, i = t.length; r !== i; ++r)
                    t[r] += e;
            return this
        }
    }, {
        key: "scale",
        value: function(e) {
            if (1 !== e)
                for (var t = this.times, r = 0, i = t.length; r !== i; ++r)
                    t[r] *= e;
            return this
        }
    }, {
        key: "trim",
        value: function(e, t) {
            for (var r = this.times, i = r.length, n = 0, a = i - 1; n !== i && r[n] < e; )
                ++n;
            for (; -1 !== a && r[a] > t; )
                --a;
            if (++a,
            0 !== n || a !== i) {
                n >= a && (n = (a = Math.max(a, 1)) - 1);
                var o = this.getValueSize();
                this.times = AnimationUtils.arraySlice(r, n, a),
                this.values = AnimationUtils.arraySlice(this.values, n * o, a * o)
            }
            return this
        }
    }, {
        key: "validate",
        value: function() {
            var e = !0
              , t = this.getValueSize();
            t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
            e = !1);
            var r = this.times
              , i = this.values
              , n = r.length;
            0 === n && (console.error("THREE.KeyframeTrack: Track is empty.", this),
            e = !1);
            for (var a = null, o = 0; o !== n; o++) {
                var s = r[o];
                if ("number" == typeof s && isNaN(s)) {
                    console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, s),
                    e = !1;
                    break
                }
                if (null !== a && a > s) {
                    console.error("THREE.KeyframeTrack: Out of order keys.", this, o, s, a),
                    e = !1;
                    break
                }
                a = s
            }
            if (void 0 !== i && AnimationUtils.isTypedArray(i))
                for (var l = 0, u = i.length; l !== u; ++l) {
                    var c = i[l];
                    if (isNaN(c)) {
                        console.error("THREE.KeyframeTrack: Value is not a valid number.", this, l, c),
                        e = !1;
                        break
                    }
                }
            return e
        }
    }, {
        key: "optimize",
        value: function() {
            for (var e = AnimationUtils.arraySlice(this.times), t = AnimationUtils.arraySlice(this.values), r = this.getValueSize(), i = this.getInterpolation() === InterpolateSmooth, n = e.length - 1, a = 1, o = 1; o < n; ++o) {
                var s = !1
                  , l = e[o];
                if (l !== e[o + 1] && (1 !== o || l !== e[0]))
                    if (i)
                        s = !0;
                    else
                        for (var u = o * r, c = u - r, h = u + r, d = 0; d !== r; ++d) {
                            var p = t[u + d];
                            if (p !== t[c + d] || p !== t[h + d]) {
                                s = !0;
                                break
                            }
                        }
                if (s) {
                    if (o !== a) {
                        e[a] = e[o];
                        for (var f = o * r, m = a * r, v = 0; v !== r; ++v)
                            t[m + v] = t[f + v]
                    }
                    ++a
                }
            }
            if (n > 0) {
                e[a] = e[n];
                for (var g = n * r, _ = a * r, y = 0; y !== r; ++y)
                    t[_ + y] = t[g + y];
                ++a
            }
            return a !== e.length ? (this.times = AnimationUtils.arraySlice(e, 0, a),
            this.values = AnimationUtils.arraySlice(t, 0, a * r)) : (this.times = e,
            this.values = t),
            this
        }
    }, {
        key: "clone",
        value: function() {
            var e = AnimationUtils.arraySlice(this.times, 0)
              , t = AnimationUtils.arraySlice(this.values, 0)
              , r = new (0,
            this.constructor)(this.name,e,t);
            return r.createInterpolant = this.createInterpolant,
            r
        }
    }], [{
        key: "toJSON",
        value: function(e) {
            var t, r = e.constructor;
            if (r.toJSON !== this.toJSON)
                t = r.toJSON(e);
            else {
                t = {
                    name: e.name,
                    times: AnimationUtils.convertArray(e.times, Array),
                    values: AnimationUtils.convertArray(e.values, Array)
                };
                var i = e.getInterpolation();
                i !== e.DefaultInterpolation && (t.interpolation = i)
            }
            return t.type = e.ValueTypeName,
            t
        }
    }]),
    e
}();
KeyframeTrack.prototype.TimeBufferType = Float32Array,
KeyframeTrack.prototype.ValueBufferType = Float32Array,
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
var BooleanKeyframeTrack = function(e) {
    _inherits(r, KeyframeTrack);
    var t = _createSuper(r);
    function r() {
        return _classCallCheck(this, r),
        t.apply(this, arguments)
    }
    return _createClass(r)
}();
BooleanKeyframeTrack.prototype.ValueTypeName = "bool",
BooleanKeyframeTrack.prototype.ValueBufferType = Array,
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete,
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0,
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
var ColorKeyframeTrack = function(e) {
    _inherits(r, KeyframeTrack);
    var t = _createSuper(r);
    function r() {
        return _classCallCheck(this, r),
        t.apply(this, arguments)
    }
    return _createClass(r)
}();
ColorKeyframeTrack.prototype.ValueTypeName = "color";
var NumberKeyframeTrack = function(e) {
    _inherits(r, KeyframeTrack);
    var t = _createSuper(r);
    function r() {
        return _classCallCheck(this, r),
        t.apply(this, arguments)
    }
    return _createClass(r)
}();
NumberKeyframeTrack.prototype.ValueTypeName = "number";
var QuaternionLinearInterpolant = function(e) {
    _inherits(r, Interpolant);
    var t = _createSuper(r);
    function r(e, i, n, a) {
        return _classCallCheck(this, r),
        t.call(this, e, i, n, a)
    }
    return _createClass(r, [{
        key: "interpolate_",
        value: function(e, t, r, i) {
            for (var n = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = (r - t) / (i - t), l = e * o, u = l + o; l !== u; l += 4)
                Quaternion.slerpFlat(n, 0, a, l - o, a, l, s);
            return n
        }
    }]),
    r
}()
  , QuaternionKeyframeTrack = function(e) {
    _inherits(r, KeyframeTrack);
    var t = _createSuper(r);
    function r() {
        return _classCallCheck(this, r),
        t.apply(this, arguments)
    }
    return _createClass(r, [{
        key: "InterpolantFactoryMethodLinear",
        value: function(e) {
            return new QuaternionLinearInterpolant(this.times,this.values,this.getValueSize(),e)
        }
    }]),
    r
}();
QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion",
QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear,
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
var StringKeyframeTrack = function(e) {
    _inherits(r, KeyframeTrack);
    var t = _createSuper(r);
    function r() {
        return _classCallCheck(this, r),
        t.apply(this, arguments)
    }
    return _createClass(r)
}();
StringKeyframeTrack.prototype.ValueTypeName = "string",
StringKeyframeTrack.prototype.ValueBufferType = Array,
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete,
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0,
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
var VectorKeyframeTrack = function(e) {
    _inherits(r, KeyframeTrack);
    var t = _createSuper(r);
    function r() {
        return _classCallCheck(this, r),
        t.apply(this, arguments)
    }
    return _createClass(r)
}();
VectorKeyframeTrack.prototype.ValueTypeName = "vector";
var AnimationClip = function() {
    function e(t) {
        var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1
          , i = arguments.length > 2 ? arguments[2] : void 0
          , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : NormalAnimationBlendMode;
        _classCallCheck(this, e),
        this.name = t,
        this.tracks = i,
        this.duration = r,
        this.blendMode = n,
        this.uuid = generateUUID(),
        this.duration < 0 && this.resetDuration()
    }
    return _createClass(e, [{
        key: "resetDuration",
        value: function() {
            for (var e = 0, t = 0, r = this.tracks.length; t !== r; ++t) {
                var i = this.tracks[t];
                e = Math.max(e, i.times[i.times.length - 1])
            }
            return this.duration = e,
            this
        }
    }, {
        key: "trim",
        value: function() {
            for (var e = 0; e < this.tracks.length; e++)
                this.tracks[e].trim(0, this.duration);
            return this
        }
    }, {
        key: "validate",
        value: function() {
            for (var e = !0, t = 0; t < this.tracks.length; t++)
                e = e && this.tracks[t].validate();
            return e
        }
    }, {
        key: "optimize",
        value: function() {
            for (var e = 0; e < this.tracks.length; e++)
                this.tracks[e].optimize();
            return this
        }
    }, {
        key: "clone",
        value: function() {
            for (var e = [], t = 0; t < this.tracks.length; t++)
                e.push(this.tracks[t].clone());
            return new this.constructor(this.name,this.duration,e,this.blendMode)
        }
    }, {
        key: "toJSON",
        value: function() {
            return this.constructor.toJSON(this)
        }
    }], [{
        key: "parse",
        value: function(e) {
            for (var t = [], r = e.tracks, i = 1 / (e.fps || 1), n = 0, a = r.length; n !== a; ++n)
                t.push(parseKeyframeTrack(r[n]).scale(i));
            var o = new this(e.name,e.duration,t,e.blendMode);
            return o.uuid = e.uuid,
            o
        }
    }, {
        key: "toJSON",
        value: function(e) {
            for (var t = [], r = e.tracks, i = {
                name: e.name,
                duration: e.duration,
                tracks: t,
                uuid: e.uuid,
                blendMode: e.blendMode
            }, n = 0, a = r.length; n !== a; ++n)
                t.push(KeyframeTrack.toJSON(r[n]));
            return i
        }
    }, {
        key: "CreateFromMorphTargetSequence",
        value: function(e, t, r, i) {
            for (var n = t.length, a = [], o = 0; o < n; o++) {
                var s = []
                  , l = [];
                s.push((o + n - 1) % n, o, (o + 1) % n),
                l.push(0, 1, 0);
                var u = AnimationUtils.getKeyframeOrder(s);
                s = AnimationUtils.sortedArray(s, 1, u),
                l = AnimationUtils.sortedArray(l, 1, u),
                i || 0 !== s[0] || (s.push(n),
                l.push(l[0])),
                a.push(new NumberKeyframeTrack(".morphTargetInfluences[" + t[o].name + "]",s,l).scale(1 / r))
            }
            return new this(e,-1,a)
        }
    }, {
        key: "findByName",
        value: function(e, t) {
            var r = e;
            if (!Array.isArray(e)) {
                var i = e;
                r = i.geometry && i.geometry.animations || i.animations
            }
            for (var n = 0; n < r.length; n++)
                if (r[n].name === t)
                    return r[n];
            return null
        }
    }, {
        key: "CreateClipsFromMorphTargetSequences",
        value: function(e, t, r) {
            for (var i = {}, n = /^([\w-]*?)([\d]+)$/, a = 0, o = e.length; a < o; a++) {
                var s = e[a]
                  , l = s.name.match(n);
                if (l && l.length > 1) {
                    var u = l[1]
                      , c = i[u];
                    c || (i[u] = c = []),
                    c.push(s)
                }
            }
            var h = [];
            for (var d in i)
                h.push(this.CreateFromMorphTargetSequence(d, i[d], t, r));
            return h
        }
    }, {
        key: "parseAnimation",
        value: function(e, t) {
            if (!e)
                return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
                null;
            for (var r = function(e, t, r, i, n) {
                if (0 !== r.length) {
                    var a = []
                      , o = [];
                    AnimationUtils.flattenJSON(r, a, o, i),
                    0 !== a.length && n.push(new e(t,a,o))
                }
            }, i = [], n = e.name || "default", a = e.fps || 30, o = e.blendMode, s = e.length || -1, l = e.hierarchy || [], u = 0; u < l.length; u++) {
                var c = l[u].keys;
                if (c && 0 !== c.length)
                    if (c[0].morphTargets) {
                        var h = {}
                          , d = void 0;
                        for (d = 0; d < c.length; d++)
                            if (c[d].morphTargets)
                                for (var p = 0; p < c[d].morphTargets.length; p++)
                                    h[c[d].morphTargets[p]] = -1;
                        for (var f in h) {
                            for (var m = [], v = [], g = 0; g !== c[d].morphTargets.length; ++g) {
                                var _ = c[d];
                                m.push(_.time),
                                v.push(_.morphTarget === f ? 1 : 0)
                            }
                            i.push(new NumberKeyframeTrack(".morphTargetInfluence[" + f + "]",m,v))
                        }
                        s = h.length * a
                    } else {
                        var y = ".bones[" + t[u].name + "]";
                        r(VectorKeyframeTrack, y + ".position", c, "pos", i),
                        r(QuaternionKeyframeTrack, y + ".quaternion", c, "rot", i),
                        r(VectorKeyframeTrack, y + ".scale", c, "scl", i)
                    }
            }
            return 0 === i.length ? null : new this(n,s,i,o)
        }
    }]),
    e
}();
function getTrackTypeForValueTypeName(e) {
    switch (e.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
        return NumberKeyframeTrack;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
        return VectorKeyframeTrack;
    case "color":
        return ColorKeyframeTrack;
    case "quaternion":
        return QuaternionKeyframeTrack;
    case "bool":
    case "boolean":
        return BooleanKeyframeTrack;
    case "string":
        return StringKeyframeTrack
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
}
function parseKeyframeTrack(e) {
    if (void 0 === e.type)
        throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    var t = getTrackTypeForValueTypeName(e.type);
    if (void 0 === e.times) {
        var r = []
          , i = [];
        AnimationUtils.flattenJSON(e.keys, r, i, "value"),
        e.times = r,
        e.values = i
    }
    return void 0 !== t.parse ? t.parse(e) : new t(e.name,e.times,e.values,e.interpolation)
}
var Cache = {
    enabled: !1,
    files: {},
    add: function(e, t) {
        !1 !== this.enabled && (this.files[e] = t)
    },
    get: function(e) {
        if (!1 !== this.enabled)
            return this.files[e]
    },
    remove: function(e) {
        delete this.files[e]
    },
    clear: function() {
        this.files = {}
    }
}
  , LoadingManager = _createClass((function e(t, r, i) {
    _classCallCheck(this, e);
    var n = this
      , a = !1
      , o = 0
      , s = 0
      , l = void 0
      , u = [];
    this.onStart = void 0,
    this.onLoad = t,
    this.onProgress = r,
    this.onError = i,
    this.itemStart = function(e) {
        s++,
        !1 === a && void 0 !== n.onStart && n.onStart(e, o, s),
        a = !0
    }
    ,
    this.itemEnd = function(e) {
        o++,
        void 0 !== n.onProgress && n.onProgress(e, o, s),
        o === s && (a = !1,
        void 0 !== n.onLoad && n.onLoad())
    }
    ,
    this.itemError = function(e) {
        void 0 !== n.onError && n.onError(e)
    }
    ,
    this.resolveURL = function(e) {
        return l ? l(e) : e
    }
    ,
    this.setURLModifier = function(e) {
        return l = e,
        this
    }
    ,
    this.addHandler = function(e, t) {
        return u.push(e, t),
        this
    }
    ,
    this.removeHandler = function(e) {
        var t = u.indexOf(e);
        return -1 !== t && u.splice(t, 2),
        this
    }
    ,
    this.getHandler = function(e) {
        for (var t = 0, r = u.length; t < r; t += 2) {
            var i = u[t]
              , n = u[t + 1];
            if (i.global && (i.lastIndex = 0),
            i.test(e))
                return n
        }
        return null
    }
}
))
  , DefaultLoadingManager = new LoadingManager
  , Loader = function() {
    function e(t) {
        _classCallCheck(this, e),
        this.manager = void 0 !== t ? t : DefaultLoadingManager,
        this.crossOrigin = "anonymous",
        this.withCredentials = !1,
        this.path = "",
        this.resourcePath = "",
        this.requestHeader = {}
    }
    return _createClass(e, [{
        key: "load",
        value: function() {}
    }, {
        key: "loadAsync",
        value: function(e, t) {
            var r = this;
            return new Promise((function(i, n) {
                r.load(e, i, t, n)
            }
            ))
        }
    }, {
        key: "parse",
        value: function() {}
    }, {
        key: "setCrossOrigin",
        value: function(e) {
            return this.crossOrigin = e,
            this
        }
    }, {
        key: "setWithCredentials",
        value: function(e) {
            return this.withCredentials = e,
            this
        }
    }, {
        key: "setPath",
        value: function(e) {
            return this.path = e,
            this
        }
    }, {
        key: "setResourcePath",
        value: function(e) {
            return this.resourcePath = e,
            this
        }
    }, {
        key: "setRequestHeader",
        value: function(e) {
            return this.requestHeader = e,
            this
        }
    }]),
    e
}()
  , loading$1 = {}
  , FileLoader = function(e) {
    _inherits(r, Loader);
    var t = _createSuper(r);
    function r(e) {
        return _classCallCheck(this, r),
        t.call(this, e)
    }
    return _createClass(r, [{
        key: "load",
        value: function(e, t, r, i) {
            var n = this;
            void 0 === e && (e = ""),
            void 0 !== this.path && (e = this.path + e),
            e = this.manager.resolveURL(e);
            var a = Cache.get(e);
            if (void 0 !== a)
                return this.manager.itemStart(e),
                setTimeout((function() {
                    t && t(a),
                    n.manager.itemEnd(e)
                }
                ), 0),
                a;
            if (void 0 === loading$1[e]) {
                loading$1[e] = [],
                loading$1[e].push({
                    onLoad: t,
                    onProgress: r,
                    onError: i
                });
                var o = new Request(e,{
                    headers: new Headers(this.requestHeader),
                    credentials: this.withCredentials ? "include" : "same-origin"
                })
                  , s = this.mimeType
                  , l = this.responseType;
                fetch(o).then((function(t) {
                    if (200 === t.status || 0 === t.status) {
                        if (0 === t.status && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                        "undefined" == typeof ReadableStream || void 0 === t.body || void 0 === t.body.getReader)
                            return t;
                        var r = loading$1[e]
                          , i = t.body.getReader()
                          , n = t.headers.get("Content-Length")
                          , a = n ? parseInt(n) : 0
                          , o = 0 !== a
                          , s = 0
                          , l = new ReadableStream({
                            start: function(e) {
                                !function t() {
                                    i.read().then((function(i) {
                                        var n = i.done
                                          , l = i.value;
                                        if (n)
                                            e.close();
                                        else {
                                            s += l.byteLength;
                                            for (var u = new ProgressEvent("progress",{
                                                lengthComputable: o,
                                                loaded: s,
                                                total: a
                                            }), c = 0, h = r.length; c < h; c++) {
                                                var d = r[c];
                                                d.onProgress && d.onProgress(u)
                                            }
                                            e.enqueue(l),
                                            t()
                                        }
                                    }
                                    ))
                                }()
                            }
                        });
                        return new Response(l)
                    }
                    throw Error('fetch for "'.concat(t.url, '" responded with ').concat(t.status, ": ").concat(t.statusText))
                }
                )).then((function(e) {
                    switch (l) {
                    case "arraybuffer":
                        return e.arrayBuffer();
                    case "blob":
                        return e.blob();
                    case "document":
                        return e.text().then((function(e) {
                            return (new DOMParser).parseFromString(e, s)
                        }
                        ));
                    case "json":
                        return e.json();
                    default:
                        if (void 0 === s)
                            return e.text();
                        var t = /charset="?([^;"\s]*)"?/i.exec(s)
                          , r = t && t[1] ? t[1].toLowerCase() : void 0
                          , i = new TextDecoder(r);
                        return e.arrayBuffer().then((function(e) {
                            return i.decode(e)
                        }
                        ))
                    }
                }
                )).then((function(t) {
                    Cache.add(e, t);
                    var r = loading$1[e];
                    delete loading$1[e];
                    for (var i = 0, n = r.length; i < n; i++) {
                        var a = r[i];
                        a.onLoad && a.onLoad(t)
                    }
                }
                )).catch((function(t) {
                    var r = loading$1[e];
                    if (void 0 === r)
                        throw n.manager.itemError(e),
                        t;
                    delete loading$1[e];
                    for (var i = 0, a = r.length; i < a; i++) {
                        var o = r[i];
                        o.onError && o.onError(t)
                    }
                    n.manager.itemError(e)
                }
                )).finally((function() {
                    n.manager.itemEnd(e)
                }
                )),
                this.manager.itemStart(e)
            } else
                loading$1[e].push({
                    onLoad: t,
                    onProgress: r,
                    onError: i
                })
        }
    }, {
        key: "setResponseType",
        value: function(e) {
            return this.responseType = e,
            this
        }
    }, {
        key: "setMimeType",
        value: function(e) {
            return this.mimeType = e,
            this
        }
    }]),
    r
}()
  , ImageLoader = function(e) {
    _inherits(r, Loader);
    var t = _createSuper(r);
    function r(e) {
        return _classCallCheck(this, r),
        t.call(this, e)
    }
    return _createClass(r, [{
        key: "load",
        value: function(e, t, r, i) {
            void 0 !== this.path && (e = this.path + e),
            e = this.manager.resolveURL(e);
            var n = this
              , a = Cache.get(e);
            if (void 0 !== a)
                return n.manager.itemStart(e),
                setTimeout((function() {
                    t && t(a),
                    n.manager.itemEnd(e)
                }
                ), 0),
                a;
            var o = createElementNS("img");
            function s() {
                u(),
                Cache.add(e, this),
                t && t(this),
                n.manager.itemEnd(e)
            }
            function l(t) {
                u(),
                i && i(t),
                n.manager.itemError(e),
                n.manager.itemEnd(e)
            }
            function u() {
                o.removeEventListener("load", s, !1),
                o.removeEventListener("error", l, !1)
            }
            return o.addEventListener("load", s, !1),
            o.addEventListener("error", l, !1),
            "data:" !== e.slice(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin),
            n.manager.itemStart(e),
            o.src = e,
            o
        }
    }]),
    r
}()
  , CubeTextureLoader = function(e) {
    _inherits(r, Loader);
    var t = _createSuper(r);
    function r(e) {
        return _classCallCheck(this, r),
        t.call(this, e)
    }
    return _createClass(r, [{
        key: "load",
        value: function(e, t, r, i) {
            var n = new CubeTexture
              , a = new ImageLoader(this.manager);
            a.setCrossOrigin(this.crossOrigin),
            a.setPath(this.path);
            var o = 0;
            function s(r) {
                a.load(e[r], (function(e) {
                    n.images[r] = e,
                    6 == ++o && (n.needsUpdate = !0,
                    t && t(n))
                }
                ), void 0, i)
            }
            for (var l = 0; l < e.length; ++l)
                s(l);
            return n
        }
    }]),
    r
}()
  , TextureLoader = function(e) {
    _inherits(r, Loader);
    var t = _createSuper(r);
    function r(e) {
        return _classCallCheck(this, r),
        t.call(this, e)
    }
    return _createClass(r, [{
        key: "load",
        value: function(e, t, r, i) {
            var n = new Texture
              , a = new ImageLoader(this.manager);
            return a.setCrossOrigin(this.crossOrigin),
            a.setPath(this.path),
            a.load(e, (function(e) {
                n.image = e,
                n.needsUpdate = !0,
                void 0 !== t && t(n)
            }
            ), r, i),
            n
        }
    }]),
    r
}()
  , Light = function(e) {
    _inherits(r, Object3D);
    var t = _createSuper(r);
    function r(e) {
        var i, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
        return _classCallCheck(this, r),
        (i = t.call(this)).type = "Light",
        i.color = new Color(e),
        i.intensity = n,
        i
    }
    return _createClass(r, [{
        key: "dispose",
        value: function() {}
    }, {
        key: "copy",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e),
            this.color.copy(e.color),
            this.intensity = e.intensity,
            this
        }
    }, {
        key: "toJSON",
        value: function(e) {
            var t = _get(_getPrototypeOf(r.prototype), "toJSON", this).call(this, e);
            return t.object.color = this.color.getHex(),
            t.object.intensity = this.intensity,
            void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()),
            void 0 !== this.distance && (t.object.distance = this.distance),
            void 0 !== this.angle && (t.object.angle = this.angle),
            void 0 !== this.decay && (t.object.decay = this.decay),
            void 0 !== this.penumbra && (t.object.penumbra = this.penumbra),
            void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()),
            t
        }
    }]),
    r
}();
Light.prototype.isLight = !0;
var HemisphereLight = function(e) {
    _inherits(r, Light);
    var t = _createSuper(r);
    function r(e, i, n) {
        var a;
        return _classCallCheck(this, r),
        (a = t.call(this, e, n)).type = "HemisphereLight",
        a.position.copy(Object3D.DefaultUp),
        a.updateMatrix(),
        a.groundColor = new Color(i),
        a
    }
    return _createClass(r, [{
        key: "copy",
        value: function(e) {
            return Light.prototype.copy.call(this, e),
            this.groundColor.copy(e.groundColor),
            this
        }
    }]),
    r
}();
HemisphereLight.prototype.isHemisphereLight = !0;
var _projScreenMatrix$1 = new Matrix4
  , _lightPositionWorld$1 = new Vector3
  , _lookTarget$1 = new Vector3
  , LightShadow = function() {
    function e(t) {
        _classCallCheck(this, e),
        this.camera = t,
        this.bias = 0,
        this.normalBias = 0,
        this.radius = 1,
        this.blurSamples = 8,
        this.mapSize = new Vector2(512,512),
        this.map = null,
        this.mapPass = null,
        this.matrix = new Matrix4,
        this.autoUpdate = !0,
        this.needsUpdate = !1,
        this._frustum = new Frustum,
        this._frameExtents = new Vector2(1,1),
        this._viewportCount = 1,
        this._viewports = [new Vector4(0,0,1,1)]
    }
    return _createClass(e, [{
        key: "getViewportCount",
        value: function() {
            return this._viewportCount
        }
    }, {
        key: "getFrustum",
        value: function() {
            return this._frustum
        }
    }, {
        key: "updateMatrices",
        value: function(e) {
            var t = this.camera
              , r = this.matrix;
            _lightPositionWorld$1.setFromMatrixPosition(e.matrixWorld),
            t.position.copy(_lightPositionWorld$1),
            _lookTarget$1.setFromMatrixPosition(e.target.matrixWorld),
            t.lookAt(_lookTarget$1),
            t.updateMatrixWorld(),
            _projScreenMatrix$1.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(_projScreenMatrix$1),
            r.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
            r.multiply(t.projectionMatrix),
            r.multiply(t.matrixWorldInverse)
        }
    }, {
        key: "getViewport",
        value: function(e) {
            return this._viewports[e]
        }
    }, {
        key: "getFrameExtents",
        value: function() {
            return this._frameExtents
        }
    }, {
        key: "dispose",
        value: function() {
            this.map && this.map.dispose(),
            this.mapPass && this.mapPass.dispose()
        }
    }, {
        key: "copy",
        value: function(e) {
            return this.camera = e.camera.clone(),
            this.bias = e.bias,
            this.radius = e.radius,
            this.mapSize.copy(e.mapSize),
            this
        }
    }, {
        key: "clone",
        value: function() {
            return (new this.constructor).copy(this)
        }
    }, {
        key: "toJSON",
        value: function() {
            var e = {};
            return 0 !== this.bias && (e.bias = this.bias),
            0 !== this.normalBias && (e.normalBias = this.normalBias),
            1 !== this.radius && (e.radius = this.radius),
            512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()),
            e.camera = this.camera.toJSON(!1).object,
            delete e.camera.matrix,
            e
        }
    }]),
    e
}()
  , SpotLightShadow = function(e) {
    _inherits(r, LightShadow);
    var t = _createSuper(r);
    function r() {
        var e;
        return _classCallCheck(this, r),
        (e = t.call(this, new PerspectiveCamera(50,1,.5,500))).focus = 1,
        e
    }
    return _createClass(r, [{
        key: "updateMatrices",
        value: function(e) {
            var t = this.camera
              , i = 2 * RAD2DEG * e.angle * this.focus
              , n = this.mapSize.width / this.mapSize.height
              , a = e.distance || t.far;
            i === t.fov && n === t.aspect && a === t.far || (t.fov = i,
            t.aspect = n,
            t.far = a,
            t.updateProjectionMatrix()),
            _get(_getPrototypeOf(r.prototype), "updateMatrices", this).call(this, e)
        }
    }, {
        key: "copy",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e),
            this.focus = e.focus,
            this
        }
    }]),
    r
}();
SpotLightShadow.prototype.isSpotLightShadow = !0;
var SpotLight = function(e) {
    _inherits(r, Light);
    var t = _createSuper(r);
    function r(e, i) {
        var n, a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Math.PI / 3, s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, l = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1;
        return _classCallCheck(this, r),
        (n = t.call(this, e, i)).type = "SpotLight",
        n.position.copy(Object3D.DefaultUp),
        n.updateMatrix(),
        n.target = new Object3D,
        n.distance = a,
        n.angle = o,
        n.penumbra = s,
        n.decay = l,
        n.shadow = new SpotLightShadow,
        n
    }
    return _createClass(r, [{
        key: "power",
        get: function() {
            return this.intensity * Math.PI
        },
        set: function(e) {
            this.intensity = e / Math.PI
        }
    }, {
        key: "dispose",
        value: function() {
            this.shadow.dispose()
        }
    }, {
        key: "copy",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e),
            this.distance = e.distance,
            this.angle = e.angle,
            this.penumbra = e.penumbra,
            this.decay = e.decay,
            this.target = e.target.clone(),
            this.shadow = e.shadow.clone(),
            this
        }
    }]),
    r
}();
SpotLight.prototype.isSpotLight = !0;
var _projScreenMatrix = new Matrix4
  , _lightPositionWorld = new Vector3
  , _lookTarget = new Vector3
  , PointLightShadow = function(e) {
    _inherits(r, LightShadow);
    var t = _createSuper(r);
    function r() {
        var e;
        return _classCallCheck(this, r),
        (e = t.call(this, new PerspectiveCamera(90,1,.5,500)))._frameExtents = new Vector2(4,2),
        e._viewportCount = 6,
        e._viewports = [new Vector4(2,1,1,1), new Vector4(0,1,1,1), new Vector4(3,1,1,1), new Vector4(1,1,1,1), new Vector4(3,0,1,1), new Vector4(1,0,1,1)],
        e._cubeDirections = [new Vector3(1,0,0), new Vector3(-1,0,0), new Vector3(0,0,1), new Vector3(0,0,-1), new Vector3(0,1,0), new Vector3(0,-1,0)],
        e._cubeUps = [new Vector3(0,1,0), new Vector3(0,1,0), new Vector3(0,1,0), new Vector3(0,1,0), new Vector3(0,0,1), new Vector3(0,0,-1)],
        e
    }
    return _createClass(r, [{
        key: "updateMatrices",
        value: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
              , r = this.camera
              , i = this.matrix
              , n = e.distance || r.far;
            n !== r.far && (r.far = n,
            r.updateProjectionMatrix()),
            _lightPositionWorld.setFromMatrixPosition(e.matrixWorld),
            r.position.copy(_lightPositionWorld),
            _lookTarget.copy(r.position),
            _lookTarget.add(this._cubeDirections[t]),
            r.up.copy(this._cubeUps[t]),
            r.lookAt(_lookTarget),
            r.updateMatrixWorld(),
            i.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z),
            _projScreenMatrix.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(_projScreenMatrix)
        }
    }]),
    r
}();
PointLightShadow.prototype.isPointLightShadow = !0;
var PointLight = function(e) {
    _inherits(r, Light);
    var t = _createSuper(r);
    function r(e, i) {
        var n, a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
        return _classCallCheck(this, r),
        (n = t.call(this, e, i)).type = "PointLight",
        n.distance = a,
        n.decay = o,
        n.shadow = new PointLightShadow,
        n
    }
    return _createClass(r, [{
        key: "power",
        get: function() {
            return 4 * this.intensity * Math.PI
        },
        set: function(e) {
            this.intensity = e / (4 * Math.PI)
        }
    }, {
        key: "dispose",
        value: function() {
            this.shadow.dispose()
        }
    }, {
        key: "copy",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e),
            this.distance = e.distance,
            this.decay = e.decay,
            this.shadow = e.shadow.clone(),
            this
        }
    }]),
    r
}();
PointLight.prototype.isPointLight = !0;
var DirectionalLightShadow = function(e) {
    _inherits(r, LightShadow);
    var t = _createSuper(r);
    function r() {
        return _classCallCheck(this, r),
        t.call(this, new OrthographicCamera(-5,5,5,-5,.5,500))
    }
    return _createClass(r)
}();
DirectionalLightShadow.prototype.isDirectionalLightShadow = !0;
var DirectionalLight = function(e) {
    _inherits(r, Light);
    var t = _createSuper(r);
    function r(e, i) {
        var n;
        return _classCallCheck(this, r),
        (n = t.call(this, e, i)).type = "DirectionalLight",
        n.position.copy(Object3D.DefaultUp),
        n.updateMatrix(),
        n.target = new Object3D,
        n.shadow = new DirectionalLightShadow,
        n
    }
    return _createClass(r, [{
        key: "dispose",
        value: function() {
            this.shadow.dispose()
        }
    }, {
        key: "copy",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e),
            this.target = e.target.clone(),
            this.shadow = e.shadow.clone(),
            this
        }
    }]),
    r
}();
DirectionalLight.prototype.isDirectionalLight = !0;
var AmbientLight = function(e) {
    _inherits(r, Light);
    var t = _createSuper(r);
    function r(e, i) {
        var n;
        return _classCallCheck(this, r),
        (n = t.call(this, e, i)).type = "AmbientLight",
        n
    }
    return _createClass(r)
}();
AmbientLight.prototype.isAmbientLight = !0;
var RectAreaLight = function(e) {
    _inherits(r, Light);
    var t = _createSuper(r);
    function r(e, i) {
        var n, a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 10, o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 10;
        return _classCallCheck(this, r),
        (n = t.call(this, e, i)).type = "RectAreaLight",
        n.width = a,
        n.height = o,
        n
    }
    return _createClass(r, [{
        key: "power",
        get: function() {
            return this.intensity * this.width * this.height * Math.PI
        },
        set: function(e) {
            this.intensity = e / (this.width * this.height * Math.PI)
        }
    }, {
        key: "copy",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e),
            this.width = e.width,
            this.height = e.height,
            this
        }
    }, {
        key: "toJSON",
        value: function(e) {
            var t = _get(_getPrototypeOf(r.prototype), "toJSON", this).call(this, e);
            return t.object.width = this.width,
            t.object.height = this.height,
            t
        }
    }]),
    r
}();
RectAreaLight.prototype.isRectAreaLight = !0;
var SphericalHarmonics3 = function() {
    function e() {
        _classCallCheck(this, e),
        this.coefficients = [];
        for (var t = 0; t < 9; t++)
            this.coefficients.push(new Vector3)
    }
    return _createClass(e, [{
        key: "set",
        value: function(e) {
            for (var t = 0; t < 9; t++)
                this.coefficients[t].copy(e[t]);
            return this
        }
    }, {
        key: "zero",
        value: function() {
            for (var e = 0; e < 9; e++)
                this.coefficients[e].set(0, 0, 0);
            return this
        }
    }, {
        key: "getAt",
        value: function(e, t) {
            var r = e.x
              , i = e.y
              , n = e.z
              , a = this.coefficients;
            return t.copy(a[0]).multiplyScalar(.282095),
            t.addScaledVector(a[1], .488603 * i),
            t.addScaledVector(a[2], .488603 * n),
            t.addScaledVector(a[3], .488603 * r),
            t.addScaledVector(a[4], r * i * 1.092548),
            t.addScaledVector(a[5], i * n * 1.092548),
            t.addScaledVector(a[6], .315392 * (3 * n * n - 1)),
            t.addScaledVector(a[7], r * n * 1.092548),
            t.addScaledVector(a[8], .546274 * (r * r - i * i)),
            t
        }
    }, {
        key: "getIrradianceAt",
        value: function(e, t) {
            var r = e.x
              , i = e.y
              , n = e.z
              , a = this.coefficients;
            return t.copy(a[0]).multiplyScalar(.886227),
            t.addScaledVector(a[1], 1.023328 * i),
            t.addScaledVector(a[2], 1.023328 * n),
            t.addScaledVector(a[3], 1.023328 * r),
            t.addScaledVector(a[4], .858086 * r * i),
            t.addScaledVector(a[5], .858086 * i * n),
            t.addScaledVector(a[6], .743125 * n * n - .247708),
            t.addScaledVector(a[7], .858086 * r * n),
            t.addScaledVector(a[8], .429043 * (r * r - i * i)),
            t
        }
    }, {
        key: "add",
        value: function(e) {
            for (var t = 0; t < 9; t++)
                this.coefficients[t].add(e.coefficients[t]);
            return this
        }
    }, {
        key: "addScaledSH",
        value: function(e, t) {
            for (var r = 0; r < 9; r++)
                this.coefficients[r].addScaledVector(e.coefficients[r], t);
            return this
        }
    }, {
        key: "scale",
        value: function(e) {
            for (var t = 0; t < 9; t++)
                this.coefficients[t].multiplyScalar(e);
            return this
        }
    }, {
        key: "lerp",
        value: function(e, t) {
            for (var r = 0; r < 9; r++)
                this.coefficients[r].lerp(e.coefficients[r], t);
            return this
        }
    }, {
        key: "equals",
        value: function(e) {
            for (var t = 0; t < 9; t++)
                if (!this.coefficients[t].equals(e.coefficients[t]))
                    return !1;
            return !0
        }
    }, {
        key: "copy",
        value: function(e) {
            return this.set(e.coefficients)
        }
    }, {
        key: "clone",
        value: function() {
            return (new this.constructor).copy(this)
        }
    }, {
        key: "fromArray",
        value: function(e) {
            for (var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, r = this.coefficients, i = 0; i < 9; i++)
                r[i].fromArray(e, t + 3 * i);
            return this
        }
    }, {
        key: "toArray",
        value: function() {
            for (var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, r = this.coefficients, i = 0; i < 9; i++)
                r[i].toArray(e, t + 3 * i);
            return e
        }
    }], [{
        key: "getBasisAt",
        value: function(e, t) {
            var r = e.x
              , i = e.y
              , n = e.z;
            t[0] = .282095,
            t[1] = .488603 * i,
            t[2] = .488603 * n,
            t[3] = .488603 * r,
            t[4] = 1.092548 * r * i,
            t[5] = 1.092548 * i * n,
            t[6] = .315392 * (3 * n * n - 1),
            t[7] = 1.092548 * r * n,
            t[8] = .546274 * (r * r - i * i)
        }
    }]),
    e
}();
SphericalHarmonics3.prototype.isSphericalHarmonics3 = !0;
var LightProbe = function(e) {
    _inherits(r, Light);
    var t = _createSuper(r);
    function r() {
        var e, i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new SphericalHarmonics3, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
        return _classCallCheck(this, r),
        (e = t.call(this, void 0, n)).sh = i,
        e
    }
    return _createClass(r, [{
        key: "copy",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e),
            this.sh.copy(e.sh),
            this
        }
    }, {
        key: "fromJSON",
        value: function(e) {
            return this.intensity = e.intensity,
            this.sh.fromArray(e.sh),
            this
        }
    }, {
        key: "toJSON",
        value: function(e) {
            var t = _get(_getPrototypeOf(r.prototype), "toJSON", this).call(this, e);
            return t.object.sh = this.sh.toArray(),
            t
        }
    }]),
    r
}();
LightProbe.prototype.isLightProbe = !0;
var LoaderUtils = function() {
    function e() {
        _classCallCheck(this, e)
    }
    return _createClass(e, null, [{
        key: "decodeText",
        value: function(e) {
            if ("undefined" != typeof TextDecoder)
                return (new TextDecoder).decode(e);
            for (var t = "", r = 0, i = e.length; r < i; r++)
                t += String.fromCharCode(e[r]);
            try {
                return decodeURIComponent(escape(t))
            } catch (n) {
                return t
            }
        }
    }, {
        key: "extractUrlBase",
        value: function(e) {
            var t = e.lastIndexOf("/");
            return -1 === t ? "./" : e.slice(0, t + 1)
        }
    }, {
        key: "resolveURL",
        value: function(e, t) {
            return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
            /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
        }
    }]),
    e
}()
  , InstancedBufferGeometry = function(e) {
    _inherits(r, BufferGeometry);
    var t = _createSuper(r);
    function r() {
        var e;
        return _classCallCheck(this, r),
        (e = t.call(this)).type = "InstancedBufferGeometry",
        e.instanceCount = 1 / 0,
        e
    }
    return _createClass(r, [{
        key: "copy",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e),
            this.instanceCount = e.instanceCount,
            this
        }
    }, {
        key: "clone",
        value: function() {
            return (new this.constructor).copy(this)
        }
    }, {
        key: "toJSON",
        value: function() {
            var e = _get(_getPrototypeOf(r.prototype), "toJSON", this).call(this, this);
            return e.instanceCount = this.instanceCount,
            e.isInstancedBufferGeometry = !0,
            e
        }
    }]),
    r
}();
InstancedBufferGeometry.prototype.isInstancedBufferGeometry = !0;
var ImageBitmapLoader = function(e) {
    _inherits(r, Loader);
    var t = _createSuper(r);
    function r(e) {
        var i;
        return _classCallCheck(this, r),
        i = t.call(this, e),
        "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
        "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
        i.options = {
            premultiplyAlpha: "none"
        },
        i
    }
    return _createClass(r, [{
        key: "setOptions",
        value: function(e) {
            return this.options = e,
            this
        }
    }, {
        key: "load",
        value: function(e, t, r, i) {
            void 0 === e && (e = ""),
            void 0 !== this.path && (e = this.path + e),
            e = this.manager.resolveURL(e);
            var n = this
              , a = Cache.get(e);
            if (void 0 !== a)
                return n.manager.itemStart(e),
                setTimeout((function() {
                    t && t(a),
                    n.manager.itemEnd(e)
                }
                ), 0),
                a;
            var o = {};
            o.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include",
            o.headers = this.requestHeader,
            fetch(e, o).then((function(e) {
                return e.blob()
            }
            )).then((function(e) {
                return createImageBitmap(e, Object.assign(n.options, {
                    colorSpaceConversion: "none"
                }))
            }
            )).then((function(r) {
                Cache.add(e, r),
                t && t(r),
                n.manager.itemEnd(e)
            }
            )).catch((function(t) {
                i && i(t),
                n.manager.itemError(e),
                n.manager.itemEnd(e)
            }
            )),
            n.manager.itemStart(e)
        }
    }]),
    r
}(), _context;
ImageBitmapLoader.prototype.isImageBitmapLoader = !0;
var AudioContext = {
    getContext: function() {
        return void 0 === _context && (_context = new (window.AudioContext || window.webkitAudioContext)),
        _context
    },
    setContext: function(e) {
        _context = e
    }
}
  , AudioLoader = function(e) {
    _inherits(r, Loader);
    var t = _createSuper(r);
    function r(e) {
        return _classCallCheck(this, r),
        t.call(this, e)
    }
    return _createClass(r, [{
        key: "load",
        value: function(e, t, r, i) {
            var n = this
              , a = new FileLoader(this.manager);
            a.setResponseType("arraybuffer"),
            a.setPath(this.path),
            a.setRequestHeader(this.requestHeader),
            a.setWithCredentials(this.withCredentials),
            a.load(e, (function(r) {
                try {
                    var a = r.slice(0);
                    AudioContext.getContext().decodeAudioData(a, (function(e) {
                        t(e)
                    }
                    ))
                } catch (o) {
                    i ? i(o) : console.error(o),
                    n.manager.itemError(e)
                }
            }
            ), r, i)
        }
    }]),
    r
}()
  , HemisphereLightProbe = function(e) {
    _inherits(r, LightProbe);
    var t = _createSuper(r);
    function r(e, i) {
        var n, a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
        _classCallCheck(this, r),
        n = t.call(this, void 0, a);
        var o = (new Color).set(e)
          , s = (new Color).set(i)
          , l = new Vector3(o.r,o.g,o.b)
          , u = new Vector3(s.r,s.g,s.b)
          , c = Math.sqrt(Math.PI)
          , h = c * Math.sqrt(.75);
        return n.sh.coefficients[0].copy(l).add(u).multiplyScalar(c),
        n.sh.coefficients[1].copy(l).sub(u).multiplyScalar(h),
        n
    }
    return _createClass(r)
}();
HemisphereLightProbe.prototype.isHemisphereLightProbe = !0;
var AmbientLightProbe = function(e) {
    _inherits(r, LightProbe);
    var t = _createSuper(r);
    function r(e) {
        var i, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
        _classCallCheck(this, r),
        i = t.call(this, void 0, n);
        var a = (new Color).set(e);
        return i.sh.coefficients[0].set(a.r, a.g, a.b).multiplyScalar(2 * Math.sqrt(Math.PI)),
        i
    }
    return _createClass(r)
}();
AmbientLightProbe.prototype.isAmbientLightProbe = !0;
var Clock = function() {
    function e() {
        var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
        _classCallCheck(this, e),
        this.autoStart = t,
        this.startTime = 0,
        this.oldTime = 0,
        this.elapsedTime = 0,
        this.running = !1
    }
    return _createClass(e, [{
        key: "start",
        value: function() {
            this.startTime = now(),
            this.oldTime = this.startTime,
            this.elapsedTime = 0,
            this.running = !0
        }
    }, {
        key: "stop",
        value: function() {
            this.getElapsedTime(),
            this.running = !1,
            this.autoStart = !1
        }
    }, {
        key: "getElapsedTime",
        value: function() {
            return this.getDelta(),
            this.elapsedTime
        }
    }, {
        key: "getDelta",
        value: function() {
            var e = 0;
            if (this.autoStart && !this.running)
                return this.start(),
                0;
            if (this.running) {
                var t = now();
                e = (t - this.oldTime) / 1e3,
                this.oldTime = t,
                this.elapsedTime += e
            }
            return e
        }
    }]),
    e
}();
function now() {
    return ("undefined" == typeof performance ? Date : performance).now()
}
var _position$1 = new Vector3
  , _quaternion$1 = new Quaternion
  , _scale$1 = new Vector3
  , _orientation$1 = new Vector3
  , AudioListener = function(e) {
    _inherits(r, Object3D);
    var t = _createSuper(r);
    function r() {
        var e;
        return _classCallCheck(this, r),
        (e = t.call(this)).type = "AudioListener",
        e.context = AudioContext.getContext(),
        e.gain = e.context.createGain(),
        e.gain.connect(e.context.destination),
        e.filter = null,
        e.timeDelta = 0,
        e._clock = new Clock,
        e
    }
    return _createClass(r, [{
        key: "getInput",
        value: function() {
            return this.gain
        }
    }, {
        key: "removeFilter",
        value: function() {
            return null !== this.filter && (this.gain.disconnect(this.filter),
            this.filter.disconnect(this.context.destination),
            this.gain.connect(this.context.destination),
            this.filter = null),
            this
        }
    }, {
        key: "getFilter",
        value: function() {
            return this.filter
        }
    }, {
        key: "setFilter",
        value: function(e) {
            return null !== this.filter ? (this.gain.disconnect(this.filter),
            this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination),
            this.filter = e,
            this.gain.connect(this.filter),
            this.filter.connect(this.context.destination),
            this
        }
    }, {
        key: "getMasterVolume",
        value: function() {
            return this.gain.gain.value
        }
    }, {
        key: "setMasterVolume",
        value: function(e) {
            return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
            this
        }
    }, {
        key: "updateMatrixWorld",
        value: function(e) {
            _get(_getPrototypeOf(r.prototype), "updateMatrixWorld", this).call(this, e);
            var t = this.context.listener
              , i = this.up;
            if (this.timeDelta = this._clock.getDelta(),
            this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1),
            _orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1),
            t.positionX) {
                var n = this.context.currentTime + this.timeDelta;
                t.positionX.linearRampToValueAtTime(_position$1.x, n),
                t.positionY.linearRampToValueAtTime(_position$1.y, n),
                t.positionZ.linearRampToValueAtTime(_position$1.z, n),
                t.forwardX.linearRampToValueAtTime(_orientation$1.x, n),
                t.forwardY.linearRampToValueAtTime(_orientation$1.y, n),
                t.forwardZ.linearRampToValueAtTime(_orientation$1.z, n),
                t.upX.linearRampToValueAtTime(i.x, n),
                t.upY.linearRampToValueAtTime(i.y, n),
                t.upZ.linearRampToValueAtTime(i.z, n)
            } else
                t.setPosition(_position$1.x, _position$1.y, _position$1.z),
                t.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z, i.x, i.y, i.z)
        }
    }]),
    r
}()
  , Audio$1 = function(e) {
    _inherits(r, Object3D);
    var t = _createSuper(r);
    function r(e) {
        var i;
        return _classCallCheck(this, r),
        (i = t.call(this)).type = "Audio",
        i.listener = e,
        i.context = e.context,
        i.gain = i.context.createGain(),
        i.gain.connect(e.getInput()),
        i.autoplay = !1,
        i.buffer = null,
        i.detune = 0,
        i.loop = !1,
        i.loopStart = 0,
        i.loopEnd = 0,
        i.offset = 0,
        i.duration = void 0,
        i.playbackRate = 1,
        i.isPlaying = !1,
        i.hasPlaybackControl = !0,
        i.source = null,
        i.sourceType = "empty",
        i._startedAt = 0,
        i._progress = 0,
        i._connected = !1,
        i.filters = [],
        i
    }
    return _createClass(r, [{
        key: "getOutput",
        value: function() {
            return this.gain
        }
    }, {
        key: "setNodeSource",
        value: function(e) {
            return this.hasPlaybackControl = !1,
            this.sourceType = "audioNode",
            this.source = e,
            this.connect(),
            this
        }
    }, {
        key: "setMediaElementSource",
        value: function(e) {
            return this.hasPlaybackControl = !1,
            this.sourceType = "mediaNode",
            this.source = this.context.createMediaElementSource(e),
            this.connect(),
            this
        }
    }, {
        key: "setMediaStreamSource",
        value: function(e) {
            return this.hasPlaybackControl = !1,
            this.sourceType = "mediaStreamNode",
            this.source = this.context.createMediaStreamSource(e),
            this.connect(),
            this
        }
    }, {
        key: "setBuffer",
        value: function(e) {
            return this.buffer = e,
            this.sourceType = "buffer",
            this.autoplay && this.play(),
            this
        }
    }, {
        key: "play",
        value: function() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
            if (!0 !== this.isPlaying) {
                if (!1 !== this.hasPlaybackControl) {
                    this._startedAt = this.context.currentTime + e;
                    var t = this.context.createBufferSource();
                    return t.buffer = this.buffer,
                    t.loop = this.loop,
                    t.loopStart = this.loopStart,
                    t.loopEnd = this.loopEnd,
                    t.onended = this.onEnded.bind(this),
                    t.start(this._startedAt, this._progress + this.offset, this.duration),
                    this.isPlaying = !0,
                    this.source = t,
                    this.setDetune(this.detune),
                    this.setPlaybackRate(this.playbackRate),
                    this.connect()
                }
                console.warn("THREE.Audio: this Audio has no playback control.")
            } else
                console.warn("THREE.Audio: Audio is already playing.")
        }
    }, {
        key: "pause",
        value: function() {
            if (!1 !== this.hasPlaybackControl)
                return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate,
                !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)),
                this.source.stop(),
                this.source.onended = null,
                this.isPlaying = !1),
                this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        }
    }, {
        key: "stop",
        value: function() {
            if (!1 !== this.hasPlaybackControl)
                return this._progress = 0,
                this.source.stop(),
                this.source.onended = null,
                this.isPlaying = !1,
                this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        }
    }, {
        key: "connect",
        value: function() {
            if (this.filters.length > 0) {
                this.source.connect(this.filters[0]);
                for (var e = 1, t = this.filters.length; e < t; e++)
                    this.filters[e - 1].connect(this.filters[e]);
                this.filters[this.filters.length - 1].connect(this.getOutput())
            } else
                this.source.connect(this.getOutput());
            return this._connected = !0,
            this
        }
    }, {
        key: "disconnect",
        value: function() {
            if (this.filters.length > 0) {
                this.source.disconnect(this.filters[0]);
                for (var e = 1, t = this.filters.length; e < t; e++)
                    this.filters[e - 1].disconnect(this.filters[e]);
                this.filters[this.filters.length - 1].disconnect(this.getOutput())
            } else
                this.source.disconnect(this.getOutput());
            return this._connected = !1,
            this
        }
    }, {
        key: "getFilters",
        value: function() {
            return this.filters
        }
    }, {
        key: "setFilters",
        value: function(e) {
            return e || (e = []),
            !0 === this._connected ? (this.disconnect(),
            this.filters = e.slice(),
            this.connect()) : this.filters = e.slice(),
            this
        }
    }, {
        key: "setDetune",
        value: function(e) {
            if (this.detune = e,
            void 0 !== this.source.detune)
                return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01),
                this
        }
    }, {
        key: "getDetune",
        value: function() {
            return this.detune
        }
    }, {
        key: "getFilter",
        value: function() {
            return this.getFilters()[0]
        }
    }, {
        key: "setFilter",
        value: function(e) {
            return this.setFilters(e ? [e] : [])
        }
    }, {
        key: "setPlaybackRate",
        value: function(e) {
            if (!1 !== this.hasPlaybackControl)
                return this.playbackRate = e,
                !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01),
                this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        }
    }, {
        key: "getPlaybackRate",
        value: function() {
            return this.playbackRate
        }
    }, {
        key: "onEnded",
        value: function() {
            this.isPlaying = !1
        }
    }, {
        key: "getLoop",
        value: function() {
            return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."),
            !1) : this.loop
        }
    }, {
        key: "setLoop",
        value: function(e) {
            if (!1 !== this.hasPlaybackControl)
                return this.loop = e,
                !0 === this.isPlaying && (this.source.loop = this.loop),
                this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        }
    }, {
        key: "setLoopStart",
        value: function(e) {
            return this.loopStart = e,
            this
        }
    }, {
        key: "setLoopEnd",
        value: function(e) {
            return this.loopEnd = e,
            this
        }
    }, {
        key: "getVolume",
        value: function() {
            return this.gain.gain.value
        }
    }, {
        key: "setVolume",
        value: function(e) {
            return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
            this
        }
    }]),
    r
}()
  , _position = new Vector3
  , _quaternion = new Quaternion
  , _scale = new Vector3
  , _orientation = new Vector3
  , PositionalAudio = function(e) {
    _inherits(r, Audio$1);
    var t = _createSuper(r);
    function r(e) {
        var i;
        return _classCallCheck(this, r),
        (i = t.call(this, e)).panner = i.context.createPanner(),
        i.panner.panningModel = "HRTF",
        i.panner.connect(i.gain),
        i
    }
    return _createClass(r, [{
        key: "disconnect",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "disconnect", this).call(this),
            this.panner.disconnect(this.gain)
        }
    }, {
        key: "getOutput",
        value: function() {
            return this.panner
        }
    }, {
        key: "getRefDistance",
        value: function() {
            return this.panner.refDistance
        }
    }, {
        key: "setRefDistance",
        value: function(e) {
            return this.panner.refDistance = e,
            this
        }
    }, {
        key: "getRolloffFactor",
        value: function() {
            return this.panner.rolloffFactor
        }
    }, {
        key: "setRolloffFactor",
        value: function(e) {
            return this.panner.rolloffFactor = e,
            this
        }
    }, {
        key: "getDistanceModel",
        value: function() {
            return this.panner.distanceModel
        }
    }, {
        key: "setDistanceModel",
        value: function(e) {
            return this.panner.distanceModel = e,
            this
        }
    }, {
        key: "getMaxDistance",
        value: function() {
            return this.panner.maxDistance
        }
    }, {
        key: "setMaxDistance",
        value: function(e) {
            return this.panner.maxDistance = e,
            this
        }
    }, {
        key: "setDirectionalCone",
        value: function(e, t, r) {
            return this.panner.coneInnerAngle = e,
            this.panner.coneOuterAngle = t,
            this.panner.coneOuterGain = r,
            this
        }
    }, {
        key: "updateMatrixWorld",
        value: function(e) {
            if (_get(_getPrototypeOf(r.prototype), "updateMatrixWorld", this).call(this, e),
            !0 !== this.hasPlaybackControl || !1 !== this.isPlaying) {
                this.matrixWorld.decompose(_position, _quaternion, _scale),
                _orientation.set(0, 0, 1).applyQuaternion(_quaternion);
                var t = this.panner;
                if (t.positionX) {
                    var i = this.context.currentTime + this.listener.timeDelta;
                    t.positionX.linearRampToValueAtTime(_position.x, i),
                    t.positionY.linearRampToValueAtTime(_position.y, i),
                    t.positionZ.linearRampToValueAtTime(_position.z, i),
                    t.orientationX.linearRampToValueAtTime(_orientation.x, i),
                    t.orientationY.linearRampToValueAtTime(_orientation.y, i),
                    t.orientationZ.linearRampToValueAtTime(_orientation.z, i)
                } else
                    t.setPosition(_position.x, _position.y, _position.z),
                    t.setOrientation(_orientation.x, _orientation.y, _orientation.z)
            }
        }
    }]),
    r
}()
  , PropertyMixer = function() {
    function e(t, r, i) {
        var n, a, o;
        switch (_classCallCheck(this, e),
        this.binding = t,
        this.valueSize = i,
        r) {
        case "quaternion":
            n = this._slerp,
            a = this._slerpAdditive,
            o = this._setAdditiveIdentityQuaternion,
            this.buffer = new Float64Array(6 * i),
            this._workIndex = 5;
            break;
        case "string":
        case "bool":
            n = this._select,
            a = this._select,
            o = this._setAdditiveIdentityOther,
            this.buffer = new Array(5 * i);
            break;
        default:
            n = this._lerp,
            a = this._lerpAdditive,
            o = this._setAdditiveIdentityNumeric,
            this.buffer = new Float64Array(5 * i)
        }
        this._mixBufferRegion = n,
        this._mixBufferRegionAdditive = a,
        this._setIdentity = o,
        this._origIndex = 3,
        this._addIndex = 4,
        this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0,
        this.useCount = 0,
        this.referenceCount = 0
    }
    return _createClass(e, [{
        key: "accumulate",
        value: function(e, t) {
            var r = this.buffer
              , i = this.valueSize
              , n = e * i + i
              , a = this.cumulativeWeight;
            if (0 === a) {
                for (var o = 0; o !== i; ++o)
                    r[n + o] = r[o];
                a = t
            } else {
                var s = t / (a += t);
                this._mixBufferRegion(r, n, 0, s, i)
            }
            this.cumulativeWeight = a
        }
    }, {
        key: "accumulateAdditive",
        value: function(e) {
            var t = this.buffer
              , r = this.valueSize
              , i = r * this._addIndex;
            0 === this.cumulativeWeightAdditive && this._setIdentity(),
            this._mixBufferRegionAdditive(t, i, 0, e, r),
            this.cumulativeWeightAdditive += e
        }
    }, {
        key: "apply",
        value: function(e) {
            var t = this.valueSize
              , r = this.buffer
              , i = e * t + t
              , n = this.cumulativeWeight
              , a = this.cumulativeWeightAdditive
              , o = this.binding;
            if (this.cumulativeWeight = 0,
            this.cumulativeWeightAdditive = 0,
            n < 1) {
                var s = t * this._origIndex;
                this._mixBufferRegion(r, i, s, 1 - n, t)
            }
            a > 0 && this._mixBufferRegionAdditive(r, i, this._addIndex * t, 1, t);
            for (var l = t, u = t + t; l !== u; ++l)
                if (r[l] !== r[l + t]) {
                    o.setValue(r, i);
                    break
                }
        }
    }, {
        key: "saveOriginalState",
        value: function() {
            var e = this.binding
              , t = this.buffer
              , r = this.valueSize
              , i = r * this._origIndex;
            e.getValue(t, i);
            for (var n = r, a = i; n !== a; ++n)
                t[n] = t[i + n % r];
            this._setIdentity(),
            this.cumulativeWeight = 0,
            this.cumulativeWeightAdditive = 0
        }
    }, {
        key: "restoreOriginalState",
        value: function() {
            var e = 3 * this.valueSize;
            this.binding.setValue(this.buffer, e)
        }
    }, {
        key: "_setAdditiveIdentityNumeric",
        value: function() {
            for (var e = this._addIndex * this.valueSize, t = e + this.valueSize, r = e; r < t; r++)
                this.buffer[r] = 0
        }
    }, {
        key: "_setAdditiveIdentityQuaternion",
        value: function() {
            this._setAdditiveIdentityNumeric(),
            this.buffer[this._addIndex * this.valueSize + 3] = 1
        }
    }, {
        key: "_setAdditiveIdentityOther",
        value: function() {
            for (var e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize, r = 0; r < this.valueSize; r++)
                this.buffer[t + r] = this.buffer[e + r]
        }
    }, {
        key: "_select",
        value: function(e, t, r, i, n) {
            if (i >= .5)
                for (var a = 0; a !== n; ++a)
                    e[t + a] = e[r + a]
        }
    }, {
        key: "_slerp",
        value: function(e, t, r, i) {
            Quaternion.slerpFlat(e, t, e, t, e, r, i)
        }
    }, {
        key: "_slerpAdditive",
        value: function(e, t, r, i, n) {
            var a = this._workIndex * n;
            Quaternion.multiplyQuaternionsFlat(e, a, e, t, e, r),
            Quaternion.slerpFlat(e, t, e, t, e, a, i)
        }
    }, {
        key: "_lerp",
        value: function(e, t, r, i, n) {
            for (var a = 1 - i, o = 0; o !== n; ++o) {
                var s = t + o;
                e[s] = e[s] * a + e[r + o] * i
            }
        }
    }, {
        key: "_lerpAdditive",
        value: function(e, t, r, i, n) {
            for (var a = 0; a !== n; ++a) {
                var o = t + a;
                e[o] = e[o] + e[r + a] * i
            }
        }
    }]),
    e
}()
  , _RESERVED_CHARS_RE = "\\[\\]\\.:\\/"
  , _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]","g")
  , _wordChar = "[^" + _RESERVED_CHARS_RE + "]"
  , _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]"
  , _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar)
  , _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot)
  , _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar)
  , _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar)
  , _trackRe = new RegExp("^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$")
  , _supportedObjectNames = ["material", "materials", "bones"]
  , Composite = function() {
    function e(t, r, i) {
        _classCallCheck(this, e);
        var n = i || PropertyBinding.parseTrackName(r);
        this._targetGroup = t,
        this._bindings = t.subscribe_(r, n)
    }
    return _createClass(e, [{
        key: "getValue",
        value: function(e, t) {
            this.bind();
            var r = this._targetGroup.nCachedObjects_
              , i = this._bindings[r];
            void 0 !== i && i.getValue(e, t)
        }
    }, {
        key: "setValue",
        value: function(e, t) {
            for (var r = this._bindings, i = this._targetGroup.nCachedObjects_, n = r.length; i !== n; ++i)
                r[i].setValue(e, t)
        }
    }, {
        key: "bind",
        value: function() {
            for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t)
                e[t].bind()
        }
    }, {
        key: "unbind",
        value: function() {
            for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t)
                e[t].unbind()
        }
    }]),
    e
}()
  , PropertyBinding = function() {
    function e(t, r, i) {
        _classCallCheck(this, e),
        this.path = r,
        this.parsedPath = i || e.parseTrackName(r),
        this.node = e.findNode(t, this.parsedPath.nodeName) || t,
        this.rootNode = t,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound
    }
    return _createClass(e, [{
        key: "_getValue_unavailable",
        value: function() {}
    }, {
        key: "_setValue_unavailable",
        value: function() {}
    }, {
        key: "_getValue_direct",
        value: function(e, t) {
            e[t] = this.targetObject[this.propertyName]
        }
    }, {
        key: "_getValue_array",
        value: function(e, t) {
            for (var r = this.resolvedProperty, i = 0, n = r.length; i !== n; ++i)
                e[t++] = r[i]
        }
    }, {
        key: "_getValue_arrayElement",
        value: function(e, t) {
            e[t] = this.resolvedProperty[this.propertyIndex]
        }
    }, {
        key: "_getValue_toArray",
        value: function(e, t) {
            this.resolvedProperty.toArray(e, t)
        }
    }, {
        key: "_setValue_direct",
        value: function(e, t) {
            this.targetObject[this.propertyName] = e[t]
        }
    }, {
        key: "_setValue_direct_setNeedsUpdate",
        value: function(e, t) {
            this.targetObject[this.propertyName] = e[t],
            this.targetObject.needsUpdate = !0
        }
    }, {
        key: "_setValue_direct_setMatrixWorldNeedsUpdate",
        value: function(e, t) {
            this.targetObject[this.propertyName] = e[t],
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
    }, {
        key: "_setValue_array",
        value: function(e, t) {
            for (var r = this.resolvedProperty, i = 0, n = r.length; i !== n; ++i)
                r[i] = e[t++]
        }
    }, {
        key: "_setValue_array_setNeedsUpdate",
        value: function(e, t) {
            for (var r = this.resolvedProperty, i = 0, n = r.length; i !== n; ++i)
                r[i] = e[t++];
            this.targetObject.needsUpdate = !0
        }
    }, {
        key: "_setValue_array_setMatrixWorldNeedsUpdate",
        value: function(e, t) {
            for (var r = this.resolvedProperty, i = 0, n = r.length; i !== n; ++i)
                r[i] = e[t++];
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
    }, {
        key: "_setValue_arrayElement",
        value: function(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t]
        }
    }, {
        key: "_setValue_arrayElement_setNeedsUpdate",
        value: function(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t],
            this.targetObject.needsUpdate = !0
        }
    }, {
        key: "_setValue_arrayElement_setMatrixWorldNeedsUpdate",
        value: function(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t],
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
    }, {
        key: "_setValue_fromArray",
        value: function(e, t) {
            this.resolvedProperty.fromArray(e, t)
        }
    }, {
        key: "_setValue_fromArray_setNeedsUpdate",
        value: function(e, t) {
            this.resolvedProperty.fromArray(e, t),
            this.targetObject.needsUpdate = !0
        }
    }, {
        key: "_setValue_fromArray_setMatrixWorldNeedsUpdate",
        value: function(e, t) {
            this.resolvedProperty.fromArray(e, t),
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
    }, {
        key: "_getValue_unbound",
        value: function(e, t) {
            this.bind(),
            this.getValue(e, t)
        }
    }, {
        key: "_setValue_unbound",
        value: function(e, t) {
            this.bind(),
            this.setValue(e, t)
        }
    }, {
        key: "bind",
        value: function() {
            var t = this.node
              , r = this.parsedPath
              , i = r.objectName
              , n = r.propertyName
              , a = r.propertyIndex;
            if (t || (t = e.findNode(this.rootNode, r.nodeName) || this.rootNode,
            this.node = t),
            this.getValue = this._getValue_unavailable,
            this.setValue = this._setValue_unavailable,
            t) {
                if (i) {
                    var o = r.objectIndex;
                    switch (i) {
                    case "materials":
                        if (!t.material)
                            return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        if (!t.material.materials)
                            return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                        t = t.material.materials;
                        break;
                    case "bones":
                        if (!t.skeleton)
                            return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                        t = t.skeleton.bones;
                        for (var s = 0; s < t.length; s++)
                            if (t[s].name === o) {
                                o = s;
                                break
                            }
                        break;
                    default:
                        if (void 0 === t[i])
                            return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                        t = t[i]
                    }
                    if (void 0 !== o) {
                        if (void 0 === t[o])
                            return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                        t = t[o]
                    }
                }
                var l = t[n];
                if (void 0 !== l) {
                    var u = this.Versioning.None;
                    this.targetObject = t,
                    void 0 !== t.needsUpdate ? u = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (u = this.Versioning.MatrixWorldNeedsUpdate);
                    var c = this.BindingType.Direct;
                    if (void 0 !== a) {
                        if ("morphTargetInfluences" === n) {
                            if (!t.geometry)
                                return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                            if (!t.geometry.isBufferGeometry)
                                return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
                            if (!t.geometry.morphAttributes)
                                return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                            void 0 !== t.morphTargetDictionary[a] && (a = t.morphTargetDictionary[a])
                        }
                        c = this.BindingType.ArrayElement,
                        this.resolvedProperty = l,
                        this.propertyIndex = a
                    } else
                        void 0 !== l.fromArray && void 0 !== l.toArray ? (c = this.BindingType.HasFromToArray,
                        this.resolvedProperty = l) : Array.isArray(l) ? (c = this.BindingType.EntireArray,
                        this.resolvedProperty = l) : this.propertyName = n;
                    this.getValue = this.GetterByBindingType[c],
                    this.setValue = this.SetterByBindingTypeAndVersioning[c][u]
                } else {
                    var h = r.nodeName;
                    console.error("THREE.PropertyBinding: Trying to update property for track: " + h + "." + n + " but it wasn't found.", t)
                }
            } else
                console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.")
        }
    }, {
        key: "unbind",
        value: function() {
            this.node = null,
            this.getValue = this._getValue_unbound,
            this.setValue = this._setValue_unbound
        }
    }], [{
        key: "create",
        value: function(t, r, i) {
            return t && t.isAnimationObjectGroup ? new e.Composite(t,r,i) : new e(t,r,i)
        }
    }, {
        key: "sanitizeNodeName",
        value: function(e) {
            return e.replace(/\s/g, "_").replace(_reservedRe, "")
        }
    }, {
        key: "parseTrackName",
        value: function(e) {
            var t = _trackRe.exec(e);
            if (null === t)
                throw new Error("PropertyBinding: Cannot parse trackName: " + e);
            var r = {
                nodeName: t[2],
                objectName: t[3],
                objectIndex: t[4],
                propertyName: t[5],
                propertyIndex: t[6]
            }
              , i = r.nodeName && r.nodeName.lastIndexOf(".");
            if (void 0 !== i && -1 !== i) {
                var n = r.nodeName.substring(i + 1);
                -1 !== _supportedObjectNames.indexOf(n) && (r.nodeName = r.nodeName.substring(0, i),
                r.objectName = n)
            }
            if (null === r.propertyName || 0 === r.propertyName.length)
                throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
            return r
        }
    }, {
        key: "findNode",
        value: function(e, t) {
            if (void 0 === t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid)
                return e;
            if (e.skeleton) {
                var r = e.skeleton.getBoneByName(t);
                if (void 0 !== r)
                    return r
            }
            if (e.children) {
                var i = function e(r) {
                    for (var i = 0; i < r.length; i++) {
                        var n = r[i];
                        if (n.name === t || n.uuid === t)
                            return n;
                        var a = e(n.children);
                        if (a)
                            return a
                    }
                    return null
                }(e.children);
                if (i)
                    return i
            }
            return null
        }
    }]),
    e
}();
PropertyBinding.Composite = Composite,
PropertyBinding.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
},
PropertyBinding.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
},
PropertyBinding.prototype.GetterByBindingType = [PropertyBinding.prototype._getValue_direct, PropertyBinding.prototype._getValue_array, PropertyBinding.prototype._getValue_arrayElement, PropertyBinding.prototype._getValue_toArray],
PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [[PropertyBinding.prototype._setValue_direct, PropertyBinding.prototype._setValue_direct_setNeedsUpdate, PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [PropertyBinding.prototype._setValue_array, PropertyBinding.prototype._setValue_array_setNeedsUpdate, PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate], [PropertyBinding.prototype._setValue_arrayElement, PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate, PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [PropertyBinding.prototype._setValue_fromArray, PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate, PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
var AnimationAction = function() {
    function e(t, r) {
        var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null
          , n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : r.blendMode;
        _classCallCheck(this, e),
        this._mixer = t,
        this._clip = r,
        this._localRoot = i,
        this.blendMode = n;
        for (var a = r.tracks, o = a.length, s = new Array(o), l = {
            endingStart: ZeroCurvatureEnding,
            endingEnd: ZeroCurvatureEnding
        }, u = 0; u !== o; ++u) {
            var c = a[u].createInterpolant(null);
            s[u] = c,
            c.settings = l
        }
        this._interpolantSettings = l,
        this._interpolants = s,
        this._propertyBindings = new Array(o),
        this._cacheIndex = null,
        this._byClipCacheIndex = null,
        this._timeScaleInterpolant = null,
        this._weightInterpolant = null,
        this.loop = LoopRepeat,
        this._loopCount = -1,
        this._startTime = null,
        this.time = 0,
        this.timeScale = 1,
        this._effectiveTimeScale = 1,
        this.weight = 1,
        this._effectiveWeight = 1,
        this.repetitions = 1 / 0,
        this.paused = !1,
        this.enabled = !0,
        this.clampWhenFinished = !1,
        this.zeroSlopeAtStart = !0,
        this.zeroSlopeAtEnd = !0
    }
    return _createClass(e, [{
        key: "play",
        value: function() {
            return this._mixer._activateAction(this),
            this
        }
    }, {
        key: "stop",
        value: function() {
            return this._mixer._deactivateAction(this),
            this.reset()
        }
    }, {
        key: "reset",
        value: function() {
            return this.paused = !1,
            this.enabled = !0,
            this.time = 0,
            this._loopCount = -1,
            this._startTime = null,
            this.stopFading().stopWarping()
        }
    }, {
        key: "isRunning",
        value: function() {
            return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
        }
    }, {
        key: "isScheduled",
        value: function() {
            return this._mixer._isActiveAction(this)
        }
    }, {
        key: "startAt",
        value: function(e) {
            return this._startTime = e,
            this
        }
    }, {
        key: "setLoop",
        value: function(e, t) {
            return this.loop = e,
            this.repetitions = t,
            this
        }
    }, {
        key: "setEffectiveWeight",
        value: function(e) {
            return this.weight = e,
            this._effectiveWeight = this.enabled ? e : 0,
            this.stopFading()
        }
    }, {
        key: "getEffectiveWeight",
        value: function() {
            return this._effectiveWeight
        }
    }, {
        key: "fadeIn",
        value: function(e) {
            return this._scheduleFading(e, 0, 1)
        }
    }, {
        key: "fadeOut",
        value: function(e) {
            return this._scheduleFading(e, 1, 0)
        }
    }, {
        key: "crossFadeFrom",
        value: function(e, t, r) {
            if (e.fadeOut(t),
            this.fadeIn(t),
            r) {
                var i = this._clip.duration
                  , n = e._clip.duration
                  , a = n / i
                  , o = i / n;
                e.warp(1, a, t),
                this.warp(o, 1, t)
            }
            return this
        }
    }, {
        key: "crossFadeTo",
        value: function(e, t, r) {
            return e.crossFadeFrom(this, t, r)
        }
    }, {
        key: "stopFading",
        value: function() {
            var e = this._weightInterpolant;
            return null !== e && (this._weightInterpolant = null,
            this._mixer._takeBackControlInterpolant(e)),
            this
        }
    }, {
        key: "setEffectiveTimeScale",
        value: function(e) {
            return this.timeScale = e,
            this._effectiveTimeScale = this.paused ? 0 : e,
            this.stopWarping()
        }
    }, {
        key: "getEffectiveTimeScale",
        value: function() {
            return this._effectiveTimeScale
        }
    }, {
        key: "setDuration",
        value: function(e) {
            return this.timeScale = this._clip.duration / e,
            this.stopWarping()
        }
    }, {
        key: "syncWith",
        value: function(e) {
            return this.time = e.time,
            this.timeScale = e.timeScale,
            this.stopWarping()
        }
    }, {
        key: "halt",
        value: function(e) {
            return this.warp(this._effectiveTimeScale, 0, e)
        }
    }, {
        key: "warp",
        value: function(e, t, r) {
            var i = this._mixer
              , n = i.time
              , a = this.timeScale
              , o = this._timeScaleInterpolant;
            null === o && (o = i._lendControlInterpolant(),
            this._timeScaleInterpolant = o);
            var s = o.parameterPositions
              , l = o.sampleValues;
            return s[0] = n,
            s[1] = n + r,
            l[0] = e / a,
            l[1] = t / a,
            this
        }
    }, {
        key: "stopWarping",
        value: function() {
            var e = this._timeScaleInterpolant;
            return null !== e && (this._timeScaleInterpolant = null,
            this._mixer._takeBackControlInterpolant(e)),
            this
        }
    }, {
        key: "getMixer",
        value: function() {
            return this._mixer
        }
    }, {
        key: "getClip",
        value: function() {
            return this._clip
        }
    }, {
        key: "getRoot",
        value: function() {
            return this._localRoot || this._mixer._root
        }
    }, {
        key: "_update",
        value: function(e, t, r, i) {
            if (this.enabled) {
                var n = this._startTime;
                if (null !== n) {
                    var a = (e - n) * r;
                    if (a < 0 || 0 === r)
                        return;
                    this._startTime = null,
                    t = r * a
                }
                t *= this._updateTimeScale(e);
                var o = this._updateTime(t)
                  , s = this._updateWeight(e);
                if (s > 0) {
                    var l = this._interpolants
                      , u = this._propertyBindings;
                    if (this.blendMode === AdditiveAnimationBlendMode)
                        for (var c = 0, h = l.length; c !== h; ++c)
                            l[c].evaluate(o),
                            u[c].accumulateAdditive(s);
                    else
                        for (var d = 0, p = l.length; d !== p; ++d)
                            l[d].evaluate(o),
                            u[d].accumulate(i, s)
                }
            } else
                this._updateWeight(e)
        }
    }, {
        key: "_updateWeight",
        value: function(e) {
            var t = 0;
            if (this.enabled) {
                t = this.weight;
                var r = this._weightInterpolant;
                if (null !== r) {
                    var i = r.evaluate(e)[0];
                    t *= i,
                    e > r.parameterPositions[1] && (this.stopFading(),
                    0 === i && (this.enabled = !1))
                }
            }
            return this._effectiveWeight = t,
            t
        }
    }, {
        key: "_updateTimeScale",
        value: function(e) {
            var t = 0;
            if (!this.paused) {
                t = this.timeScale;
                var r = this._timeScaleInterpolant;
                null !== r && (t *= r.evaluate(e)[0],
                e > r.parameterPositions[1] && (this.stopWarping(),
                0 === t ? this.paused = !0 : this.timeScale = t))
            }
            return this._effectiveTimeScale = t,
            t
        }
    }, {
        key: "_updateTime",
        value: function(e) {
            var t = this._clip.duration
              , r = this.loop
              , i = this.time + e
              , n = this._loopCount
              , a = r === LoopPingPong;
            if (0 === e)
                return -1 === n ? i : a && 1 == (1 & n) ? t - i : i;
            if (r === LoopOnce) {
                -1 === n && (this._loopCount = 0,
                this._setEndings(!0, !0, !1));
                e: {
                    if (i >= t)
                        i = t;
                    else {
                        if (!(i < 0)) {
                            this.time = i;
                            break e
                        }
                        i = 0
                    }
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                    this.time = i,
                    this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: e < 0 ? -1 : 1
                    })
                }
            } else {
                if (-1 === n && (e >= 0 ? (n = 0,
                this._setEndings(!0, 0 === this.repetitions, a)) : this._setEndings(0 === this.repetitions, !0, a)),
                i >= t || i < 0) {
                    var o = Math.floor(i / t);
                    i -= t * o,
                    n += Math.abs(o);
                    var s = this.repetitions - n;
                    if (s <= 0)
                        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                        i = e > 0 ? t : 0,
                        this.time = i,
                        this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: e > 0 ? 1 : -1
                        });
                    else {
                        if (1 === s) {
                            var l = e < 0;
                            this._setEndings(l, !l, a)
                        } else
                            this._setEndings(!1, !1, a);
                        this._loopCount = n,
                        this.time = i,
                        this._mixer.dispatchEvent({
                            type: "loop",
                            action: this,
                            loopDelta: o
                        })
                    }
                } else
                    this.time = i;
                if (a && 1 == (1 & n))
                    return t - i
            }
            return i
        }
    }, {
        key: "_setEndings",
        value: function(e, t, r) {
            var i = this._interpolantSettings;
            r ? (i.endingStart = ZeroSlopeEnding,
            i.endingEnd = ZeroSlopeEnding) : (i.endingStart = e ? this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding : WrapAroundEnding,
            i.endingEnd = t ? this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding : WrapAroundEnding)
        }
    }, {
        key: "_scheduleFading",
        value: function(e, t, r) {
            var i = this._mixer
              , n = i.time
              , a = this._weightInterpolant;
            null === a && (a = i._lendControlInterpolant(),
            this._weightInterpolant = a);
            var o = a.parameterPositions
              , s = a.sampleValues;
            return o[0] = n,
            s[0] = t,
            o[1] = n + e,
            s[1] = r,
            this
        }
    }]),
    e
}()
  , AnimationMixer = function(e) {
    _inherits(r, EventDispatcher);
    var t = _createSuper(r);
    function r(e) {
        var i;
        return _classCallCheck(this, r),
        (i = t.call(this))._root = e,
        i._initMemoryManager(),
        i._accuIndex = 0,
        i.time = 0,
        i.timeScale = 1,
        i
    }
    return _createClass(r, [{
        key: "_bindAction",
        value: function(e, t) {
            var r = e._localRoot || this._root
              , i = e._clip.tracks
              , n = i.length
              , a = e._propertyBindings
              , o = e._interpolants
              , s = r.uuid
              , l = this._bindingsByRootAndName
              , u = l[s];
            void 0 === u && (u = {},
            l[s] = u);
            for (var c = 0; c !== n; ++c) {
                var h = i[c]
                  , d = h.name
                  , p = u[d];
                if (void 0 !== p)
                    ++p.referenceCount,
                    a[c] = p;
                else {
                    if (void 0 !== (p = a[c])) {
                        null === p._cacheIndex && (++p.referenceCount,
                        this._addInactiveBinding(p, s, d));
                        continue
                    }
                    var f = t && t._propertyBindings[c].binding.parsedPath;
                    ++(p = new PropertyMixer(PropertyBinding.create(r, d, f),h.ValueTypeName,h.getValueSize())).referenceCount,
                    this._addInactiveBinding(p, s, d),
                    a[c] = p
                }
                o[c].resultBuffer = p.buffer
            }
        }
    }, {
        key: "_activateAction",
        value: function(e) {
            if (!this._isActiveAction(e)) {
                if (null === e._cacheIndex) {
                    var t = (e._localRoot || this._root).uuid
                      , r = e._clip.uuid
                      , i = this._actionsByClip[r];
                    this._bindAction(e, i && i.knownActions[0]),
                    this._addInactiveAction(e, r, t)
                }
                for (var n = e._propertyBindings, a = 0, o = n.length; a !== o; ++a) {
                    var s = n[a];
                    0 == s.useCount++ && (this._lendBinding(s),
                    s.saveOriginalState())
                }
                this._lendAction(e)
            }
        }
    }, {
        key: "_deactivateAction",
        value: function(e) {
            if (this._isActiveAction(e)) {
                for (var t = e._propertyBindings, r = 0, i = t.length; r !== i; ++r) {
                    var n = t[r];
                    0 == --n.useCount && (n.restoreOriginalState(),
                    this._takeBackBinding(n))
                }
                this._takeBackAction(e)
            }
        }
    }, {
        key: "_initMemoryManager",
        value: function() {
            this._actions = [],
            this._nActiveActions = 0,
            this._actionsByClip = {},
            this._bindings = [],
            this._nActiveBindings = 0,
            this._bindingsByRootAndName = {},
            this._controlInterpolants = [],
            this._nActiveControlInterpolants = 0;
            var e = this;
            this.stats = {
                actions: {
                    get total() {
                        return e._actions.length
                    },
                    get inUse() {
                        return e._nActiveActions
                    }
                },
                bindings: {
                    get total() {
                        return e._bindings.length
                    },
                    get inUse() {
                        return e._nActiveBindings
                    }
                },
                controlInterpolants: {
                    get total() {
                        return e._controlInterpolants.length
                    },
                    get inUse() {
                        return e._nActiveControlInterpolants
                    }
                }
            }
        }
    }, {
        key: "_isActiveAction",
        value: function(e) {
            var t = e._cacheIndex;
            return null !== t && t < this._nActiveActions
        }
    }, {
        key: "_addInactiveAction",
        value: function(e, t, r) {
            var i = this._actions
              , n = this._actionsByClip
              , a = n[t];
            if (void 0 === a)
                a = {
                    knownActions: [e],
                    actionByRoot: {}
                },
                e._byClipCacheIndex = 0,
                n[t] = a;
            else {
                var o = a.knownActions;
                e._byClipCacheIndex = o.length,
                o.push(e)
            }
            e._cacheIndex = i.length,
            i.push(e),
            a.actionByRoot[r] = e
        }
    }, {
        key: "_removeInactiveAction",
        value: function(e) {
            var t = this._actions
              , r = t[t.length - 1]
              , i = e._cacheIndex;
            r._cacheIndex = i,
            t[i] = r,
            t.pop(),
            e._cacheIndex = null;
            var n = e._clip.uuid
              , a = this._actionsByClip
              , o = a[n]
              , s = o.knownActions
              , l = s[s.length - 1]
              , u = e._byClipCacheIndex;
            l._byClipCacheIndex = u,
            s[u] = l,
            s.pop(),
            e._byClipCacheIndex = null,
            delete o.actionByRoot[(e._localRoot || this._root).uuid],
            0 === s.length && delete a[n],
            this._removeInactiveBindingsForAction(e)
        }
    }, {
        key: "_removeInactiveBindingsForAction",
        value: function(e) {
            for (var t = e._propertyBindings, r = 0, i = t.length; r !== i; ++r) {
                var n = t[r];
                0 == --n.referenceCount && this._removeInactiveBinding(n)
            }
        }
    }, {
        key: "_lendAction",
        value: function(e) {
            var t = this._actions
              , r = e._cacheIndex
              , i = this._nActiveActions++
              , n = t[i];
            e._cacheIndex = i,
            t[i] = e,
            n._cacheIndex = r,
            t[r] = n
        }
    }, {
        key: "_takeBackAction",
        value: function(e) {
            var t = this._actions
              , r = e._cacheIndex
              , i = --this._nActiveActions
              , n = t[i];
            e._cacheIndex = i,
            t[i] = e,
            n._cacheIndex = r,
            t[r] = n
        }
    }, {
        key: "_addInactiveBinding",
        value: function(e, t, r) {
            var i = this._bindingsByRootAndName
              , n = this._bindings
              , a = i[t];
            void 0 === a && (a = {},
            i[t] = a),
            a[r] = e,
            e._cacheIndex = n.length,
            n.push(e)
        }
    }, {
        key: "_removeInactiveBinding",
        value: function(e) {
            var t = this._bindings
              , r = e.binding
              , i = r.rootNode.uuid
              , n = r.path
              , a = this._bindingsByRootAndName
              , o = a[i]
              , s = t[t.length - 1]
              , l = e._cacheIndex;
            s._cacheIndex = l,
            t[l] = s,
            t.pop(),
            delete o[n],
            0 === Object.keys(o).length && delete a[i]
        }
    }, {
        key: "_lendBinding",
        value: function(e) {
            var t = this._bindings
              , r = e._cacheIndex
              , i = this._nActiveBindings++
              , n = t[i];
            e._cacheIndex = i,
            t[i] = e,
            n._cacheIndex = r,
            t[r] = n
        }
    }, {
        key: "_takeBackBinding",
        value: function(e) {
            var t = this._bindings
              , r = e._cacheIndex
              , i = --this._nActiveBindings
              , n = t[i];
            e._cacheIndex = i,
            t[i] = e,
            n._cacheIndex = r,
            t[r] = n
        }
    }, {
        key: "_lendControlInterpolant",
        value: function() {
            var e = this._controlInterpolants
              , t = this._nActiveControlInterpolants++
              , r = e[t];
            return void 0 === r && ((r = new LinearInterpolant(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer)).__cacheIndex = t,
            e[t] = r),
            r
        }
    }, {
        key: "_takeBackControlInterpolant",
        value: function(e) {
            var t = this._controlInterpolants
              , r = e.__cacheIndex
              , i = --this._nActiveControlInterpolants
              , n = t[i];
            e.__cacheIndex = i,
            t[i] = e,
            n.__cacheIndex = r,
            t[r] = n
        }
    }, {
        key: "clipAction",
        value: function(e, t, r) {
            var i = t || this._root
              , n = i.uuid
              , a = "string" == typeof e ? AnimationClip.findByName(i, e) : e
              , o = null !== a ? a.uuid : e
              , s = this._actionsByClip[o]
              , l = null;
            if (void 0 === r && (r = null !== a ? a.blendMode : NormalAnimationBlendMode),
            void 0 !== s) {
                var u = s.actionByRoot[n];
                if (void 0 !== u && u.blendMode === r)
                    return u;
                l = s.knownActions[0],
                null === a && (a = l._clip)
            }
            if (null === a)
                return null;
            var c = new AnimationAction(this,a,t,r);
            return this._bindAction(c, l),
            this._addInactiveAction(c, o, n),
            c
        }
    }, {
        key: "existingAction",
        value: function(e, t) {
            var r = t || this._root
              , i = r.uuid
              , n = "string" == typeof e ? AnimationClip.findByName(r, e) : e
              , a = n ? n.uuid : e
              , o = this._actionsByClip[a];
            return void 0 !== o && o.actionByRoot[i] || null
        }
    }, {
        key: "stopAllAction",
        value: function() {
            for (var e = this._actions, t = this._nActiveActions - 1; t >= 0; --t)
                e[t].stop();
            return this
        }
    }, {
        key: "update",
        value: function(e) {
            e *= this.timeScale;
            for (var t = this._actions, r = this._nActiveActions, i = this.time += e, n = Math.sign(e), a = this._accuIndex ^= 1, o = 0; o !== r; ++o)
                t[o]._update(i, e, n, a);
            for (var s = this._bindings, l = this._nActiveBindings, u = 0; u !== l; ++u)
                s[u].apply(a);
            return this
        }
    }, {
        key: "setTime",
        value: function(e) {
            this.time = 0;
            for (var t = 0; t < this._actions.length; t++)
                this._actions[t].time = 0;
            return this.update(e)
        }
    }, {
        key: "getRoot",
        value: function() {
            return this._root
        }
    }, {
        key: "uncacheClip",
        value: function(e) {
            var t = this._actions
              , r = e.uuid
              , i = this._actionsByClip
              , n = i[r];
            if (void 0 !== n) {
                for (var a = n.knownActions, o = 0, s = a.length; o !== s; ++o) {
                    var l = a[o];
                    this._deactivateAction(l);
                    var u = l._cacheIndex
                      , c = t[t.length - 1];
                    l._cacheIndex = null,
                    l._byClipCacheIndex = null,
                    c._cacheIndex = u,
                    t[u] = c,
                    t.pop(),
                    this._removeInactiveBindingsForAction(l)
                }
                delete i[r]
            }
        }
    }, {
        key: "uncacheRoot",
        value: function(e) {
            var t = e.uuid
              , r = this._actionsByClip;
            for (var i in r) {
                var n = r[i].actionByRoot[t];
                void 0 !== n && (this._deactivateAction(n),
                this._removeInactiveAction(n))
            }
            var a = this._bindingsByRootAndName[t];
            if (void 0 !== a)
                for (var o in a) {
                    var s = a[o];
                    s.restoreOriginalState(),
                    this._removeInactiveBinding(s)
                }
        }
    }, {
        key: "uncacheAction",
        value: function(e, t) {
            var r = this.existingAction(e, t);
            null !== r && (this._deactivateAction(r),
            this._removeInactiveAction(r))
        }
    }]),
    r
}();
AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
var InstancedInterleavedBuffer = function(e) {
    _inherits(r, InterleavedBuffer);
    var t = _createSuper(r);
    function r(e, i) {
        var n, a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
        return _classCallCheck(this, r),
        (n = t.call(this, e, i)).meshPerAttribute = a,
        n
    }
    return _createClass(r, [{
        key: "copy",
        value: function(e) {
            return _get(_getPrototypeOf(r.prototype), "copy", this).call(this, e),
            this.meshPerAttribute = e.meshPerAttribute,
            this
        }
    }, {
        key: "clone",
        value: function(e) {
            var t = _get(_getPrototypeOf(r.prototype), "clone", this).call(this, e);
            return t.meshPerAttribute = this.meshPerAttribute,
            t
        }
    }, {
        key: "toJSON",
        value: function(e) {
            var t = _get(_getPrototypeOf(r.prototype), "toJSON", this).call(this, e);
            return t.isInstancedInterleavedBuffer = !0,
            t.meshPerAttribute = this.meshPerAttribute,
            t
        }
    }]),
    r
}();
InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = !0;
var Spherical = function() {
    function e() {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1
          , r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
          , i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        return _classCallCheck(this, e),
        this.radius = t,
        this.phi = r,
        this.theta = i,
        this
    }
    return _createClass(e, [{
        key: "set",
        value: function(e, t, r) {
            return this.radius = e,
            this.phi = t,
            this.theta = r,
            this
        }
    }, {
        key: "copy",
        value: function(e) {
            return this.radius = e.radius,
            this.phi = e.phi,
            this.theta = e.theta,
            this
        }
    }, {
        key: "makeSafe",
        value: function() {
            var e = 1e-6;
            return this.phi = Math.max(e, Math.min(Math.PI - e, this.phi)),
            this
        }
    }, {
        key: "setFromVector3",
        value: function(e) {
            return this.setFromCartesianCoords(e.x, e.y, e.z)
        }
    }, {
        key: "setFromCartesianCoords",
        value: function(e, t, r) {
            return this.radius = Math.sqrt(e * e + t * t + r * r),
            0 === this.radius ? (this.theta = 0,
            this.phi = 0) : (this.theta = Math.atan2(e, r),
            this.phi = Math.acos(clamp(t / this.radius, -1, 1))),
            this
        }
    }, {
        key: "clone",
        value: function() {
            return (new this.constructor).copy(this)
        }
    }]),
    e
}()
  , _vector$2 = new Vector3
  , _boneMatrix = new Matrix4
  , _matrixWorldInv = new Matrix4
  , SkeletonHelper = function(e) {
    _inherits(r, LineSegments);
    var t = _createSuper(r);
    function r(e) {
        var i;
        _classCallCheck(this, r);
        for (var n = getBoneList(e), a = new BufferGeometry, o = [], s = [], l = new Color(0,0,1), u = new Color(0,1,0), c = 0; c < n.length; c++) {
            var h = n[c];
            h.parent && h.parent.isBone && (o.push(0, 0, 0),
            o.push(0, 0, 0),
            s.push(l.r, l.g, l.b),
            s.push(u.r, u.g, u.b))
        }
        a.setAttribute("position", new Float32BufferAttribute(o,3)),
        a.setAttribute("color", new Float32BufferAttribute(s,3));
        var d = new LineBasicMaterial({
            vertexColors: !0,
            depthTest: !1,
            depthWrite: !1,
            toneMapped: !1,
            transparent: !0
        });
        return (i = t.call(this, a, d)).type = "SkeletonHelper",
        i.isSkeletonHelper = !0,
        i.root = e,
        i.bones = n,
        i.matrix = e.matrixWorld,
        i.matrixAutoUpdate = !1,
        i
    }
    return _createClass(r, [{
        key: "updateMatrixWorld",
        value: function(e) {
            var t = this.bones
              , i = this.geometry
              , n = i.getAttribute("position");
            _matrixWorldInv.copy(this.root.matrixWorld).invert();
            for (var a = 0, o = 0; a < t.length; a++) {
                var s = t[a];
                s.parent && s.parent.isBone && (_boneMatrix.multiplyMatrices(_matrixWorldInv, s.matrixWorld),
                _vector$2.setFromMatrixPosition(_boneMatrix),
                n.setXYZ(o, _vector$2.x, _vector$2.y, _vector$2.z),
                _boneMatrix.multiplyMatrices(_matrixWorldInv, s.parent.matrixWorld),
                _vector$2.setFromMatrixPosition(_boneMatrix),
                n.setXYZ(o + 1, _vector$2.x, _vector$2.y, _vector$2.z),
                o += 2)
            }
            i.getAttribute("position").needsUpdate = !0,
            _get(_getPrototypeOf(r.prototype), "updateMatrixWorld", this).call(this, e)
        }
    }]),
    r
}();
function getBoneList(e) {
    var t = [];
    !0 === e.isBone && t.push(e);
    for (var r = 0; r < e.children.length; r++)
        t.push.apply(t, getBoneList(e.children[r]));
    return t
}
for (var GridHelper = function(e) {
    _inherits(r, LineSegments);
    var t = _createSuper(r);
    function r() {
        var e, i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 10, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 10, a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 4473924, o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 8947848;
        _classCallCheck(this, r),
        a = new Color(a),
        o = new Color(o);
        for (var s = n / 2, l = i / n, u = i / 2, c = [], h = [], d = 0, p = 0, f = -u; d <= n; d++,
        f += l) {
            c.push(-u, 0, f, u, 0, f),
            c.push(f, 0, -u, f, 0, u);
            var m = d === s ? a : o;
            m.toArray(h, p),
            p += 3,
            m.toArray(h, p),
            p += 3,
            m.toArray(h, p),
            p += 3,
            m.toArray(h, p),
            p += 3
        }
        var v = new BufferGeometry;
        v.setAttribute("position", new Float32BufferAttribute(c,3)),
        v.setAttribute("color", new Float32BufferAttribute(h,3));
        var g = new LineBasicMaterial({
            vertexColors: !0,
            toneMapped: !1
        });
        return (e = t.call(this, v, g)).type = "GridHelper",
        e
    }
    return _createClass(r)
}(), _baseTable = new Uint32Array(512), _shiftTable = new Uint32Array(512), _i286 = 0; _i286 < 256; ++_i286) {
    var e = _i286 - 127;
    e < -27 ? (_baseTable[_i286] = 0,
    _baseTable[256 | _i286] = 32768,
    _shiftTable[_i286] = 24,
    _shiftTable[256 | _i286] = 24) : e < -14 ? (_baseTable[_i286] = 1024 >> -e - 14,
    _baseTable[256 | _i286] = 1024 >> -e - 14 | 32768,
    _shiftTable[_i286] = -e - 1,
    _shiftTable[256 | _i286] = -e - 1) : e <= 15 ? (_baseTable[_i286] = e + 15 << 10,
    _baseTable[256 | _i286] = e + 15 << 10 | 32768,
    _shiftTable[_i286] = 13,
    _shiftTable[256 | _i286] = 13) : e < 128 ? (_baseTable[_i286] = 31744,
    _baseTable[256 | _i286] = 64512,
    _shiftTable[_i286] = 24,
    _shiftTable[256 | _i286] = 24) : (_baseTable[_i286] = 31744,
    _baseTable[256 | _i286] = 64512,
    _shiftTable[_i286] = 13,
    _shiftTable[256 | _i286] = 13)
}
for (var _mantissaTable = new Uint32Array(2048), _exponentTable = new Uint32Array(64), _offsetTable = new Uint32Array(64), _i287 = 1; _i287 < 1024; ++_i287) {
    for (var m = _i287 << 13, _e2 = 0; 0 == (8388608 & m); )
        m <<= 1,
        _e2 -= 8388608;
    m &= -8388609,
    _e2 += 947912704,
    _mantissaTable[_i287] = m | _e2
}
for (var _i288 = 1024; _i288 < 2048; ++_i288)
    _mantissaTable[_i288] = 939524096 + (_i288 - 1024 << 13);
for (var _i289 = 1; _i289 < 31; ++_i289)
    _exponentTable[_i289] = _i289 << 23;
_exponentTable[31] = 1199570944,
_exponentTable[32] = 2147483648;
for (var _i290 = 33; _i290 < 63; ++_i290)
    _exponentTable[_i290] = 2147483648 + (_i290 - 32 << 23);
_exponentTable[63] = 3347054592;
for (var _i291 = 1; _i291 < 64; ++_i291)
    32 !== _i291 && (_offsetTable[_i291] = 1024);
Curve.create = function(e, t) {
    return console.log("THREE.Curve.create() has been deprecated"),
    e.prototype = Object.create(Curve.prototype),
    e.prototype.constructor = e,
    e.prototype.getPoint = t,
    e
}
,
Path.prototype.fromPoints = function(e) {
    return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),
    this.setFromPoints(e)
}
,
GridHelper.prototype.setColors = function() {
    console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
}
,
SkeletonHelper.prototype.update = function() {
    console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
}
,
Loader.prototype.extractUrlBase = function(e) {
    return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),
    LoaderUtils.extractUrlBase(e)
}
,
Loader.Handlers = {
    add: function() {
        console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
    },
    get: function() {
        console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
    }
},
Box3.prototype.center = function(e) {
    return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),
    this.getCenter(e)
}
,
Box3.prototype.empty = function() {
    return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),
    this.isEmpty()
}
,
Box3.prototype.isIntersectionBox = function(e) {
    return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),
    this.intersectsBox(e)
}
,
Box3.prototype.isIntersectionSphere = function(e) {
    return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
    this.intersectsSphere(e)
}
,
Box3.prototype.size = function(e) {
    return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
    this.getSize(e)
}
,
Euler.prototype.toVector3 = function() {
    console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead")
}
,
Sphere.prototype.empty = function() {
    return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),
    this.isEmpty()
}
,
Frustum.prototype.setFromMatrix = function(e) {
    return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),
    this.setFromProjectionMatrix(e)
}
,
Matrix3.prototype.flattenToArrayOffset = function(e, t) {
    return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),
    this.toArray(e, t)
}
,
Matrix3.prototype.multiplyVector3 = function(e) {
    return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),
    e.applyMatrix3(this)
}
,
Matrix3.prototype.multiplyVector3Array = function() {
    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
}
,
Matrix3.prototype.applyToBufferAttribute = function(e) {
    return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),
    e.applyMatrix3(this)
}
,
Matrix3.prototype.applyToVector3Array = function() {
    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
}
,
Matrix3.prototype.getInverse = function(e) {
    return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),
    this.copy(e).invert()
}
,
Matrix4.prototype.extractPosition = function(e) {
    return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),
    this.copyPosition(e)
}
,
Matrix4.prototype.flattenToArrayOffset = function(e, t) {
    return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),
    this.toArray(e, t)
}
,
Matrix4.prototype.getPosition = function() {
    return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),
    (new Vector3).setFromMatrixColumn(this, 3)
}
,
Matrix4.prototype.setRotationFromQuaternion = function(e) {
    return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),
    this.makeRotationFromQuaternion(e)
}
,
Matrix4.prototype.multiplyToArray = function() {
    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
}
,
Matrix4.prototype.multiplyVector3 = function(e) {
    return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),
    e.applyMatrix4(this)
}
,
Matrix4.prototype.multiplyVector4 = function(e) {
    return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),
    e.applyMatrix4(this)
}
,
Matrix4.prototype.multiplyVector3Array = function() {
    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
}
,
Matrix4.prototype.rotateAxis = function(e) {
    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),
    e.transformDirection(this)
}
,
Matrix4.prototype.crossVector = function(e) {
    return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),
    e.applyMatrix4(this)
}
,
Matrix4.prototype.translate = function() {
    console.error("THREE.Matrix4: .translate() has been removed.")
}
,
Matrix4.prototype.rotateX = function() {
    console.error("THREE.Matrix4: .rotateX() has been removed.")
}
,
Matrix4.prototype.rotateY = function() {
    console.error("THREE.Matrix4: .rotateY() has been removed.")
}
,
Matrix4.prototype.rotateZ = function() {
    console.error("THREE.Matrix4: .rotateZ() has been removed.")
}
,
Matrix4.prototype.rotateByAxis = function() {
    console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
}
,
Matrix4.prototype.applyToBufferAttribute = function(e) {
    return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),
    e.applyMatrix4(this)
}
,
Matrix4.prototype.applyToVector3Array = function() {
    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
}
,
Matrix4.prototype.makeFrustum = function(e, t, r, i, n, a) {
    return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),
    this.makePerspective(e, t, i, r, n, a)
}
,
Matrix4.prototype.getInverse = function(e) {
    return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),
    this.copy(e).invert()
}
,
Plane.prototype.isIntersectionLine = function(e) {
    return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),
    this.intersectsLine(e)
}
,
Quaternion.prototype.multiplyVector3 = function(e) {
    return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),
    e.applyQuaternion(this)
}
,
Quaternion.prototype.inverse = function() {
    return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),
    this.invert()
}
,
Ray.prototype.isIntersectionBox = function(e) {
    return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),
    this.intersectsBox(e)
}
,
Ray.prototype.isIntersectionPlane = function(e) {
    return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),
    this.intersectsPlane(e)
}
,
Ray.prototype.isIntersectionSphere = function(e) {
    return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
    this.intersectsSphere(e)
}
,
Triangle.prototype.area = function() {
    return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),
    this.getArea()
}
,
Triangle.prototype.barycoordFromPoint = function(e, t) {
    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),
    this.getBarycoord(e, t)
}
,
Triangle.prototype.midpoint = function(e) {
    return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),
    this.getMidpoint(e)
}
,
Triangle.prototypenormal = function(e) {
    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),
    this.getNormal(e)
}
,
Triangle.prototype.plane = function(e) {
    return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),
    this.getPlane(e)
}
,
Triangle.barycoordFromPoint = function(e, t, r, i, n) {
    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),
    Triangle.getBarycoord(e, t, r, i, n)
}
,
Triangle.normal = function(e, t, r, i) {
    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),
    Triangle.getNormal(e, t, r, i)
}
,
Shape.prototype.extractAllPoints = function(e) {
    return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),
    this.extractPoints(e)
}
,
Shape.prototype.extrude = function(e) {
    return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),
    new ExtrudeGeometry(this,e)
}
,
Shape.prototype.makeGeometry = function(e) {
    return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),
    new ShapeGeometry(this,e)
}
,
Vector2.prototype.fromAttribute = function(e, t, r) {
    return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),
    this.fromBufferAttribute(e, t, r)
}
,
Vector2.prototype.distanceToManhattan = function(e) {
    return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),
    this.manhattanDistanceTo(e)
}
,
Vector2.prototype.lengthManhattan = function() {
    return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),
    this.manhattanLength()
}
,
Vector3.prototype.setEulerFromRotationMatrix = function() {
    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
}
,
Vector3.prototype.setEulerFromQuaternion = function() {
    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
}
,
Vector3.prototype.getPositionFromMatrix = function(e) {
    return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),
    this.setFromMatrixPosition(e)
}
,
Vector3.prototype.getScaleFromMatrix = function(e) {
    return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),
    this.setFromMatrixScale(e)
}
,
Vector3.prototype.getColumnFromMatrix = function(e, t) {
    return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),
    this.setFromMatrixColumn(t, e)
}
,
Vector3.prototype.applyProjection = function(e) {
    return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),
    this.applyMatrix4(e)
}
,
Vector3.prototype.fromAttribute = function(e, t, r) {
    return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),
    this.fromBufferAttribute(e, t, r)
}
,
Vector3.prototype.distanceToManhattan = function(e) {
    return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),
    this.manhattanDistanceTo(e)
}
,
Vector3.prototype.lengthManhattan = function() {
    return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),
    this.manhattanLength()
}
,
Vector4.prototype.fromAttribute = function(e, t, r) {
    return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),
    this.fromBufferAttribute(e, t, r)
}
,
Vector4.prototype.lengthManhattan = function() {
    return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),
    this.manhattanLength()
}
,
Object3D.prototype.getChildByName = function(e) {
    return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),
    this.getObjectByName(e)
}
,
Object3D.prototype.renderDepth = function() {
    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
}
,
Object3D.prototype.translate = function(e, t) {
    return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),
    this.translateOnAxis(t, e)
}
,
Object3D.prototype.getWorldRotation = function() {
    console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
}
,
Object3D.prototype.applyMatrix = function(e) {
    return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),
    this.applyMatrix4(e)
}
,
Object.defineProperties(Object3D.prototype, {
    eulerOrder: {
        get: function() {
            return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
            this.rotation.order
        },
        set: function(e) {
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
            this.rotation.order = e
        }
    },
    useQuaternion: {
        get: function() {
            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
        },
        set: function() {
            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
        }
    }
}),
Mesh.prototype.setDrawMode = function() {
    console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
}
,
Object.defineProperties(Mesh.prototype, {
    drawMode: {
        get: function() {
            return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),
            TrianglesDrawMode
        },
        set: function() {
            console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
        }
    }
}),
SkinnedMesh.prototype.initBones = function() {
    console.error("THREE.SkinnedMesh: initBones() has been removed.")
}
,
PerspectiveCamera.prototype.setLens = function(e, t) {
    console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),
    void 0 !== t && (this.filmGauge = t),
    this.setFocalLength(e)
}
,
Object.defineProperties(Light.prototype, {
    onlyShadow: {
        set: function() {
            console.warn("THREE.Light: .onlyShadow has been removed.")
        }
    },
    shadowCameraFov: {
        set: function(e) {
            console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),
            this.shadow.camera.fov = e
        }
    },
    shadowCameraLeft: {
        set: function(e) {
            console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),
            this.shadow.camera.left = e
        }
    },
    shadowCameraRight: {
        set: function(e) {
            console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),
            this.shadow.camera.right = e
        }
    },
    shadowCameraTop: {
        set: function(e) {
            console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),
            this.shadow.camera.top = e
        }
    },
    shadowCameraBottom: {
        set: function(e) {
            console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),
            this.shadow.camera.bottom = e
        }
    },
    shadowCameraNear: {
        set: function(e) {
            console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),
            this.shadow.camera.near = e
        }
    },
    shadowCameraFar: {
        set: function(e) {
            console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),
            this.shadow.camera.far = e
        }
    },
    shadowCameraVisible: {
        set: function() {
            console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
        }
    },
    shadowBias: {
        set: function(e) {
            console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
            this.shadow.bias = e
        }
    },
    shadowDarkness: {
        set: function() {
            console.warn("THREE.Light: .shadowDarkness has been removed.")
        }
    },
    shadowMapWidth: {
        set: function(e) {
            console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),
            this.shadow.mapSize.width = e
        }
    },
    shadowMapHeight: {
        set: function(e) {
            console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),
            this.shadow.mapSize.height = e
        }
    }
}),
Object.defineProperties(BufferAttribute.prototype, {
    length: {
        get: function() {
            return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),
            this.array.length
        }
    },
    dynamic: {
        get: function() {
            return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),
            this.usage === DynamicDrawUsage
        },
        set: function() {
            console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),
            this.setUsage(DynamicDrawUsage)
        }
    }
}),
BufferAttribute.prototype.setDynamic = function(e) {
    return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),
    this.setUsage(!0 === e ? DynamicDrawUsage : StaticDrawUsage),
    this
}
,
BufferAttribute.prototype.copyIndicesArray = function() {
    console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
}
,
BufferAttribute.prototype.setArray = function() {
    console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
}
,
BufferGeometry.prototype.addIndex = function(e) {
    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),
    this.setIndex(e)
}
,
BufferGeometry.prototype.addAttribute = function(e, t) {
    return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),
    t && t.isBufferAttribute || t && t.isInterleavedBufferAttribute ? "index" === e ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),
    this.setIndex(t),
    this) : this.setAttribute(e, t) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),
    this.setAttribute(e, new BufferAttribute(arguments[1],arguments[2])))
}
,
BufferGeometry.prototype.addDrawCall = function(e, t, r) {
    void 0 !== r && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),
    console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),
    this.addGroup(e, t)
}
,
BufferGeometry.prototype.clearDrawCalls = function() {
    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),
    this.clearGroups()
}
,
BufferGeometry.prototype.computeOffsets = function() {
    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
}
,
BufferGeometry.prototype.removeAttribute = function(e) {
    return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),
    this.deleteAttribute(e)
}
,
BufferGeometry.prototype.applyMatrix = function(e) {
    return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),
    this.applyMatrix4(e)
}
,
Object.defineProperties(BufferGeometry.prototype, {
    drawcalls: {
        get: function() {
            return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),
            this.groups
        }
    },
    offsets: {
        get: function() {
            return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),
            this.groups
        }
    }
}),
InterleavedBuffer.prototype.setDynamic = function(e) {
    return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),
    this.setUsage(!0 === e ? DynamicDrawUsage : StaticDrawUsage),
    this
}
,
InterleavedBuffer.prototype.setArray = function() {
    console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
}
,
ExtrudeGeometry.prototype.getArrays = function() {
    console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")
}
,
ExtrudeGeometry.prototype.addShapeList = function() {
    console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")
}
,
ExtrudeGeometry.prototype.addShape = function() {
    console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")
}
,
Scene.prototype.dispose = function() {
    console.error("THREE.Scene: .dispose() has been removed.")
}
,
Object.defineProperties(Material.prototype, {
    wrapAround: {
        get: function() {
            console.warn("THREE.Material: .wrapAround has been removed.")
        },
        set: function() {
            console.warn("THREE.Material: .wrapAround has been removed.")
        }
    },
    overdraw: {
        get: function() {
            console.warn("THREE.Material: .overdraw has been removed.")
        },
        set: function() {
            console.warn("THREE.Material: .overdraw has been removed.")
        }
    },
    wrapRGB: {
        get: function() {
            return console.warn("THREE.Material: .wrapRGB has been removed."),
            new Color
        }
    },
    shading: {
        get: function() {
            console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
        },
        set: function(e) {
            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
            this.flatShading = e === FlatShading
        }
    },
    stencilMask: {
        get: function() {
            return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."),
            this.stencilFuncMask
        },
        set: function(e) {
            console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."),
            this.stencilFuncMask = e
        }
    },
    vertexTangents: {
        get: function() {
            console.warn("THREE." + this.type + ": .vertexTangents has been removed.")
        },
        set: function() {
            console.warn("THREE." + this.type + ": .vertexTangents has been removed.")
        }
    }
}),
Object.defineProperties(ShaderMaterial.prototype, {
    derivatives: {
        get: function() {
            return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
            this.extensions.derivatives
        },
        set: function(e) {
            console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
            this.extensions.derivatives = e
        }
    }
}),
WebGLRenderer.prototype.clearTarget = function(e, t, r, i) {
    console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),
    this.setRenderTarget(e),
    this.clear(t, r, i)
}
,
WebGLRenderer.prototype.animate = function(e) {
    console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),
    this.setAnimationLoop(e)
}
,
WebGLRenderer.prototype.getCurrentRenderTarget = function() {
    return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),
    this.getRenderTarget()
}
,
WebGLRenderer.prototype.getMaxAnisotropy = function() {
    return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),
    this.capabilities.getMaxAnisotropy()
}
,
WebGLRenderer.prototype.getPrecision = function() {
    return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),
    this.capabilities.precision
}
,
WebGLRenderer.prototype.resetGLState = function() {
    return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),
    this.state.reset()
}
,
WebGLRenderer.prototype.supportsFloatTextures = function() {
    return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),
    this.extensions.get("OES_texture_float")
}
,
WebGLRenderer.prototype.supportsHalfFloatTextures = function() {
    return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),
    this.extensions.get("OES_texture_half_float")
}
,
WebGLRenderer.prototype.supportsStandardDerivatives = function() {
    return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),
    this.extensions.get("OES_standard_derivatives")
}
,
WebGLRenderer.prototype.supportsCompressedTextureS3TC = function() {
    return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),
    this.extensions.get("WEBGL_compressed_texture_s3tc")
}
,
WebGLRenderer.prototype.supportsCompressedTexturePVRTC = function() {
    return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),
    this.extensions.get("WEBGL_compressed_texture_pvrtc")
}
,
WebGLRenderer.prototype.supportsBlendMinMax = function() {
    return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),
    this.extensions.get("EXT_blend_minmax")
}
,
WebGLRenderer.prototype.supportsVertexTextures = function() {
    return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),
    this.capabilities.vertexTextures
}
,
WebGLRenderer.prototype.supportsInstancedArrays = function() {
    return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),
    this.extensions.get("ANGLE_instanced_arrays")
}
,
WebGLRenderer.prototype.enableScissorTest = function(e) {
    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),
    this.setScissorTest(e)
}
,
WebGLRenderer.prototype.initMaterial = function() {
    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
}
,
WebGLRenderer.prototype.addPrePlugin = function() {
    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
}
,
WebGLRenderer.prototype.addPostPlugin = function() {
    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
}
,
WebGLRenderer.prototype.updateShadowMap = function() {
    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
}
,
WebGLRenderer.prototype.setFaceCulling = function() {
    console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
}
,
WebGLRenderer.prototype.allocTextureUnit = function() {
    console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
}
,
WebGLRenderer.prototype.setTexture = function() {
    console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
}
,
WebGLRenderer.prototype.setTexture2D = function() {
    console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
}
,
WebGLRenderer.prototype.setTextureCube = function() {
    console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
}
,
WebGLRenderer.prototype.getActiveMipMapLevel = function() {
    return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),
    this.getActiveMipmapLevel()
}
,
Object.defineProperties(WebGLRenderer.prototype, {
    shadowMapEnabled: {
        get: function() {
            return this.shadowMap.enabled
        },
        set: function(e) {
            console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),
            this.shadowMap.enabled = e
        }
    },
    shadowMapType: {
        get: function() {
            return this.shadowMap.type
        },
        set: function(e) {
            console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),
            this.shadowMap.type = e
        }
    },
    shadowMapCullFace: {
        get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
        }
    },
    context: {
        get: function() {
            return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),
            this.getContext()
        }
    },
    vr: {
        get: function() {
            return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),
            this.xr
        }
    },
    gammaInput: {
        get: function() {
            return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),
            !1
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")
        }
    },
    gammaOutput: {
        get: function() {
            return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),
            !1
        },
        set: function(e) {
            console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),
            this.outputEncoding = !0 === e ? sRGBEncoding : LinearEncoding
        }
    },
    toneMappingWhitePoint: {
        get: function() {
            return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),
            1
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")
        }
    },
    gammaFactor: {
        get: function() {
            return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."),
            2
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")
        }
    }
}),
Object.defineProperties(WebGLShadowMap.prototype, {
    cullFace: {
        get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
        }
    },
    renderReverseSided: {
        get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
        }
    },
    renderSingleSided: {
        get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
        }
    }
}),
Object.defineProperties(WebGLRenderTarget.prototype, {
    wrapS: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
            this.texture.wrapS
        },
        set: function(e) {
            console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
            this.texture.wrapS = e
        }
    },
    wrapT: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
            this.texture.wrapT
        },
        set: function(e) {
            console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
            this.texture.wrapT = e
        }
    },
    magFilter: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
            this.texture.magFilter
        },
        set: function(e) {
            console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
            this.texture.magFilter = e
        }
    },
    minFilter: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
            this.texture.minFilter
        },
        set: function(e) {
            console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
            this.texture.minFilter = e
        }
    },
    anisotropy: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
            this.texture.anisotropy
        },
        set: function(e) {
            console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
            this.texture.anisotropy = e
        }
    },
    offset: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
            this.texture.offset
        },
        set: function(e) {
            console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
            this.texture.offset = e
        }
    },
    repeat: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
            this.texture.repeat
        },
        set: function(e) {
            console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
            this.texture.repeat = e
        }
    },
    format: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
            this.texture.format
        },
        set: function(e) {
            console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
            this.texture.format = e
        }
    },
    type: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
            this.texture.type
        },
        set: function(e) {
            console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
            this.texture.type = e
        }
    },
    generateMipmaps: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
            this.texture.generateMipmaps
        },
        set: function(e) {
            console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
            this.texture.generateMipmaps = e
        }
    }
}),
Audio$1.prototype.load = function(e) {
    console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
    var t = this;
    return (new AudioLoader).load(e, (function(e) {
        t.setBuffer(e)
    }
    )),
    this
}
,
CubeCamera.prototype.updateCubeMap = function(e, t) {
    return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),
    this.update(e, t)
}
,
CubeCamera.prototype.clear = function(e, t, r, i) {
    return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),
    this.renderTarget.clear(e, t, r, i)
}
,
ImageUtils.crossOrigin = void 0,
ImageUtils.loadTexture = function(e, t, r, i) {
    console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
    var n = new TextureLoader;
    n.setCrossOrigin(this.crossOrigin);
    var a = n.load(e, r, void 0, i);
    return t && (a.mapping = t),
    a
}
,
ImageUtils.loadTextureCube = function(e, t, r, i) {
    console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
    var n = new CubeTextureLoader;
    n.setCrossOrigin(this.crossOrigin);
    var a = n.load(e, r, void 0, i);
    return t && (a.mapping = t),
    a
}
,
ImageUtils.loadCompressedTexture = function() {
    console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
}
,
ImageUtils.loadCompressedTextureCube = function() {
    console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
}
,
"undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
    detail: {
        revision: REVISION
    }
})),
"undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = REVISION);
var isSSR = "undefined" == typeof window, DetectUA = function() {
    function e(e) {
        this.userAgent = e || (!isSSR && window.navigator ? window.navigator.userAgent : ""),
        this.isAndroidDevice = !/like android/i.test(this.userAgent) && /android/i.test(this.userAgent),
        this.iOSDevice = this.match(1, /(iphone|ipod|ipad)/i).toLowerCase(),
        !isSSR && "MacIntel" === navigator.platform && navigator.maxTouchPoints > 2 && !window.MSStream && (this.iOSDevice = "ipad")
    }
    return e.prototype.match = function(e, t) {
        var r = this.userAgent.match(t);
        return r && r.length > 1 && r[e] || ""
    }
    ,
    Object.defineProperty(e.prototype, "isMobile", {
        get: function() {
            return !this.isTablet && (/[^-]mobi/i.test(this.userAgent) || "iphone" === this.iOSDevice || "ipod" === this.iOSDevice || this.isAndroidDevice || /nexus\s*[0-6]\s*/i.test(this.userAgent))
        },
        enumerable: !1,
        configurable: !0
    }),
    Object.defineProperty(e.prototype, "isTablet", {
        get: function() {
            return /tablet/i.test(this.userAgent) && !/tablet pc/i.test(this.userAgent) || "ipad" === this.iOSDevice || this.isAndroidDevice && !/[^-]mobi/i.test(this.userAgent) || !/nexus\s*[0-6]\s*/i.test(this.userAgent) && /nexus\s*[0-9]+/i.test(this.userAgent)
        },
        enumerable: !1,
        configurable: !0
    }),
    Object.defineProperty(e.prototype, "isDesktop", {
        get: function() {
            return !this.isMobile && !this.isTablet
        },
        enumerable: !1,
        configurable: !0
    }),
    Object.defineProperty(e.prototype, "isMacOS", {
        get: function() {
            return /macintosh/i.test(this.userAgent) && {
                version: this.match(1, /mac os x (\d+(\.?_?\d+)+)/i).replace(/[_\s]/g, ".").split(".").map((function(e) {
                    return e
                }
                ))[1]
            }
        },
        enumerable: !1,
        configurable: !0
    }),
    Object.defineProperty(e.prototype, "isWindows", {
        get: function() {
            return /windows /i.test(this.userAgent) && {
                version: this.match(1, /Windows ((NT|XP)( \d\d?.\d)?)/i)
            }
        },
        enumerable: !1,
        configurable: !0
    }),
    Object.defineProperty(e.prototype, "isiOS", {
        get: function() {
            return !!this.iOSDevice && {
                version: this.match(1, /os (\d+([_\s]\d+)*) like mac os x/i).replace(/[_\s]/g, ".") || this.match(1, /version\/(\d+(\.\d+)?)/i)
            }
        },
        enumerable: !1,
        configurable: !0
    }),
    Object.defineProperty(e.prototype, "isAndroid", {
        get: function() {
            return this.isAndroidDevice && {
                version: this.match(1, /android[ \/-](\d+(\.\d+)*)/i)
            }
        },
        enumerable: !1,
        configurable: !0
    }),
    Object.defineProperty(e.prototype, "browser", {
        get: function() {
            var e = this.match(1, /version\/(\d+(\.\d+)?)/i);
            return /opera/i.test(this.userAgent) ? {
                name: "Opera",
                version: e || this.match(1, /(?:opera|opr|opios)[\s\/](\d+(\.\d+)?)/i)
            } : /opr\/|opios/i.test(this.userAgent) ? {
                name: "Opera",
                version: this.match(1, /(?:opr|opios)[\s\/](\d+(\.\d+)?)/i) || e
            } : /SamsungBrowser/i.test(this.userAgent) ? {
                name: "Samsung Internet for Android",
                version: e || this.match(1, /(?:SamsungBrowser)[\s\/](\d+(\.\d+)?)/i)
            } : /yabrowser/i.test(this.userAgent) ? {
                name: "Yandex Browser",
                version: e || this.match(1, /(?:yabrowser)[\s\/](\d+(\.\d+)?)/i)
            } : /ucbrowser/i.test(this.userAgent) ? {
                name: "UC Browser",
                version: this.match(1, /(?:ucbrowser)[\s\/](\d+(\.\d+)?)/i)
            } : /msie|trident/i.test(this.userAgent) ? {
                name: "Internet Explorer",
                version: this.match(1, /(?:msie |rv:)(\d+(\.\d+)?)/i)
            } : /(edge|edgios|edga|edg)/i.test(this.userAgent) ? {
                name: "Microsoft Edge",
                version: this.match(2, /(edge|edgios|edga|edg)\/(\d+(\.\d+)?)/i)
            } : /firefox|iceweasel|fxios/i.test(this.userAgent) ? {
                name: "Firefox",
                version: this.match(1, /(?:firefox|iceweasel|fxios)[ \/](\d+(\.\d+)?)/i)
            } : /chromium/i.test(this.userAgent) ? {
                name: "Chromium",
                version: this.match(1, /(?:chromium)[\s\/](\d+(?:\.\d+)?)/i) || e
            } : /chrome|crios|crmo/i.test(this.userAgent) ? {
                name: "Chrome",
                version: this.match(1, /(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
            } : /safari|applewebkit/i.test(this.userAgent) ? {
                name: "Safari",
                version: e
            } : {
                name: this.match(1, /^(.*)\/(.*) /),
                version: this.match(2, /^(.*)\/(.*) /)
            }
        },
        enumerable: !1,
        configurable: !0
    }),
    e
}(), detectUA = new DetectUA, userAgent = (navigator.userAgent || navigator.vendor).toLowerCase(), browserName = detectUA.browser.name, Browser = _createClass((function e() {
    _classCallCheck(this, e),
    _defineProperty(this, "isMobile", detectUA.isMobile || detectUA.isTablet),
    _defineProperty(this, "isDesktop", detectUA.isDesktop),
    _defineProperty(this, "device", this.isMobile ? "mobile" : "desktop"),
    _defineProperty(this, "isAndroid", Boolean(detectUA.isAndroid)),
    _defineProperty(this, "isIOS", Boolean(detectUA.isiOS)),
    _defineProperty(this, "isMacOS", Boolean(detectUA.isMacOS)),
    _defineProperty(this, "isWindows", Boolean(null !== detectUA.isWindows.version)),
    _defineProperty(this, "isLinux", Boolean(-1 != userAgent.indexOf("linux"))),
    _defineProperty(this, "ua", userAgent),
    _defineProperty(this, "isEdge", "Microsoft Edge" === browserName),
    _defineProperty(this, "isIE", "Internet Explorer" === browserName),
    _defineProperty(this, "isFirefox", "Firefox" === browserName),
    _defineProperty(this, "isChrome", "Chrome" === browserName),
    _defineProperty(this, "isOpera", "Opera" === browserName),
    _defineProperty(this, "isSafari", "Safari" === browserName),
    _defineProperty(this, "isRetina", window.devicePixelRatio && window.devicePixelRatio >= 1.5),
    _defineProperty(this, "devicePixelRatio", window.devicePixelRatio || 1),
    _defineProperty(this, "cpuCoreCount", navigator.hardwareConcurrency || 1),
    _defineProperty(this, "baseUrl", document.location.origin),
    _defineProperty(this, "isIFrame", window.self !== window.top)
}
)), browser = new Browser, Settings = function() {
    function e() {
        if (_classCallCheck(this, e),
        _defineProperty(this, "GLOBAL_ID", "LUSION_APP"),
        _defineProperty(this, "IS_API_MODE", !1),
        _defineProperty(this, "MODEL_PATH", "assets/models/"),
        _defineProperty(this, "IMAGE_PATH", "assets/images/"),
        _defineProperty(this, "TEXTURE_PATH", "assets/textures/"),
        _defineProperty(this, "AUDIO_PATH", "assets/audios/"),
        _defineProperty(this, "RENDER_TARGET_FLOAT_TYPE", null),
        _defineProperty(this, "DATA_FLOAT_TYPE", null),
        _defineProperty(this, "USE_FLOAT_PACKING", !1),
        _defineProperty(this, "USE_WEBGL2", !0),
        _defineProperty(this, "DPR", Math.min(1.5, browser.devicePixelRatio) || 1),
        _defineProperty(this, "USE_PIXEL_LIMIT", !0),
        _defineProperty(this, "MAX_PIXEL_COUNT", 3686400),
        _defineProperty(this, "UP_SCALE", browser.isMobile ? 1.5 : 1),
        _defineProperty(this, "CROSS_ORIGINS", {
            "https://example.com/": "anonymous"
        }),
        _defineProperty(this, "IS_DEV", !Boolean(!0)),
        _defineProperty(this, "LOG", !1),
        _defineProperty(this, "SKIP_ANIMATION", !1),
        _defineProperty(this, "LOOK_DEV_MODE", !1),
        window.URLSearchParams) {
            var t = _toConsumableArray(new URLSearchParams(window.location.search)).reduce((function(e, t) {
                var r = _slicedToArray(t, 2)
                  , i = r[0]
                  , n = r[1];
                return e[i] = "" === n || n,
                e
            }
            ), {});
            this.override(t)
        }
    }
    return _createClass(e, [{
        key: "override",
        value: function(e) {
            for (var t in e)
                if (void 0 !== this[t]) {
                    var r = e[t].toString();
                    "boolean" == typeof this[t] ? this[t] = !("0" === r || !1 === r) : "number" == typeof this[t] ? this[t] = parseFloat(r) : "string" == typeof this[t] && (this[t] = r)
                }
        }
    }]),
    e
}(), settings = new Settings, minSignal$1 = {
    exports: {}
}, module;
module = minSignal$1,
function(e) {
    function t() {
        this._listeners = [],
        this.dispatchCount = 0
    }
    var r = t.prototype;
    r.add = o,
    r.addOnce = function(t, r, a, s) {
        if (!t)
            throw i;
        var l = this
          , u = function() {
            return l.remove.call(l, t, r),
            t.apply(r, n.call(arguments, 0))
        };
        1 === (s = n.call(arguments, 0)).length && s.push(e),
        s.splice(2, 0, u),
        o.apply(l, s)
    }
    ,
    r.remove = function(e, t) {
        if (!e)
            return this._listeners.length = 0,
            !0;
        for (var r, i = this._listeners, n = i.length; n--; )
            if ((r = i[n]).f === e && (!t || r.c === t))
                return r.j = 0,
                i.splice(n, 1),
                !0;
        return !1
    }
    ,
    r.dispatch = function(e) {
        e = n.call(arguments, 0),
        this.dispatchCount++;
        for (var t, r, i = this.dispatchCount, a = this._listeners, o = a.length; o--; )
            if ((t = a[o]) && t.j < i && (t.j = i,
            !1 === t.r.apply(t.c, t.a.concat(e)))) {
                r = t;
                break
            }
        for (o = (a = this._listeners).length; o--; )
            a[o].j = 0;
        return r
    }
    ;
    var i = "Callback function is missing!"
      , n = Array.prototype.slice;
    function a(e) {
        e.sort((function(e, t) {
            return e = e.p,
            (t = t.p) < e ? 1 : t > e ? -1 : 0
        }
        ))
    }
    function o(e, t, r, o) {
        if (!e)
            throw i;
        r = r || 0;
        for (var s, l, u, c = this._listeners, h = c.length; h--; )
            if ((s = c[h]).f === e && s.c === t)
                return !1;
        "function" == typeof r && (l = r,
        r = o,
        u = 4),
        c.unshift({
            f: e,
            c: t,
            p: r,
            r: l || e,
            a: n.call(arguments, u || 3),
            j: 0
        }),
        a(c)
    }
    module.exports = t
}();
var MinSignal$2 = minSignal$1.exports
  , quickLoader$a = {
    exports: {}
}
  , minSignal = {
    exports: {}
};
!function(e) {
    !function(t) {
        function r() {
            this._listeners = [],
            this.dispatchCount = 0
        }
        var i = r.prototype;
        i.add = s,
        i.addOnce = function(e, r, i, o) {
            if (!e)
                throw n;
            var l = this
              , u = function() {
                return l.remove.call(l, e, r),
                e.apply(r, a.call(arguments, 0))
            };
            1 === (o = a.call(arguments, 0)).length && o.push(t),
            o.splice(2, 0, u),
            s.apply(l, o)
        }
        ,
        i.remove = function(e, t) {
            if (!e)
                return this._listeners.length = 0,
                !0;
            for (var r, i = this._listeners, n = i.length; n--; )
                if ((r = i[n]).f === e && (!t || r.c === t))
                    return r.j = 0,
                    i.splice(n, 1),
                    !0;
            return !1
        }
        ,
        i.dispatch = function(e) {
            e = a.call(arguments, 0),
            this.dispatchCount++;
            for (var t, r, i = this.dispatchCount, n = this._listeners, o = n.length; o--; )
                if ((t = n[o]) && t.j < i && (t.j = i,
                !1 === t.r.apply(t.c, t.a.concat(e)))) {
                    r = t;
                    break
                }
            for (o = (n = this._listeners).length; o--; )
                n[o].j = 0;
            return r
        }
        ;
        var n = "Callback function is missing!"
          , a = Array.prototype.slice;
        function o(e) {
            e.sort((function(e, t) {
                return e = e.p,
                (t = t.p) < e ? 1 : e > t ? -1 : 0
            }
            ))
        }
        function s(e, t, r, i) {
            if (!e)
                throw n;
            r = r || 0;
            for (var s, l, u, c = this._listeners, h = c.length; h--; )
                if ((s = c[h]).f === e && s.c === t)
                    return !1;
            "function" == typeof r && (l = r,
            r = i,
            u = 4),
            c.unshift({
                f: e,
                c: t,
                p: r,
                r: l || e,
                a: a.call(arguments, u || 3),
                j: 0
            }),
            o(c)
        }
        e.exports = r
    }()
}(minSignal);
var MinSignal$1 = minSignal.exports, undef$3;
function QuickLoader() {
    this.isLoading = !1,
    this.totalWeight = 0,
    this.loadedWeight = 0,
    this.itemUrls = {},
    this.itemList = [],
    this.loadingSignal = new MinSignal$1,
    this.crossOriginMap = {},
    this.queue = [],
    this.activeItems = [],
    this.maxActiveItems = 4
}
var _p$9 = QuickLoader.prototype;
_p$9.addChunk = addChunk,
_p$9.setCrossOrigin = setCrossOrigin,
_p$9.add = add,
_p$9.load = load$7,
_p$9.start = start,
_p$9.loadNext = loadNext,
_p$9._createItem = _createItem,
_p$9._onLoading = _onLoading$1,
_p$9.VERSION = "0.1.17",
_p$9.register = register,
_p$9.retrieveAll = retrieveAll,
_p$9.retrieve = retrieve,
_p$9.testExtensions = testExtensions,
_p$9.create = create,
_p$9.check = check;
var addedItems = _p$9.addedItems = {}
  , loadedItems = _p$9.loadedItems = {}
  , ITEM_CLASS_LIST = _p$9.ITEM_CLASS_LIST = []
  , ITEM_CLASSES = _p$9.ITEM_CLASSES = {};
function setCrossOrigin(e, t) {
    this.crossOriginMap[e] = t
}
function addChunk(e, t) {
    var r, i, n, a, o, s = retrieveAll(e, t);
    for (r = 0,
    n = s.length; r < n; r++)
        for (i = 0,
        a = (o = s[r]).items.length; i < a; i++)
            this.add(o.items[i], {
                type: o.type
            });
    return s
}
function add(e, t) {
    var r = addedItems[e];
    return r || (r = this._createItem(e, t && t.type ? t.type : retrieve(e).type, t)),
    t && t.onLoad && r.onLoaded.addOnce(t.onLoad),
    this.itemUrls[e] || (this.itemUrls[e] = r,
    this.itemList.push(r),
    this.totalWeight += r.weight),
    r
}
function load$7(e, t) {
    var r = addedItems[e];
    return r || (r = this._createItem(e, t && t.type ? t.type : retrieve(e).type, t)),
    t && t.onLoad && r.onLoaded.addOnce(t.onLoad),
    loadedItems[e] ? r.dispatch() : r.isStartLoaded || r.load(),
    r
}
function start(e) {
    e && this.loadingSignal.add(e),
    this.isLoading = !0;
    var t = this.itemList.length;
    if (t) {
        var r, i = this.itemList.splice(0, this.itemList.length);
        for (var n in this.itemUrls)
            delete this.itemUrls[n];
        for (var a = 0; a < t; a++) {
            r = i[a];
            var o = !!loadedItems[r.url];
            r.onLoaded.addOnce(_onItemLoad, this, -1024, r, i, o),
            r.hasLoading && r.loadingSignal.add(_onLoading$1, this, -1024, r, i, undef$3),
            o ? r.dispatch(_onItemLoad) : r.isStartLoaded || this.queue.push(r)
        }
        this.queue.length && this.loadNext()
    } else
        _onItemLoad.call(this, undef$3, this.itemList)
}
function loadNext() {
    if (this.queue.length && this.activeItems.length < this.maxActiveItems) {
        var e = this.queue.shift();
        this.activeItems.push(e),
        this.loadNext(),
        e.load()
    }
}
function _onLoading$1(e, t, r, i, n) {
    e && !e.isLoaded && 1 === e.getCombinedPercent(i) || (n === undef$3 && (this.loadedWeight = _getLoadedWeight(t),
    n = this.loadedWeight / this.totalWeight),
    (r = r || this.loadingSignal).dispatch(n, e))
}
function _getLoadedWeight(e) {
    for (var t = 0, r = 0, i = e.length; r < i; r++)
        t += e[r].loadedWeight;
    return t
}
function _onItemLoad(e, t, r) {
    if (this.loadedWeight = _getLoadedWeight(t),
    !r)
        for (var i = this.activeItems, n = i.length; n--; )
            if (i[n] === e) {
                i.splice(n, 1);
                break
            }
    var a = this.loadingSignal;
    this.loadedWeight === this.totalWeight ? (this.isLoading = !1,
    this.loadedWeight = 0,
    this.totalWeight = 0,
    this.loadingSignal = new MinSignal$1,
    this._onLoading(e, t, a, 1, 1),
    e && e.noCache && _removeItemCache(e)) : (this._onLoading(e, t, a, 1, this.loadedWeight / this.totalWeight),
    e && e.noCache && _removeItemCache(e),
    r || this.loadNext())
}
function _removeItemCache(e) {
    var t = e.url;
    e.content = undef$3,
    addedItems[t] = undef$3,
    loadedItems[t] = undef$3
}
function _createItem(e, t, r) {
    if (!(r = r || {}).crossOrigin)
        for (var i in this.crossOriginMap)
            if (0 === e.indexOf(i)) {
                r.crossOrigin = this.crossOriginMap[i];
                break
            }
    return new ITEM_CLASSES[t](e,r)
}
function register(e) {
    ITEM_CLASSES[e.type] || (ITEM_CLASS_LIST.push(e),
    ITEM_CLASSES[e.type] = e)
}
function retrieveAll(e, t) {
    var r, i, n = e.length, a = [];
    if (n && "string" != typeof e)
        for (r = 0; r < n; r++)
            (i = retrieve(e[r], t)) && (a = a.concat(i));
    else
        (i = retrieve(e, t)) && (a = a.concat(i));
    return a
}
function retrieve(e, t) {
    var r, i, n, a, o;
    if (t)
        n = (a = ITEM_CLASSES[t]).retrieve(e);
    else
        for (r = 0,
        i = ITEM_CLASS_LIST.length; r < i; r++) {
            if (o = (a = ITEM_CLASS_LIST[r]).type,
            "string" == typeof e) {
                if (testExtensions(e, a)) {
                    n = [e];
                    break
                }
            } else if ((n = a.retrieve(e)) && n.length && "string" == typeof n[0] && testExtensions(n[0], a))
                break;
            n = undef$3,
            o = undef$3
        }
    if (n)
        return {
            type: t || o,
            items: n
        }
}
function testExtensions(e, t) {
    if (e) {
        for (var r = _getExtension(e), i = t.extensions, n = i.length; n--; )
            if (r === i[n])
                return !0;
        return !1
    }
}
function _getExtension(e) {
    return e.split(".").pop().split(/#|\?/)[0]
}
function create() {
    return new QuickLoader
}
function check() {
    var e = []
      , t = [];
    for (var r in addedItems)
        e.push(r),
        loadedItems[r] || t.push(addedItems[r]);
    console.log({
        added: e,
        notLoaded: t
    })
}
quickLoader$a.exports = create();
var MinSignal = minSignal.exports
  , quickLoader$9 = quickLoader$a.exports;
function AbstractItem$6(e, t) {
    if (e) {
        for (var r in this.url = e,
        this.loadedWeight = 0,
        this.weight = 1,
        this.postPercent = 0,
        t)
            this[r] = t[r];
        this.type || (this.type = this.constructor.type),
        this.hasLoading && (this.loadingSignal = new MinSignal,
        this.loadingSignal.add(_onLoading, this),
        this.onLoading && this.loadingSignal.add(this.onLoading)),
        this.onPost ? (this.onPostLoadingSignal = new MinSignal,
        this.onPostLoadingSignal.add(this._onPostLoading, this),
        this.postWeightRatio = this.postWeightRatio || .1) : this.postWeightRatio = 0;
        var i = this;
        this.boundOnLoad = function() {
            i._onLoad()
        }
        ,
        this.onLoaded = new MinSignal,
        quickLoader$9.addedItems[e] = this
    }
}
var AbstractItem_1 = AbstractItem$6
  , _p$8 = AbstractItem$6.prototype;
function load$6() {
    this.isStartLoaded = !0
}
function _onLoad$6() {
    this.onPost ? this.onPost.call(this, this.content, this.onPostLoadingSignal) : this._onLoadComplete()
}
function _onPostLoading(e) {
    this.postPercent = e,
    this.hasLoading && this.loadingSignal.dispatch(1),
    1 === e && this._onLoadComplete()
}
function _onLoadComplete() {
    this.isLoaded = !0,
    this.loadedWeight = this.weight,
    quickLoader$9.loadedItems[this.url] = this,
    this.onLoaded.dispatch(this.content)
}
function getCombinedPercent(e) {
    return e * (1 - this.postWeightRatio) + this.postWeightRatio * this.postPercent
}
function _onLoading(e) {
    this.loadedWeight = this.weight * this.getCombinedPercent(e)
}
function dispatch() {
    this.hasLoading && this.loadingSignal.remove(),
    this.onLoaded.dispatch(this.content)
}
_p$8.load = load$6,
_p$8._onLoad = _onLoad$6,
_p$8._onLoading = _onLoading,
_p$8._onPostLoading = _onPostLoading,
_p$8._onLoadComplete = _onLoadComplete,
_p$8.getCombinedPercent = getCombinedPercent,
_p$8.dispatch = dispatch,
AbstractItem$6.extensions = [],
AbstractItem$6.retrieve = function() {
    return !1
}
;
var AbstractItem$5 = AbstractItem_1
  , quickLoader$8 = quickLoader$a.exports;
function __generateFuncName() {
    return "_jsonp" + (new Date).getTime() + ~~(1e8 * Math.random())
}
function JSONPItem(e) {
    e && _super$7.constructor.apply(this, arguments)
}
JSONPItem.type = "jsonp",
JSONPItem.extensions = [],
quickLoader$8.register(JSONPItem),
JSONPItem.retrieve = function(e) {
    return "string" == typeof e && e.indexOf("=") > -1 && [e]
}
;
var _super$7 = AbstractItem$5.prototype
  , _p$7 = JSONPItem.prototype = new AbstractItem$5;
function load$5(e) {
    _super$7.load.apply(this, arguments);
    var t = this
      , r = this.url.lastIndexOf("=") + 1
      , i = this.url.substr(0, r)
      , n = this.url.substr(r);
    0 === n.length ? (n = __generateFuncName(),
    this.jsonpCallback = e) : this.jsonpCallback = this.jsonpCallback || window[n],
    window[n] = function(e) {
        a.parentNode && a.parentNode.removeChild(a),
        t.content = e,
        t._onLoad()
    }
    ;
    var a = document.createElement("script");
    a.type = "text/javascript",
    a.src = i + n,
    document.getElementsByTagName("head")[0].appendChild(a)
}
_p$7.constructor = JSONPItem,
_p$7.load = load$5;
var AbstractItem$4 = AbstractItem_1, quickLoader$7 = quickLoader$a.exports, undef$2, IS_SUPPORT_XML_HTTP_REQUEST = !!window.XMLHttpRequest;
function XHRItem$2(e) {
    e && (_super$6.constructor.apply(this, arguments),
    this.responseType = this.responseType || "",
    this.method = this.method || "GET")
}
var XHRItem_1 = XHRItem$2;
XHRItem$2.type = "xhr",
XHRItem$2.extensions = [],
quickLoader$7.register(XHRItem$2),
XHRItem$2.retrieve = function() {
    return !1
}
;
var _super$6 = AbstractItem$4.prototype
  , _p$6 = XHRItem$2.prototype = new AbstractItem$4;
function load$4() {
    _super$6.load.apply(this, arguments);
    var e, t = this;
    e = this.xmlhttp = IS_SUPPORT_XML_HTTP_REQUEST ? new XMLHttpRequest : new ActiveXObject("Microsoft.XMLHTTP"),
    this.hasLoading && (e.onprogress = function(e) {
        t._onXmlHttpProgress(e)
    }
    ),
    e.onreadystatechange = function() {
        t._onXmlHttpChange()
    }
    ,
    e.open(this.method, this.url, !0),
    this.xmlhttp.responseType = this.responseType,
    IS_SUPPORT_XML_HTTP_REQUEST ? e.send(null) : e.send()
}
function _onXmlHttpProgress(e) {
    this.loadingSignal.dispatch(e.loaded / e.total)
}
function _onXmlHttpChange() {
    4 === this.xmlhttp.readyState && 200 === this.xmlhttp.status && this._onLoad(this.xmlhttp)
}
function _onLoad$5() {
    this.content || (this.content = this.xmlhttp.response),
    this.xmlhttp = undef$2,
    _super$6._onLoad.call(this)
}
_p$6.constructor = XHRItem$2,
_p$6.load = load$4,
_p$6._onXmlHttpChange = _onXmlHttpChange,
_p$6._onXmlHttpProgress = _onXmlHttpProgress,
_p$6._onLoad = _onLoad$5;
var XHRItem$1 = XHRItem_1
  , quickLoader$6 = quickLoader$a.exports;
function TextItem$1(e, t) {
    e && (t.responseType = "text",
    _super$5.constructor.apply(this, arguments))
}
var TextItem_1 = TextItem$1;
TextItem$1.type = "text",
TextItem$1.extensions = ["html", "txt", "svg"],
quickLoader$6.register(TextItem$1),
TextItem$1.retrieve = function() {
    return !1
}
;
var _super$5 = XHRItem$1.prototype
  , _p$5 = TextItem$1.prototype = new XHRItem$1;
function _onLoad$4() {
    this.content || (this.content = this.xmlhttp.responseText),
    _super$5._onLoad.apply(this, arguments)
}
_p$5.constructor = TextItem$1,
_p$5._onLoad = _onLoad$4;
var TextItem = TextItem_1
  , quickLoader$5 = quickLoader$a.exports;
function JSONItem(e) {
    e && _super$4.constructor.apply(this, arguments)
}
JSONItem.type = "json",
JSONItem.extensions = ["json"],
quickLoader$5.register(JSONItem),
JSONItem.retrieve = function() {
    return !1
}
;
var _super$4 = TextItem.prototype
  , _p$4 = JSONItem.prototype = new TextItem;
function _onLoad$3() {
    this.content || (this.content = window.JSON && window.JSON.parse ? JSON.parse(this.xmlhttp.responseText.toString()) : eval(this.xmlhttp.responseText.toString())),
    _super$4._onLoad.call(this)
}
_p$4.constructor = JSONItem,
_p$4._onLoad = _onLoad$3;
var AbstractItem$3 = AbstractItem_1, quickLoader$4 = quickLoader$a.exports, undef$1;
function AudioItem$1(e, t) {
    if (e) {
        this.loadThrough = !t || t.loadThrough === undef$1 || t.loadThrough,
        _super$3.constructor.apply(this, arguments);
        try {
            this.content = this.content || new Audio
        } catch (r) {
            this.content = this.content || document.createElement("audio")
        }
        this.crossOrigin && (this.content.crossOrigin = this.crossOrigin)
    }
}
AudioItem$1.type = "audio",
AudioItem$1.extensions = ["mp3", "ogg"],
quickLoader$4.register(AudioItem$1),
AudioItem$1.retrieve = function(e) {
    return !1
}
;
var _super$3 = AbstractItem$3.prototype
  , _p$3 = AudioItem$1.prototype = new AbstractItem$3;
function load$3() {
    _super$3.load.apply(this, arguments);
    var e = this
      , t = e.content;
    t.src = this.url,
    this.loadThrough ? t.addEventListener("canplaythrough", this.boundOnLoad, !1) : t.addEventListener("canplay", this.boundOnLoad, !1),
    t.load()
}
function _onLoad$2() {
    this.content.removeEventListener("canplaythrough", this.boundOnLoad, !1),
    this.content.removeEventListener("canplay", this.boundOnLoad, !1),
    this.isLoaded || _super$3._onLoad.call(this)
}
_p$3.constructor = AudioItem$1,
_p$3.load = load$3,
_p$3._onLoad = _onLoad$2;
var AbstractItem$2 = AbstractItem_1, quickLoader$3 = quickLoader$a.exports, undef;
function VideoItem(e, t) {
    if (e) {
        this.loadThrough = !t || t.loadThrough === undef || t.loadThrough,
        _super$2.constructor.apply(this, arguments);
        try {
            this.content = this.content || new Video
        } catch (r) {
            this.content = this.content || document.createElement("video")
        }
        this.crossOrigin && (this.content.crossOrigin = this.crossOrigin)
    }
}
VideoItem.type = "video",
VideoItem.extensions = ["mp4", "webm", "ogv"],
quickLoader$3.register(VideoItem),
VideoItem.retrieve = function(e) {
    return !1
}
;
var _super$2 = AbstractItem$2.prototype
  , _p$2 = VideoItem.prototype = new AbstractItem$2;
function load$2() {
    _super$2.load.apply(this, arguments);
    var e = this.content;
    e.preload = "auto",
    e.src = this.url,
    this.loadThrough ? e.addEventListener("canplaythrough", this.boundOnLoad, !1) : e.addEventListener("canplay", this.boundOnLoad, !1),
    e.load()
}
function _onLoad$1() {
    this.content.removeEventListener("canplaythrough", this.boundOnLoad),
    this.content.removeEventListener("canplay", this.boundOnLoad),
    this.isLoaded || _super$2._onLoad.call(this)
}
_p$2.constructor = VideoItem,
_p$2.load = load$2,
_p$2._onLoad = _onLoad$1;
var AbstractItem$1 = AbstractItem_1
  , quickLoader$2 = quickLoader$a.exports;
function AnyItem$1(e, t) {
    e && (_super$1.constructor.call(this, e, t),
    !this.loadFunc && console && console[console.error || console.log]("require loadFunc in the config object."))
}
AnyItem$1.type = "any",
AnyItem$1.extensions = [],
quickLoader$2.register(AnyItem$1),
AnyItem$1.retrieve = function() {
    return !1
}
;
var _super$1 = AbstractItem$1.prototype
  , _p$1 = AnyItem$1.prototype = new AbstractItem$1;
function load$1() {
    var e = this;
    this.loadFunc(this.url, (function(t) {
        e.content = t,
        _super$1._onLoad.call(e)
    }
    ), this.loadingSignal)
}
function computedStyle$1(e, t, r, i) {
    if (i = (r = window.getComputedStyle) ? r(e) : e.currentStyle)
        return i[t.replace(/-(\w)/gi, (function(e, t) {
            return t.toUpperCase()
        }
        ))]
}
_p$1.constructor = AnyItem$1,
_p$1.load = load$1;
var computedStyle_commonjs = computedStyle$1
  , AbstractItem = AbstractItem_1
  , computedStyle = computedStyle_commonjs
  , quickLoader$1 = quickLoader$a.exports;
function ImageItem$1(e, t) {
    e && (_super.constructor.apply(this, arguments),
    this.content = this.content || new Image,
    this.crossOrigin && (this.content.crossOrigin = this.crossOrigin))
}
var _super = AbstractItem.prototype
  , _p = ImageItem$1.prototype = new AbstractItem;
function load() {
    _super.load.apply(this, arguments);
    var e = this.content;
    e.onload = this.boundOnLoad,
    e.src = this.url
}
function _onLoad() {
    delete this.content.onload,
    this.width = this.content.width,
    this.height = this.content.height,
    _super._onLoad.call(this)
}
function _isNotData(e) {
    return 0 !== e.indexOf("data:")
}
_p.constructor = ImageItem$1,
_p.load = load,
_p._onLoad = _onLoad,
ImageItem$1.retrieve = function(e) {
    if (e.nodeType && e.style) {
        var t = [];
        "img" === e.nodeName.toLowerCase() && e.src.indexOf(";") < 0 && t.push(e.src),
        computedStyle(e, "background-image").replace(/s?url\(\s*?['"]?([^;]*?)['"]?\s*?\)/g, (function(e, r) {
            t.push(r)
        }
        ));
        for (var r = t.length; r--; )
            _isNotData(t[r]) || t.splice(r, 1);
        return !!t.length && t
    }
    return "string" == typeof e && [e]
}
,
ImageItem$1.type = "image",
ImageItem$1.extensions = ["jpg", "gif", "png"],
quickLoader$1.register(ImageItem$1);
var quickLoader = quickLoader$a.exports, Properties = _createClass((function e() {
    _classCallCheck(this, e),
    _defineProperty(this, "isSecureConnection", "https:" === window.location.protocol),
    _defineProperty(this, "loader", quickLoader.create()),
    _defineProperty(this, "percent", 0),
    _defineProperty(this, "easedPercent", 0),
    _defineProperty(this, "hasStarted", !1),
    _defineProperty(this, "_isSupportedDevice", !1),
    _defineProperty(this, "_isSupportedBrowser", !1),
    _defineProperty(this, "_isSupportedWebGL", !1),
    _defineProperty(this, "_isSupportedMobileOrientation", !1),
    _defineProperty(this, "_isSupported", !1),
    _defineProperty(this, "time", 0),
    _defineProperty(this, "deltaTime", 0),
    _defineProperty(this, "isStageReady", !1),
    _defineProperty(this, "hasInitialized", !1),
    _defineProperty(this, "rawWidth", 0),
    _defineProperty(this, "rawHeight", 0),
    _defineProperty(this, "width", 0),
    _defineProperty(this, "height", 0),
    _defineProperty(this, "renderer", null),
    _defineProperty(this, "scene", null),
    _defineProperty(this, "camera", null),
    _defineProperty(this, "postprocessing", null),
    _defineProperty(this, "resolution", null),
    _defineProperty(this, "canvas", null),
    _defineProperty(this, "gl", null),
    _defineProperty(this, "webglOpts", {
        antialias: !1,
        alpha: !1,
        xrCompatible: !0
    }),
    _defineProperty(this, "sharedUniforms", {
        u_time: {
            value: 1e6
        },
        u_deltaTime: {
            value: 1
        },
        u_resolution: {
            value: null
        },
        u_bgColor: {
            value: null
        }
    }),
    _defineProperty(this, "changeCamera", new MinSignal$2),
    _defineProperty(this, "cameraLookX", 0),
    _defineProperty(this, "cameraLookY", 0),
    _defineProperty(this, "cameraDistance", 5),
    _defineProperty(this, "cameraLookStrength", .2),
    _defineProperty(this, "cameraLookEaseDamp", .1),
    _defineProperty(this, "cameraShakePositionStrength", .5),
    _defineProperty(this, "cameraShakePositionSpeed", .15),
    _defineProperty(this, "cameraShakeRotationStrength", .003),
    _defineProperty(this, "cameraShakeRotationSpeed", .3),
    _defineProperty(this, "cameraDollyZoomFovOffset", 0),
    _defineProperty(this, "smaa", null),
    _defineProperty(this, "fxaa", null),
    _defineProperty(this, "cameraMotionBlur", null),
    _defineProperty(this, "gtao", null),
    _defineProperty(this, "bokeh", null),
    _defineProperty(this, "bloom", null),
    _defineProperty(this, "screenPaintDistortion", null),
    _defineProperty(this, "final", null),
    _defineProperty(this, "bgColorHex", "#000000"),
    _defineProperty(this, "bgColor", new Color),
    _defineProperty(this, "opacity", 1),
    _defineProperty(this, "bloomAmount", 2),
    _defineProperty(this, "bloomRadius", 0),
    _defineProperty(this, "bloomThreshold", .3),
    _defineProperty(this, "bloomSmoothWidth", .75),
    _defineProperty(this, "haloWidth", .5),
    _defineProperty(this, "haloRGBShift", .01),
    _defineProperty(this, "haloStrength", .35),
    _defineProperty(this, "haloMaskInner", 0),
    _defineProperty(this, "haloMaskOuter", 1),
    _defineProperty(this, "vignetteFrom", .6),
    _defineProperty(this, "vignetteTo", 1.6),
    _defineProperty(this, "vignetteColorHex", "#000000"),
    _defineProperty(this, "saturation", 1),
    _defineProperty(this, "contrast", 0),
    _defineProperty(this, "brightness", 1),
    _defineProperty(this, "tintColorHex", "#0038ff"),
    _defineProperty(this, "tintOpacity", .045),
    _defineProperty(this, "cameraMotionBlurAmount", 0),
    _defineProperty(this, "bokehAmount", 0),
    _defineProperty(this, "bokehFNumber", .181),
    _defineProperty(this, "bokehFocusDistance", 4.5),
    _defineProperty(this, "bokehFocalLength", .344),
    _defineProperty(this, "bokehKFilmHeight", 19.26),
    _defineProperty(this, "useScreenPaint", !1),
    _defineProperty(this, "screenPaintNeedsMouseDown", !1),
    _defineProperty(this, "screenPaintMinRadius", 0),
    _defineProperty(this, "screenPaintMaxRadius", 100),
    _defineProperty(this, "screenPaintRadiusDistanceRange", 100),
    _defineProperty(this, "screenPaintPushStrength", 25),
    _defineProperty(this, "screenPaintVelocityDissipation", .985),
    _defineProperty(this, "screenPaintWeight1Dissipation", .985),
    _defineProperty(this, "screenPaintWeight2Dissipation", .75),
    _defineProperty(this, "screenPaintUseNoise", !1),
    _defineProperty(this, "screenPaintCurlScale", .1),
    _defineProperty(this, "screenPaintCurlStrength", 2),
    _defineProperty(this, "screenPaintDistortionAmount", 0),
    _defineProperty(this, "screenPaintDistortionRGBShift", 1),
    _defineProperty(this, "screenPaintDistortionMultiplier", 1.25),
    _defineProperty(this, "startRatio", 0),
    _defineProperty(this, "upscalerSharpness", 1),
    _defineProperty(this, "isPreloaderFinished", !1),
    _defineProperty(this, "isPreloaderWaitFinished", !1),
    _defineProperty(this, "onFirstClicked", new MinSignal$2),
    _defineProperty(this, "onPageChanged", new MinSignal$2),
    _defineProperty(this, "onToggleAudio", new MinSignal$2),
    _defineProperty(this, "isAudioActive", !1),
    _defineProperty(this, "audioActiveRatio", 0)
}
)), properties = new Properties, blitVert = "#define GLSLIFY 1\nattribute vec2 position;varying vec2 v_uv;void main(){v_uv=position*0.5+0.5;gl_Position=vec4(position,0.0,1.0);}", blitFrag = "#define GLSLIFY 1\nuniform sampler2D u_texture;varying vec2 v_uv;void main(){gl_FragColor=texture2D(u_texture,v_uv);}", uvBlitVert = "#define GLSLIFY 1\nattribute vec2 position;attribute vec2 uv;varying vec2 v_uv;void main(){v_uv=uv;gl_Position=vec4(position,0.0,1.0);}", clearFrag = "#define GLSLIFY 1\nuniform vec4 u_color;varying vec2 v_uv;void main(){gl_FragColor=u_color;}", debugVert = "#define GLSLIFY 1\nattribute vec3 position;attribute vec2 uv;uniform vec4 u_transform;varying vec2 v_uv;void main(){v_uv=uv;gl_Position=vec4(position.xy*u_transform.zw+u_transform.xy,0.0,1.0);}", FboHelper = function() {
    function e() {
        _classCallCheck(this, e),
        _defineProperty(this, "isWebGL2", void 0),
        _defineProperty(this, "renderer", void 0),
        _defineProperty(this, "quadGeom", void 0),
        _defineProperty(this, "triGeom", void 0),
        _defineProperty(this, "floatType", void 0),
        _defineProperty(this, "precisionPrefix", void 0),
        _defineProperty(this, "precisionPrefix2", void 0),
        _defineProperty(this, "vertexShader", void 0),
        _defineProperty(this, "_scene", void 0),
        _defineProperty(this, "_camera", void 0),
        _defineProperty(this, "_tri", void 0),
        _defineProperty(this, "copyMaterial", void 0),
        _defineProperty(this, "uvCopyMaterial", void 0),
        _defineProperty(this, "clearMaterial", void 0),
        _defineProperty(this, "_debugScene", void 0),
        _defineProperty(this, "_debugMesh", void 0),
        _defineProperty(this, "_debugMaterial", void 0)
    }
    return _createClass(e, [{
        key: "init",
        value: function(e, t) {
            this.renderer = e,
            this.floatType = t,
            this.isWebGL2 = this.renderer.capabilities.isWebGL2,
            this._scene = new Scene,
            this._camera = new Camera,
            this._camera.position.z = 1,
            this.triGeom = new BufferGeometry,
            this.triGeom.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, 0, 4, -1, 0, -1, 4, 0]),3)),
            this.quadGeom = new PlaneGeometry(2,2),
            this._tri = new Mesh(this.triGeom),
            this._tri.frustumCulled = !1,
            this._scene.add(this._tri),
            this.precisionPrefix = "precision ".concat(this.renderer.capabilities.precision, " float;\n"),
            this.precisionPrefix2 = "#version 300 es\n\t\t\tprecision ".concat(this.renderer.capabilities.precision, " float;\n\t\t\tprecision ").concat(this.renderer.capabilities.precision, " int;\n\t\t\t#define IS_WEBGL2 true\n\t\t"),
            this.isWebGL2 ? (this.vertexPrefix = "".concat(this.precisionPrefix2, "\n\t\t\t\tprecision mediump sampler2DArray;\n\t\t\t\t#define attribute in\n\t\t\t\t#define varying out\n\t\t\t\t#define texture2D texture\n\t\t\t"),
            this.fragmentPrefix = "".concat(this.precisionPrefix2, "\n\t\t\t\t#define varying in\n\t\t\t\tout highp vec4 pc_fragColor;\n\t\t\t\t#define gl_FragColor pc_fragColor\n\t\t\t\t#define gl_FragDepthEXT gl_FragDepth\n\t\t\t\t#define texture2D texture\n\t\t\t\t#define textureCube texture\n\t\t\t\t#define texture2DProj textureProj\n\t\t\t\t#define texture2DLodEXT textureLod\n\t\t\t\t#define texture2DProjLodEXT textureProjLod\n\t\t\t\t#define textureCubeLodEXT textureLod\n\t\t\t\t#define texture2DGradEXT textureGrad\n\t\t\t\t#define texture2DProjGradEXT textureProjGrad\n\t\t\t\t#define textureCubeGradEXT textureGrad\n\t\t\t")) : (this.vertexPrefix = this.precisionPrefix,
            this.fragmentPrefix = this.precisionPrefix),
            this.renderer.getContext().getExtension("OES_standard_derivatives"),
            this.vertexShader = this.precisionPrefix + blitVert,
            this.copyMaterial = new RawShaderMaterial({
                uniforms: {
                    u_texture: {
                        value: null
                    }
                },
                vertexShader: this.vertexShader,
                fragmentShader: this.precisionPrefix + blitFrag,
                depthTest: !1,
                depthWrite: !1,
                blending: NoBlending
            }),
            this.uvCopyMaterial = new RawShaderMaterial({
                uniforms: {
                    u_texture: {
                        value: null
                    }
                },
                vertexShader: this.precisionPrefix + uvBlitVert,
                fragmentShader: this.precisionPrefix + blitFrag,
                depthTest: !1,
                depthWrite: !1,
                blending: NoBlending
            }),
            this.clearMaterial = new RawShaderMaterial({
                uniforms: {
                    u_color: {
                        value: new Vector4(1,1,1,1)
                    }
                },
                vertexShader: this.vertexShader,
                fragmentShader: this.precisionPrefix + clearFrag,
                depthTest: !1,
                depthWrite: !1,
                blending: NoBlending
            });
            var r = new PlaneGeometry(1,1);
            r.translate(.5, -.5, 0),
            this._debugMaterial = new RawShaderMaterial({
                uniforms: {
                    u_texture: {
                        value: null
                    },
                    u_transform: {
                        value: new Vector4(0,0,1,1)
                    }
                },
                vertexShader: this.precisionPrefix + debugVert,
                fragmentShader: this.precisionPrefix + blitFrag,
                depthTest: !1,
                depthWrite: !1,
                blending: NoBlending
            }),
            this._debugMesh = new Mesh(r,this._debugMaterial),
            this._debugScene = new Scene,
            this._debugScene.frustumCulled = !1,
            this._debugScene.add(this._debugMesh)
        }
    }, {
        key: "copy",
        value: function(e, t) {
            var r = this.copyMaterial;
            r && (r.uniforms.u_texture.value = e,
            this.render(r, t))
        }
    }, {
        key: "uvCopy",
        value: function(e, t) {
            var r = this.uvCopyMaterial;
            r && (r.uniforms.u_texture.value = e,
            this.render(r, t))
        }
    }, {
        key: "render",
        value: function(e, t) {
            this._tri && this.renderer && this._scene && this._camera && (this._tri.material = e,
            t && this.renderer.setRenderTarget(t),
            this.renderer.render(this._scene, this._camera),
            t && this.renderer.setRenderTarget(null))
        }
    }, {
        key: "renderGeometry",
        value: function(e, t, r) {
            this._tri && this.triGeom && (this._tri.geometry = e,
            this.render(t, r),
            this._tri.geometry = this.triGeom)
        }
    }, {
        key: "renderMesh",
        value: function(e, t) {
            this._tri && this.renderer && this._scene && this._camera && (this._tri.visible = !1,
            this._scene.add(e),
            t && this.renderer.setRenderTarget(t || null),
            this.renderer.render(this._scene, this._camera),
            t && this.renderer.setRenderTarget(null),
            this._scene.remove(e),
            this._tri.visible = !0)
        }
    }, {
        key: "debugTo",
        value: function(e, t, r, i, n) {
            if (this.renderer && this._debugMaterial && this._debugScene && this._camera) {
                t = t || e.width || e.image.width,
                r = r || e.height || e.image.height,
                i = i || 0,
                n = n || 0;
                var a = this.renderer.getSize(new Vector2);
                i = i / a.width * 2 - 1,
                n = 1 - n / a.height * 2,
                t = t / a.width * 2,
                r = r / a.height * 2,
                this._debugMaterial.uniforms.u_texture.value = e,
                this._debugMaterial.uniforms.u_transform.value.set(i, n, t, r);
                var o = this.getColorState();
                this.renderer.autoClearColor = !1,
                this.renderer.setRenderTarget(null),
                this.renderer.render(this._debugScene, this._camera),
                this.setColorState(o)
            }
        }
    }, {
        key: "parseDefines",
        value: function(e) {
            var t = "";
            for (var r in e) {
                var i = e[r];
                t += !0 === i ? "#define ".concat(r, "\n") : "#define ".concat(r, " ").concat(i, "\n")
            }
            return t
        }
    }, {
        key: "clearColor",
        value: function(e, t, r, i, n) {
            this.clearMaterial && (this.clearMaterial.uniforms.u_color.value.set(e, t, r, i),
            this.render(this.clearMaterial, n))
        }
    }, {
        key: "getColorState",
        value: function() {
            if (!this.renderer)
                return {
                    autoClear: !0,
                    autoClearColor: !0,
                    autoClearStencil: !0,
                    autoClearDepth: !0,
                    clearColor: 0,
                    clearAlpha: 1
                };
            var e = new Color;
            return this.renderer.getClearColor(e),
            {
                autoClear: this.renderer.autoClear,
                autoClearColor: this.renderer.autoClearColor,
                autoClearStencil: this.renderer.autoClearStencil,
                autoClearDepth: this.renderer.autoClearDepth,
                clearColor: e.getHex(),
                clearAlpha: this.renderer.getClearAlpha()
            }
        }
    }, {
        key: "setColorState",
        value: function(e) {
            this.renderer && (this.renderer.setClearColor(e.clearColor, e.clearAlpha),
            this.renderer.autoClear = e.autoClear,
            this.renderer.autoClearColor = e.autoClearColor,
            this.renderer.autoClearStencil = e.autoClearStencil,
            this.renderer.autoClearDepth = e.autoClearDepth)
        }
    }, {
        key: "createRawShaderMaterial",
        value: function(e) {
            return (e = Object.assign({
                depthTest: !1,
                depthWrite: !1,
                blending: NoBlending,
                vertexShader: blitVert,
                fragmentShader: blitFrag
            }, e)).vertexShader = (void 0 !== e.vertexShaderPrefix ? e.vertexShaderPrefix : this.precisionPrefix) + e.vertexShader,
            e.fragmentShader = (void 0 !== e.fragmentShaderPrefix ? e.fragmentShaderPrefix : this.precisionPrefix) + e.fragmentShader,
            delete e.vertexShaderPrefix,
            delete e.fragmentShaderPrefix,
            new RawShaderMaterial(e)
        }
    }, {
        key: "createDataTexture",
        value: function(e, t, r) {
            var i = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]
              , n = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4]
              , a = new DataTexture(e,t,r,RGBAFormat,i ? FloatType : UnsignedByteType,UVMapping,ClampToEdgeWrapping,ClampToEdgeWrapping,n ? NearestFilter : LinearFilter,n ? NearestFilter : LinearFilter,0);
            return a.needsUpdate = !0,
            a
        }
    }, {
        key: "createRenderTarget",
        value: function(e, t) {
            var r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]
              , i = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]
              , n = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
            return new WebGLRenderTarget(e,t,{
                wrapS: ClampToEdgeWrapping,
                wrapT: ClampToEdgeWrapping,
                magFilter: r ? NearestFilter : LinearFilter,
                minFilter: r ? NearestFilter : LinearFilter,
                type: i ? this.floatType : UnsignedByteType,
                anisotropy: 0,
                encoding: LinearEncoding,
                depthBuffer: !1,
                stencilBuffer: !1,
                samples: n
            })
        }
    }, {
        key: "createMultisampleRenderTarget",
        value: function(e, t) {
            var r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]
              , i = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]
              , n = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 8;
            if (!this.renderer || !this.isWebGL2)
                return this.createRenderTarget(e, t, r, i);
            var a = new WebGLRenderTarget(e,t,{
                wrapS: ClampToEdgeWrapping,
                wrapT: ClampToEdgeWrapping,
                magFilter: r ? NearestFilter : LinearFilter,
                minFilter: r ? NearestFilter : LinearFilter,
                type: i ? this.floatType : UnsignedByteType,
                anisotropy: 0,
                encoding: LinearEncoding,
                depthBuffer: !1,
                stencilBuffer: !1,
                samples: n
            });
            return a
        }
    }, {
        key: "clearMultisampleRenderTargetState",
        value: function(e) {
            if ((e = e || this.renderer.getRenderTarget()) && e.samples > 0) {
                var t = this.renderer.getContext()
                  , r = this.renderer.state
                  , i = e.width
                  , n = e.height
                  , a = t.COLOR_BUFFER_BIT
                  , o = [t.COLOR_ATTACHMENT0]
                  , s = e.stencilBuffer ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT;
                e.depthBuffer && o.push(s);
                var l = this.renderer.properties.get(e)
                  , u = void 0 !== l.__ignoreDepthValues && l.__ignoreDepthValues;
                !1 === u && (e.depthBuffer && (a |= t.DEPTH_BUFFER_BIT),
                e.stencilBuffer && (a |= t.STENCIL_BUFFER_BIT)),
                r.bindFramebuffer(t.READ_FRAMEBUFFER, l.__webglMultisampledFramebuffer),
                r.bindFramebuffer(t.DRAW_FRAMEBUFFER, l.__webglFramebuffer),
                !0 === u && (t.invalidateFramebuffer(t.READ_FRAMEBUFFER, [s]),
                t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, [s])),
                t.blitFramebuffer(0, 0, i, n, 0, 0, i, n, a, t.NEAREST),
                t.invalidateFramebuffer(t.READ_FRAMEBUFFER, o),
                r.bindFramebuffer(t.READ_FRAMEBUFFER, null),
                r.bindFramebuffer(t.DRAW_FRAMEBUFFER, l.__webglMultisampledFramebuffer)
            }
        }
    }]),
    e
}(), fboHelper = new FboHelper, _geom, Postprocessing = function() {
    function e() {
        _classCallCheck(this, e),
        _defineProperty(this, "width", 1),
        _defineProperty(this, "height", 1),
        _defineProperty(this, "scene", null),
        _defineProperty(this, "camera", null),
        _defineProperty(this, "resolution", new Vector2(0,0)),
        _defineProperty(this, "texelSize", new Vector2(0,0)),
        _defineProperty(this, "aspect", new Vector2(1,1)),
        _defineProperty(this, "onBeforeSceneRendered", new MinSignal$2),
        _defineProperty(this, "onAfterSceneRendered", new MinSignal$2),
        _defineProperty(this, "onAfterRendered", new MinSignal$2),
        _defineProperty(this, "sceneRenderTarget", null),
        _defineProperty(this, "fromRenderTarget", null),
        _defineProperty(this, "toRenderTarget", null),
        _defineProperty(this, "useDepthTexture", !0),
        _defineProperty(this, "depthTexture", null),
        _defineProperty(this, "fromTexture", null),
        _defineProperty(this, "toTexture", null),
        _defineProperty(this, "sceneTexture", null),
        _defineProperty(this, "mesh", null),
        _defineProperty(this, "queue", []),
        _defineProperty(this, "sharedUniforms", {}),
        _defineProperty(this, "geom", void 0),
        _defineProperty(this, "hasSizeChanged", !0)
    }
    return _createClass(e, [{
        key: "init",
        value: function(e) {
            if (Object.assign(this, e),
            _geom ? this.geom = _geom : (this.geom = _geom = new BufferGeometry,
            this.geom.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, 0, 4, -1, 0, -1, 4, 0]),3)),
            this.geom.setAttribute("a_uvClamp", new BufferAttribute(new Float32Array([0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1]),4))),
            this.sceneRenderTarget = fboHelper.createMultisampleRenderTarget(1, 1),
            this.sceneRenderTarget.depthBuffer = !0,
            this.fromRenderTarget = fboHelper.createRenderTarget(1, 1),
            this.toRenderTarget = this.fromRenderTarget.clone(),
            this.useDepthTexture = !!this.useDepthTexture && fboHelper.renderer && (fboHelper.renderer.capabilities.isWebGL2 || fboHelper.renderer.extensions.get("WEBGL_depth_texture")),
            this.fromTexture = this.fromRenderTarget.texture,
            this.toTexture = this.toRenderTarget.texture,
            this.sceneTexture = this.sceneRenderTarget.texture,
            this.mesh = new Mesh,
            this.sharedUniforms = Object.assign(this.sharedUniforms, {
                u_sceneTexture: {
                    value: this.sceneRenderTarget.texture
                },
                u_sceneDepthTexture: {
                    value: null
                },
                u_cameraNear: {
                    value: 0
                },
                u_cameraFar: {
                    value: 1
                },
                u_cameraFovRad: {
                    value: 1
                },
                u_resolution: {
                    value: this.resolution
                },
                u_texelSize: {
                    value: this.texelSize
                },
                u_aspect: {
                    value: this.aspect
                }
            }),
            this.useDepthTexture && fboHelper.renderer) {
                var t = new DepthTexture(this.resolution.width,this.resolution.height);
                fboHelper.renderer.capabilities.isWebGL2 ? t.type = UnsignedIntType : (t.format = DepthStencilFormat,
                t.type = UnsignedInt248Type),
                t.minFilter = NearestFilter,
                t.magFilter = NearestFilter,
                this.sceneRenderTarget.depthTexture = t,
                this.depthTexture = this.sharedUniforms.u_sceneDepthTexture.value = t
            }
        }
    }, {
        key: "swap",
        value: function() {
            var e = this.fromRenderTarget;
            this.fromRenderTarget = this.toRenderTarget,
            this.toRenderTarget = e,
            this.fromTexture = this.fromRenderTarget.texture,
            this.toTexture = this.toRenderTarget.texture
        }
    }, {
        key: "setSize",
        value: function(e, t) {
            if (this.width !== e || this.height !== t) {
                this.hasSizeChanged = !0,
                this.width = e,
                this.height = t,
                this.resolution.set(e, t),
                this.texelSize.set(1 / e, 1 / t);
                var r = t / Math.sqrt(e * e + t * t) * 2;
                this.aspect.set(e / t * r, r),
                this.sceneRenderTarget.setSize(e, t),
                this.fromRenderTarget.setSize(e, t),
                this.toRenderTarget.setSize(e, t)
            }
        }
    }, {
        key: "dispose",
        value: function() {
            this.fromRenderTarget && this.fromRenderTarget.dispose(),
            this.toRenderTarget && this.toRenderTarget.dispose(),
            this.sceneRenderTarget && this.sceneRenderTarget.dispose()
        }
    }, {
        key: "_filterQueue",
        value: function(e) {
            return e.enabled && e.needsRender()
        }
    }, {
        key: "renderMaterial",
        value: function(e, t) {
            this.mesh.material = e,
            fboHelper.renderMesh(this.mesh, t)
        }
    }, {
        key: "render",
        value: function(e, t, r) {
            if (fboHelper.renderer) {
                this.scene = e,
                this.camera = t,
                this.mesh.geometry = this.geom;
                var i = this.queue.filter(this._filterQueue)
                  , n = this.sharedUniforms;
                if (n.u_sceneTexture.value = this.sceneRenderTarget.texture,
                n.u_cameraNear.value = t.near,
                n.u_cameraFar.value = t.far,
                n.u_cameraFovRad.value = t.fov / 180 * Math.PI,
                this.onBeforeSceneRendered.dispatch(),
                i.length) {
                    fboHelper.renderer.setRenderTarget(this.sceneRenderTarget),
                    fboHelper.renderer.render(e, t),
                    fboHelper.renderer.setRenderTarget(null),
                    fboHelper.copy(this.sceneRenderTarget.texture, this.fromRenderTarget),
                    this.onAfterSceneRendered.dispatch(this.sceneRenderTarget);
                    var a = fboHelper.getColorState();
                    fboHelper.renderer.autoClear = !1;
                    for (var o = 0, s = i.length; o < s; o++) {
                        var l = o === s - 1 && r
                          , u = i[o];
                        u.setPostprocessing(this),
                        u.render(this, l)
                    }
                    fboHelper.setColorState(a)
                } else
                    fboHelper.renderer.render(e, t),
                    this.onAfterSceneRendered.dispatch();
                this.onAfterRendered.dispatch(),
                this.hasSizeChanged = !1
            }
        }
    }]),
    e
}(), PostEffect = function() {
    function e() {
        _classCallCheck(this, e),
        _defineProperty(this, "sharedUniforms", {}),
        _defineProperty(this, "enabled", !0),
        _defineProperty(this, "material", null),
        _defineProperty(this, "_hasShownWarning", !1)
    }
    return _createClass(e, [{
        key: "init",
        value: function(e) {
            Object.assign(this, e)
        }
    }, {
        key: "needsRender",
        value: function() {
            return !0
        }
    }, {
        key: "warn",
        value: function(e) {
            this._hasShownWarning || (console.warn(e),
            this._hasShownWarning = !0)
        }
    }, {
        key: "setPostprocessing",
        value: function(e) {}
    }, {
        key: "render",
        value: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            this.material.uniforms.u_texture && (this.material.uniforms.u_texture.value = e.fromTexture),
            fboHelper.render(this.material, t ? null : e.toRenderTarget),
            e.swap()
        }
    }]),
    e
}(), smaaBlendVert = "#define GLSLIFY 1\nattribute vec3 position;uniform vec2 u_texelSize;varying vec2 v_uv;varying vec4 v_offsets[2];void SMAANeighborhoodBlendingVS(vec2 texcoord){v_offsets[0]=texcoord.xyxy+u_texelSize.xyxy*vec4(-1.0,0.0,0.0,1.0);v_offsets[1]=texcoord.xyxy+u_texelSize.xyxy*vec4(1.0,0.0,0.0,-1.0);}void main(){v_uv=position.xy*0.5+0.5;SMAANeighborhoodBlendingVS(v_uv);gl_Position=vec4(position,1.0);}", smaaBlendFrag = "#define GLSLIFY 1\nuniform sampler2D u_weightsTexture;uniform sampler2D u_texture;uniform vec2 u_texelSize;varying vec2 v_uv;varying vec4 v_offsets[2];vec4 SMAANeighborhoodBlendingPS(vec2 texcoord,vec4 offset[2],sampler2D colorTex,sampler2D blendTex){vec4 a;a.xz=texture2D(blendTex,texcoord).xz;a.y=texture2D(blendTex,offset[1].zw).g;a.w=texture2D(blendTex,offset[1].xy).a;if(dot(a,vec4(1.0,1.0,1.0,1.0))<1e-5){return texture2D(colorTex,texcoord,0.0);}else{vec2 offset;offset.x=a.a>a.b ? a.a :-a.b;offset.y=a.g>a.r ?-a.g : a.r;if(abs(offset.x)>abs(offset.y)){offset.y=0.0;}else{offset.x=0.0;}vec4 C=texture2D(colorTex,texcoord,0.0);texcoord+=sign(offset)*u_texelSize;vec4 Cop=texture2D(colorTex,texcoord,0.0);float s=abs(offset.x)>abs(offset.y)? abs(offset.x): abs(offset.y);C.xyz=pow(abs(C.xyz),vec3(2.2));Cop.xyz=pow(abs(Cop.xyz),vec3(2.2));vec4 mixed=mix(C,Cop,s);mixed.xyz=pow(abs(mixed.xyz),vec3(1.0/2.2));return mixed;}}void main(){gl_FragColor=SMAANeighborhoodBlendingPS(v_uv,v_offsets,u_texture,u_weightsTexture);}", smaaEdgesVert = "#define GLSLIFY 1\nattribute vec3 position;uniform vec2 u_texelSize;varying vec2 v_uv;varying vec4 v_offsets[3];void SMAAEdgeDetectionVS(vec2 texcoord){v_offsets[0]=texcoord.xyxy+u_texelSize.xyxy*vec4(-1.0,0.0,0.0,1.0);v_offsets[1]=texcoord.xyxy+u_texelSize.xyxy*vec4(1.0,0.0,0.0,-1.0);v_offsets[2]=texcoord.xyxy+u_texelSize.xyxy*vec4(-2.0,0.0,0.0,2.0);}void main(){v_uv=position.xy*0.5+0.5;SMAAEdgeDetectionVS(v_uv);gl_Position=vec4(position,1.0);}", smaaEdgesFrag = "#define GLSLIFY 1\nuniform sampler2D u_texture;varying vec2 v_uv;varying vec4 v_offsets[3];vec4 SMAAColorEdgeDetectionPS(vec2 texcoord,vec4 offset[3],sampler2D colorTex){vec2 threshold=vec2(SMAA_THRESHOLD,SMAA_THRESHOLD);vec4 delta;vec3 C=texture2D(colorTex,texcoord).rgb;vec3 Cleft=texture2D(colorTex,offset[0].xy).rgb;vec3 t=abs(C-Cleft);delta.x=max(max(t.r,t.g),t.b);vec3 Ctop=texture2D(colorTex,offset[0].zw).rgb;t=abs(C-Ctop);delta.y=max(max(t.r,t.g),t.b);vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0,1.0))==0.0)discard;vec3 Cright=texture2D(colorTex,offset[1].xy).rgb;t=abs(C-Cright);delta.z=max(max(t.r,t.g),t.b);vec3 Cbottom=texture2D(colorTex,offset[1].zw).rgb;t=abs(C-Cbottom);delta.w=max(max(t.r,t.g),t.b);float maxDelta=max(max(max(delta.x,delta.y),delta.z),delta.w);vec3 Cleftleft=texture2D(colorTex,offset[2].xy).rgb;t=abs(C-Cleftleft);delta.z=max(max(t.r,t.g),t.b);vec3 Ctoptop=texture2D(colorTex,offset[2].zw).rgb;t=abs(C-Ctoptop);delta.w=max(max(t.r,t.g),t.b);maxDelta=max(max(maxDelta,delta.z),delta.w);edges.xy*=step(0.5*maxDelta,delta.xy);return vec4(edges,0.0,0.0);}void main(){gl_FragColor=SMAAColorEdgeDetectionPS(v_uv,v_offsets,u_texture);}", smaaWeightsVert = "#define GLSLIFY 1\nattribute vec3 position;uniform vec2 u_texelSize;varying vec2 v_uv;varying vec4 v_offsets[3];varying vec2 v_pixcoord;void SMAABlendingWeightCalculationVS(vec2 texcoord){v_pixcoord=texcoord/u_texelSize;v_offsets[0]=texcoord.xyxy+u_texelSize.xyxy*vec4(-0.25,0.125,1.25,0.125);v_offsets[1]=texcoord.xyxy+u_texelSize.xyxy*vec4(-0.125,0.25,-0.125,-1.25);v_offsets[2]=vec4(v_offsets[0].xz,v_offsets[1].yw)+vec4(-2.0,2.0,-2.0,2.0)*u_texelSize.xxyy*float(SMAA_MAX_SEARCH_STEPS);}void main(){v_uv=position.xy*0.5+0.5;SMAABlendingWeightCalculationVS(v_uv);gl_Position=vec4(position,1.0);}", smaaWeightsFrag = "#define GLSLIFY 1\n#define SMAASampleLevelZeroOffset( tex, coord, offset ) texture2D( tex, coord + float( offset ) * u_texelSize, 0.0 )\nuniform sampler2D u_edgesTexture;uniform sampler2D u_areaTexture;uniform sampler2D u_searchTexture;uniform vec2 u_texelSize;varying vec2 v_uv;varying vec4 v_offsets[3];varying vec2 v_pixcoord;vec2 round(vec2 x){return sign(x)*floor(abs(x)+0.5);}float SMAASearchLength(sampler2D searchTex,vec2 e,float bias,float scale){e.r=bias+e.r*scale;return 255.0*texture2D(searchTex,e,0.0).r;}float SMAASearchXLeft(sampler2D edgesTex,sampler2D searchTex,vec2 texcoord,float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<SMAA_MAX_SEARCH_STEPS;i++){e=texture2D(edgesTex,texcoord,0.0).rg;texcoord-=vec2(2.0,0.0)*u_texelSize;if(!(texcoord.x>end&&e.g>0.8281&&e.r==0.0))break;}texcoord.x+=0.25*u_texelSize.x;texcoord.x+=u_texelSize.x;texcoord.x+=2.0*u_texelSize.x;texcoord.x-=u_texelSize.x*SMAASearchLength(searchTex,e,0.0,0.5);return texcoord.x;}float SMAASearchXRight(sampler2D edgesTex,sampler2D searchTex,vec2 texcoord,float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<SMAA_MAX_SEARCH_STEPS;i++){e=texture2D(edgesTex,texcoord,0.0).rg;texcoord+=vec2(2.0,0.0)*u_texelSize;if(!(texcoord.x<end&&e.g>0.8281&&e.r==0.0))break;}texcoord.x-=0.25*u_texelSize.x;texcoord.x-=u_texelSize.x;texcoord.x-=2.0*u_texelSize.x;texcoord.x+=u_texelSize.x*SMAASearchLength(searchTex,e,0.5,0.5);return texcoord.x;}float SMAASearchYUp(sampler2D edgesTex,sampler2D searchTex,vec2 texcoord,float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<SMAA_MAX_SEARCH_STEPS;i++){e=texture2D(edgesTex,texcoord,0.0).rg;texcoord+=vec2(0.0,2.0)*u_texelSize;if(!(texcoord.y>end&&e.r>0.8281&&e.g==0.0))break;}texcoord.y-=0.25*u_texelSize.y;texcoord.y-=u_texelSize.y;texcoord.y-=2.0*u_texelSize.y;texcoord.y+=u_texelSize.y*SMAASearchLength(searchTex,e.gr,0.0,0.5);return texcoord.y;}float SMAASearchYDown(sampler2D edgesTex,sampler2D searchTex,vec2 texcoord,float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<SMAA_MAX_SEARCH_STEPS;i++){e=texture2D(edgesTex,texcoord,0.0).rg;texcoord-=vec2(0.0,2.0)*u_texelSize;if(!(texcoord.y<end&&e.r>0.8281&&e.g==0.0))break;}texcoord.y+=0.25*u_texelSize.y;texcoord.y+=u_texelSize.y;texcoord.y+=2.0*u_texelSize.y;texcoord.y-=u_texelSize.y*SMAASearchLength(searchTex,e.gr,0.5,0.5);return texcoord.y;}vec2 SMAAArea(sampler2D areaTex,vec2 dist,float e1,float e2,float offset){vec2 texcoord=float(SMAA_AREATEX_MAX_DISTANCE)*round(4.0*vec2(e1,e2))+dist;texcoord=SMAA_AREATEX_PIXEL_SIZE*texcoord+(0.5*SMAA_AREATEX_PIXEL_SIZE);texcoord.y+=SMAA_AREATEX_SUBTEX_SIZE*offset;return texture2D(areaTex,texcoord,0.0).rg;}vec4 SMAABlendingWeightCalculationPS(vec2 texcoord,vec2 pixcoord,vec4 offset[3],sampler2D edgesTex,sampler2D areaTex,sampler2D searchTex,ivec4 subsampleIndices){vec4 weights=vec4(0.0,0.0,0.0,0.0);vec2 e=texture2D(edgesTex,texcoord).rg;if(e.g>0.0){vec2 d;vec2 coords;coords.x=SMAASearchXLeft(edgesTex,searchTex,offset[0].xy,offset[2].x);coords.y=offset[1].y;d.x=coords.x;float e1=texture2D(edgesTex,coords,0.0).r;coords.x=SMAASearchXRight(edgesTex,searchTex,offset[0].zw,offset[2].y);d.y=coords.x;d=d/u_texelSize.x-pixcoord.x;vec2 sqrt_d=sqrt(abs(d));coords.y-=1.0*u_texelSize.y;float e2=SMAASampleLevelZeroOffset(edgesTex,coords,ivec2(1,0)).r;weights.rg=SMAAArea(areaTex,sqrt_d,e1,e2,float(subsampleIndices.y));}if(e.r>0.0){vec2 d;vec2 coords;coords.y=SMAASearchYUp(edgesTex,searchTex,offset[1].xy,offset[2].z);coords.x=offset[0].x;d.x=coords.y;float e1=texture2D(edgesTex,coords,0.0).g;coords.y=SMAASearchYDown(edgesTex,searchTex,offset[1].zw,offset[2].w);d.y=coords.y;d=d/u_texelSize.y-pixcoord.y;vec2 sqrt_d=sqrt(abs(d));coords.y-=1.0*u_texelSize.y;float e2=SMAASampleLevelZeroOffset(edgesTex,coords,ivec2(0,1)).g;weights.ba=SMAAArea(areaTex,sqrt_d,e1,e2,float(subsampleIndices.x));}return weights;}void main(){gl_FragColor=SMAABlendingWeightCalculationPS(v_uv,v_pixcoord,v_offsets,u_edgesTexture,u_areaTexture,u_searchTexture,ivec4(0.0));}", Smaa = function(e) {
    _inherits(r, PostEffect);
    var t = _createSuper(r);
    function r() {
        var e;
        _classCallCheck(this, r);
        for (var i = arguments.length, n = new Array(i), a = 0; a < i; a++)
            n[a] = arguments[a];
        return _defineProperty(_assertThisInitialized(e = t.call.apply(t, [this].concat(n))), "edgesRenderTarget", null),
        _defineProperty(_assertThisInitialized(e), "weightsRenderTarget", null),
        _defineProperty(_assertThisInitialized(e), "edgesMaterial", null),
        _defineProperty(_assertThisInitialized(e), "weightsMaterial", null),
        e
    }
    return _createClass(r, [{
        key: "init",
        value: function(e) {
            Object.assign(this, {
                sharedUniforms: {
                    u_areaTexture: {
                        value: null
                    },
                    u_searchTexture: {
                        value: null
                    }
                }
            }, e),
            _get(_getPrototypeOf(r.prototype), "init", this).call(this),
            this.weightsRenderTarget = fboHelper.createRenderTarget(1, 1),
            this.edgesRenderTarget = fboHelper.createRenderTarget(1, 1),
            this.edgesMaterial = new RawShaderMaterial({
                uniforms: {
                    u_texture: {
                        value: null
                    },
                    u_texelSize: null
                },
                vertexShader: fboHelper.precisionPrefix + smaaEdgesVert,
                fragmentShader: fboHelper.precisionPrefix + smaaEdgesFrag,
                defines: {
                    SMAA_THRESHOLD: "0.1"
                },
                blending: NoBlending,
                depthTest: !1,
                depthWrite: !1
            }),
            this.weightsMaterial = new RawShaderMaterial({
                uniforms: {
                    u_edgesTexture: {
                        value: this.edgesRenderTarget.texture
                    },
                    u_areaTexture: this.sharedUniforms.u_areaTexture,
                    u_searchTexture: this.sharedUniforms.u_searchTexture,
                    u_texelSize: null
                },
                vertexShader: fboHelper.precisionPrefix + smaaWeightsVert,
                fragmentShader: fboHelper.precisionPrefix + smaaWeightsFrag,
                defines: {
                    SMAA_MAX_SEARCH_STEPS: "8",
                    SMAA_AREATEX_MAX_DISTANCE: "16",
                    SMAA_AREATEX_PIXEL_SIZE: "( 1.0 / vec2( 160.0, 560.0 ) )",
                    SMAA_AREATEX_SUBTEX_SIZE: "( 1.0 / 7.0 )"
                },
                transparent: !0,
                blending: NoBlending,
                depthTest: !1,
                depthWrite: !1
            }),
            this.material = fboHelper.createRawShaderMaterial({
                uniforms: {
                    u_texture: {
                        value: null
                    },
                    u_weightsTexture: {
                        value: this.weightsRenderTarget.texture
                    },
                    u_texelSize: null
                },
                vertexShader: fboHelper.precisionPrefix + smaaBlendVert,
                fragmentShader: fboHelper.precisionPrefix + smaaBlendFrag
            })
        }
    }, {
        key: "setTextures",
        value: function(e, t) {
            (this.sharedUniforms.u_areaTexture.value = this._createTexture(e)).minFilter = LinearFilter;
            var r = this.sharedUniforms.u_searchTexture.value = this._createTexture(t);
            r.magFilter = NearestFilter,
            r.minFilter = NearestFilter
        }
    }, {
        key: "updateTextures",
        value: function() {
            this.sharedUniforms.u_areaTexture.value.needsUpdate = !0,
            this.sharedUniforms.u_searchTexture.value.needsUpdate = !0
        }
    }, {
        key: "setPostprocessing",
        value: function(e) {
            _get(_getPrototypeOf(r.prototype), "setPostprocessing", this).call(this, e);
            var t = e.width
              , i = e.height;
            this.edgesRenderTarget.setSize(t, i),
            this.weightsRenderTarget.setSize(t, i)
        }
    }, {
        key: "dispose",
        value: function() {
            this.edgesRenderTarget && this.edgesRenderTarget.dispose(),
            this.weightsRenderTarget && this.weightsRenderTarget.dispose()
        }
    }, {
        key: "needsRender",
        value: function() {
            return !this.sharedUniforms.u_areaTexture.value.needsUpdate
        }
    }, {
        key: "render",
        value: function(e, t) {
            var i = fboHelper.getColorState();
            this.sharedUniforms.u_searchTexture.value || console.warn("You need to use Smaa.setImages() to set the smaa textures manually and assign to this class.");
            var n = fboHelper.renderer;
            n && (n.autoClear = !0,
            n.setClearColor(0, 0)),
            this.edgesMaterial.uniforms.u_texelSize = this.weightsMaterial.uniforms.u_texelSize = this.material.uniforms.u_texelSize = e.sharedUniforms.u_texelSize,
            this.edgesMaterial.uniforms.u_texture.value = e.fromTexture,
            e.renderMaterial(this.edgesMaterial, this.edgesRenderTarget),
            e.renderMaterial(this.weightsMaterial, this.weightsRenderTarget),
            fboHelper.setColorState(i),
            this.material.uniforms.u_texture.value = e.fromTexture,
            _get(_getPrototypeOf(r.prototype), "render", this).call(this, e, t)
        }
    }, {
        key: "_createTexture",
        value: function(e) {
            var t = new Texture(e);
            return t.generateMipmaps = !1,
            t.flipY = !1,
            t
        }
    }]),
    r
}(), fragmentShader$1 = "#define GLSLIFY 1\nvarying vec2 v_uv;uniform sampler2D u_texture;uniform sampler2D u_blurTexture0;\n#if ITERATION > 1\nuniform sampler2D u_blurTexture1;\n#endif\n#if ITERATION > 2\nuniform sampler2D u_blurTexture2;\n#endif\n#if ITERATION > 3\nuniform sampler2D u_blurTexture3;\n#endif\n#if ITERATION > 4\nuniform sampler2D u_blurTexture4;\n#endif\nuniform float u_bloomWeights[ITERATION];\n#include <common>\nvec3 dithering(vec3 color){float grid_position=rand(gl_FragCoord.xy);vec3 dither_shift_RGB=vec3(0.25/255.0,-0.25/255.0,0.25/255.0);dither_shift_RGB=mix(2.0*dither_shift_RGB,-2.0*dither_shift_RGB,grid_position);return color+dither_shift_RGB;}void main(){vec4 c=texture2D(u_texture,v_uv);vec3 luma=vec3(0.299,0.587,0.114);float v=dot(c.xyz,luma);float a=1.0-v;gl_FragColor=c+(u_bloomWeights[0]*texture2D(u_blurTexture0,v_uv)\n#if ITERATION > 1\n+u_bloomWeights[1]*texture2D(u_blurTexture1,v_uv)\n#endif\n#if ITERATION > 2\n+u_bloomWeights[2]*texture2D(u_blurTexture2,v_uv)\n#endif\n#if ITERATION > 3\n+u_bloomWeights[3]*texture2D(u_blurTexture3,v_uv)\n#endif\n#if ITERATION > 4\n+u_bloomWeights[4]*texture2D(u_blurTexture4,v_uv)\n#endif\n)*a;gl_FragColor.rgb=dithering(gl_FragColor.rgb);gl_FragColor.a=1.0;}", highPassFragmentShader = "#define GLSLIFY 1\nuniform sampler2D u_texture;uniform float u_luminosityThreshold;uniform float u_smoothWidth;\n#ifdef USE_HALO\nuniform vec2 u_texelSize;uniform vec2 u_aspect;uniform float u_haloWidth;uniform float u_haloRGBShift;uniform float u_haloStrength;uniform float u_haloMaskInner;uniform float u_haloMaskOuter;\n#endif\nvarying vec2 v_uv;void main(){vec4 texel=texture2D(u_texture,v_uv);vec3 luma=vec3(0.299,0.587,0.114);float v=dot(texel.xyz,luma);vec4 outputColor=vec4(0.0,0.0,0.0,1.0);float alpha=smoothstep(u_luminosityThreshold,u_luminosityThreshold+u_smoothWidth,v);outputColor=mix(outputColor,texel,alpha);gl_FragColor=vec4(outputColor.rgb,1.0);\n#ifdef USE_HALO\nvec2 toCenter=(v_uv-0.5)*u_aspect;vec2 ghostUv=1.0-(toCenter+0.5);vec2 ghostVec=(vec2(0.5)-ghostUv);vec2 direction=normalize(ghostVec);vec2 haloVec=direction*u_haloWidth;float weight=length(vec2(0.5)-fract(ghostUv+haloVec));weight=pow(1.0-weight,3.0);vec3 distortion=vec3(-u_texelSize.x,0.0,u_texelSize.x)*u_haloRGBShift;float zoomBlurRatio=fract(atan(toCenter.y,toCenter.x)*40.0)*0.05+0.95;vec2 uv=ghostUv*zoomBlurRatio+haloVec;gl_FragColor.rgb+=vec3(texture2D(u_texture,uv+direction*distortion.r).r,texture2D(u_texture,uv+direction*distortion.g).g,texture2D(u_texture,uv+direction*distortion.b).b)*u_haloStrength*smoothstep(u_haloMaskInner,u_haloMaskOuter,length(toCenter));\n#endif\n}", blurFragmentShader = "#define GLSLIFY 1\nvarying vec2 v_uv;uniform sampler2D u_texture;uniform vec2 u_resolution;uniform vec2 u_direction;float gaussianPdf(in float x,in float sigma){return 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;}void main(){vec2 invSize=1.0/u_resolution;float fSigma=float(SIGMA);float weightSum=gaussianPdf(0.0,fSigma);vec3 diffuseSum=texture2D(u_texture,v_uv).rgb*weightSum;for(int i=1;i<KERNEL_RADIUS;i++){float x=float(i);float w=gaussianPdf(x,fSigma);vec2 uvOffset=u_direction*invSize*x;vec3 sample1=texture2D(u_texture,v_uv+uvOffset).rgb;vec3 sample2=texture2D(u_texture,v_uv-uvOffset).rgb;diffuseSum+=(sample1+sample2)*w;weightSum+=2.0*w;}gl_FragColor=vec4(diffuseSum/weightSum,1.0);}", Bloom = function(e) {
    _inherits(r, PostEffect);
    var t = _createSuper(r);
    function r() {
        var e;
        _classCallCheck(this, r);
        for (var i = arguments.length, n = new Array(i), a = 0; a < i; a++)
            n[a] = arguments[a];
        return _defineProperty(_assertThisInitialized(e = t.call.apply(t, [this].concat(n))), "ITERATION", 5),
        _defineProperty(_assertThisInitialized(e), "amount", 1),
        _defineProperty(_assertThisInitialized(e), "radius", 0),
        _defineProperty(_assertThisInitialized(e), "threshold", .1),
        _defineProperty(_assertThisInitialized(e), "smoothWidth", 1),
        _defineProperty(_assertThisInitialized(e), "haloWidth", .8),
        _defineProperty(_assertThisInitialized(e), "haloRGBShift", .03),
        _defineProperty(_assertThisInitialized(e), "haloStrength", .21),
        _defineProperty(_assertThisInitialized(e), "haloMaskInner", .3),
        _defineProperty(_assertThisInitialized(e), "haloMaskOuter", .5),
        _defineProperty(_assertThisInitialized(e), "highPassMaterial", void 0),
        _defineProperty(_assertThisInitialized(e), "highPassRenderTarget", void 0),
        _defineProperty(_assertThisInitialized(e), "renderTargetsHorizontal", []),
        _defineProperty(_assertThisInitialized(e), "renderTargetsVertical", []),
        _defineProperty(_assertThisInitialized(e), "blurMaterials", []),
        _defineProperty(_assertThisInitialized(e), "directionX", new Vector2(1,0)),
        _defineProperty(_assertThisInitialized(e), "directionY", new Vector2(0,1)),
        e
    }
    return _createClass(r, [{
        key: "init",
        value: function(e) {
            Object.assign(this, e),
            _get(_getPrototypeOf(r.prototype), "init", this).call(this),
            this.highPassRenderTarget = fboHelper.createRenderTarget(1, 1),
            this.highPassMaterial = fboHelper.createRawShaderMaterial({
                uniforms: {
                    u_texture: {
                        value: null
                    },
                    u_luminosityThreshold: {
                        value: 1
                    },
                    u_smoothWidth: {
                        value: 1
                    },
                    u_haloWidth: {
                        value: 1
                    },
                    u_haloRGBShift: {
                        value: 1
                    },
                    u_haloStrength: {
                        value: 1
                    },
                    u_haloMaskInner: {
                        value: 1
                    },
                    u_haloMaskOuter: {
                        value: 1
                    },
                    u_texelSize: null,
                    u_aspect: null
                },
                fragmentShader: highPassFragmentShader
            });
            for (var t = 0; t < this.ITERATION; t++) {
                this.renderTargetsHorizontal.push(this.highPassRenderTarget.clone()),
                this.renderTargetsVertical.push(this.highPassRenderTarget.clone());
                var i = 3 + 2 * t;
                this.blurMaterials[t] = fboHelper.createRawShaderMaterial({
                    uniforms: {
                        u_texture: {
                            value: null
                        },
                        u_resolution: {
                            value: new Vector2
                        },
                        u_direction: {
                            value: null
                        }
                    },
                    fragmentShader: blurFragmentShader,
                    defines: {
                        KERNEL_RADIUS: i,
                        SIGMA: i
                    }
                })
            }
            this.material = fboHelper.createRawShaderMaterial({
                uniforms: {
                    u_texture: {
                        value: null
                    },
                    u_bloomStrength: {
                        value: 1
                    },
                    u_bloomWeights: {
                        value: []
                    }
                },
                fragmentShader: fragmentShader$1,
                blending: NoBlending,
                defines: {
                    ITERATION: this.ITERATION
                }
            });
            for (var n = 0; n < this.ITERATION; n++)
                this.material.uniforms["u_blurTexture" + n] = {
                    value: this.renderTargetsVertical[n].texture
                }
        }
    }, {
        key: "setPostprocessing",
        value: function(e) {
            _get(_getPrototypeOf(r.prototype), "setPostprocessing", this).call(this, e);
            var t = e.width
              , i = e.height
              , n = Math.ceil(t / 2)
              , a = Math.ceil(i / 2);
            this.highPassRenderTarget.setSize(n, a);
            for (var o = 0; o < this.ITERATION; o++)
                this.renderTargetsHorizontal[o].setSize(n, a),
                this.renderTargetsVertical[o].setSize(n, a),
                this.blurMaterials[o].uniforms.u_resolution.value.set(n, a),
                n = Math.ceil(n / 2),
                a = Math.ceil(a / 2)
        }
    }, {
        key: "dispose",
        value: function() {
            this.highPassRenderTarget && this.highPassRenderTarget.dispose();
            for (var e = 0; e < this.ITERATION; e++)
                this.renderTargetsHorizontal[e] && this.renderTargetsHorizontal[e].dispose(),
                this.renderTargetsVertical[e] && this.renderTargetsVertical[e].dispose()
        }
    }, {
        key: "needsRender",
        value: function() {
            return !!this.amount
        }
    }, {
        key: "render",
        value: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            this.highPassMaterial.uniforms.u_texture.value = e.fromTexture,
            this.highPassMaterial.uniforms.u_luminosityThreshold.value = this.threshold,
            this.highPassMaterial.uniforms.u_smoothWidth.value = this.smoothWidth,
            this.highPassMaterial.uniforms.u_haloWidth.value = this.haloWidth,
            this.highPassMaterial.uniforms.u_haloRGBShift.value = this.haloRGBShift * e.width,
            this.highPassMaterial.uniforms.u_haloStrength.value = this.haloStrength,
            this.highPassMaterial.uniforms.u_haloMaskInner.value = this.haloMaskInner,
            this.highPassMaterial.uniforms.u_haloMaskOuter.value = this.haloMaskOuter,
            this.highPassMaterial.uniforms.u_texelSize = e.sharedUniforms.u_texelSize,
            this.highPassMaterial.uniforms.u_aspect = e.sharedUniforms.u_aspect;
            var i = this.haloStrength > 0;
            this.highPassMaterial.defines.USE_HALO !== i && (this.highPassMaterial.defines.USE_HALO = i,
            this.highPassMaterial.needsUpdate = !0),
            e.renderMaterial(this.highPassMaterial, this.highPassRenderTarget);
            for (var n = this.highPassRenderTarget, a = 0; a < this.ITERATION; a++) {
                var o = this.blurMaterials[a];
                o.uniforms.u_texture.value = n.texture,
                o.uniforms.u_direction.value = this.directionX,
                e.renderMaterial(o, this.renderTargetsHorizontal[a]),
                o.uniforms.u_texture.value = this.renderTargetsHorizontal[a].texture,
                o.uniforms.u_direction.value = this.directionY,
                e.renderMaterial(o, this.renderTargetsVertical[a]),
                n = this.renderTargetsVertical[a]
            }
            this.material.uniforms.u_texture.value = e.fromTexture;
            for (var s = 0; s < this.ITERATION; s++) {
                var l = (this.ITERATION - s) / this.ITERATION;
                this.material.uniforms.u_bloomWeights.value[s] = this.amount * (l + (1.2 - 2 * l) * this.radius) / Math.pow(2, this.ITERATION - s - 1)
            }
            _get(_getPrototypeOf(r.prototype), "render", this).call(this, e, t)
        }
    }]),
    r
}(), bokehCocShader = "#define GLSLIFY 1\nuniform sampler2D u_texture;uniform sampler2D u_depthTexture;uniform vec2 u_texelSize;uniform float u_focusDistance;uniform float u_lensCoeff;uniform float u_maxCoC;uniform float u_rcpMaxCoC;uniform float u_cameraNear;uniform float u_cameraFar;varying vec2 v_uv;float max3(vec3 xyz){return max(xyz.x,max(xyz.y,xyz.z));}\n#ifndef USE_FLOAT\nuniform float u_hashNoise;float hash13(vec3 p3){p3=fract(p3*.1031);p3+=dot(p3,p3.yzx+33.33);return fract((p3.x+p3.y)*p3.z);}\n#endif\nfloat getViewZ(vec2 uv){float depth=texture2D(u_depthTexture,uv).r*2.0-1.0;return 2.0*u_cameraNear*u_cameraFar/(u_cameraFar+u_cameraNear-depth*(u_cameraFar-u_cameraNear));}void main(){vec3 duv=u_texelSize.xyx*vec3(0.5,0.5,-0.5);vec3 c0=texture2D(u_texture,v_uv-duv.xy).rgb;vec3 c1=texture2D(u_texture,v_uv-duv.zy).rgb;vec3 c2=texture2D(u_texture,v_uv+duv.zy).rgb;vec3 c3=texture2D(u_texture,v_uv+duv.xy).rgb;vec2 uvAlt=v_uv;float d0=getViewZ(uvAlt-duv.xy);float d1=getViewZ(uvAlt-duv.zy);float d2=getViewZ(uvAlt+duv.zy);float d3=getViewZ(uvAlt+duv.xy);vec4 depths=vec4(d0,d1,d2,d3);float focusDistance=u_focusDistance;vec4 cocs=(depths-focusDistance)*u_lensCoeff/depths;cocs=clamp(cocs,-u_maxCoC,u_maxCoC);vec4 weights=clamp(abs(cocs)*u_rcpMaxCoC,vec4(0.0),vec4(1.0));weights.x*=1.0/(max3(c0)+1.0);weights.y*=1.0/(max3(c1)+1.0);weights.z*=1.0/(max3(c2)+1.0);weights.w*=1.0/(max3(c3)+1.0);vec3 avg=c0*weights.x+c1*weights.y+c2*weights.z+c3*weights.w;avg/=dot(weights,vec4(1.0));float coc=dot(cocs,vec4(0.25));avg*=smoothstep(0.0,u_texelSize.y*2.0,abs(coc));gl_FragColor=vec4(avg,coc);\n#ifndef USE_FLOAT\ngl_FragColor=sign(gl_FragColor)*sqrt(abs(gl_FragColor));gl_FragColor=gl_FragColor*0.5+0.5+hash13(vec3(gl_FragCoord.xy,u_hashNoise))/255.0;\n#endif\n}", bokehSimShader = "#define GLSLIFY 1\n#if QUALITY == 0\nconst int kSampleCount=16;vec2 kDiskKernel[kSampleCount];void initKernel(){kDiskKernel[0]=vec2(0.0,0.0);kDiskKernel[1]=vec2(0.54545456,0.0);kDiskKernel[2]=vec2(0.16855472,0.5187581);kDiskKernel[3]=vec2(-0.44128203,0.3206101);kDiskKernel[4]=vec2(-0.44128197,-0.3206102);kDiskKernel[5]=vec2(0.1685548,-0.5187581);kDiskKernel[6]=vec2(1.0,0.0);kDiskKernel[7]=vec2(0.809017,0.58778524);kDiskKernel[8]=vec2(0.30901697,0.95105654);kDiskKernel[9]=vec2(-0.30901703,0.9510565);kDiskKernel[10]=vec2(-0.80901706,0.5877852);kDiskKernel[11]=vec2(-1.0,0.0);kDiskKernel[12]=vec2(-0.80901694,-0.58778536);kDiskKernel[13]=vec2(-0.30901664,-0.9510566);kDiskKernel[14]=vec2(0.30901712,-0.9510565);kDiskKernel[15]=vec2(0.80901694,-0.5877853);}\n#endif\n#if QUALITY == 1\nconst int kSampleCount=22;vec2 kDiskKernel[kSampleCount];void initKernel(){kDiskKernel[0]=vec2(0.0,0.0);kDiskKernel[1]=vec2(0.53333336,0.0);kDiskKernel[2]=vec2(0.3325279,0.4169768);kDiskKernel[3]=vec2(-0.11867785,0.5199616);kDiskKernel[4]=vec2(-0.48051673,0.2314047);kDiskKernel[5]=vec2(-0.48051673,-0.23140468);kDiskKernel[6]=vec2(-0.11867763,-0.51996166);kDiskKernel[7]=vec2(0.33252785,-0.4169769);kDiskKernel[8]=vec2(1.0,0.0);kDiskKernel[9]=vec2(0.90096885,0.43388376);kDiskKernel[10]=vec2(0.6234898,0.7818315);kDiskKernel[11]=vec2(0.22252098,0.9749279);kDiskKernel[12]=vec2(-0.22252095,0.9749279);kDiskKernel[13]=vec2(-0.62349,0.7818314);kDiskKernel[14]=vec2(-0.90096885,0.43388382);kDiskKernel[15]=vec2(-1.0,0.0);kDiskKernel[16]=vec2(-0.90096885,-0.43388376);kDiskKernel[17]=vec2(-0.6234896,-0.7818316);kDiskKernel[18]=vec2(-0.22252055,-0.974928);kDiskKernel[19]=vec2(0.2225215,-0.9749278);kDiskKernel[20]=vec2(0.6234897,-0.7818316);kDiskKernel[21]=vec2(0.90096885,-0.43388376);}\n#endif\n#if QUALITY == 2\nconst int kSampleCount=43;vec2 kDiskKernel[kSampleCount];void initKernel(){kDiskKernel[0]=vec2(0.0,0.0);kDiskKernel[1]=vec2(0.36363637,0.0);kDiskKernel[2]=vec2(0.22672357,0.28430238);kDiskKernel[3]=vec2(-0.08091671,0.35451925);kDiskKernel[4]=vec2(-0.32762504,0.15777594);kDiskKernel[5]=vec2(-0.32762504,-0.15777591);kDiskKernel[6]=vec2(-0.08091656,-0.35451928);kDiskKernel[7]=vec2(0.22672352,-0.2843024);kDiskKernel[8]=vec2(0.6818182,0.0);kDiskKernel[9]=vec2(0.614297,0.29582983);kDiskKernel[10]=vec2(0.42510667,0.5330669);kDiskKernel[11]=vec2(0.15171885,0.6647236);kDiskKernel[12]=vec2(-0.15171883,0.6647236);kDiskKernel[13]=vec2(-0.4251068,0.53306687);kDiskKernel[14]=vec2(-0.614297,0.29582986);kDiskKernel[15]=vec2(-0.6818182,0);kDiskKernel[16]=vec2(-0.614297,-0.29582983);kDiskKernel[17]=vec2(-0.42510656,-0.53306705);kDiskKernel[18]=vec2(-0.15171856,-0.66472363);kDiskKernel[19]=vec2(0.1517192,-0.6647235);kDiskKernel[20]=vec2(0.4251066,-0.53306705);kDiskKernel[21]=vec2(0.614297,-0.29582983);kDiskKernel[22]=vec2(1.0,0.0);kDiskKernel[23]=vec2(0.9555728,0.2947552);kDiskKernel[24]=vec2(0.82623875,0.5633201);kDiskKernel[25]=vec2(0.6234898,0.7818315);kDiskKernel[26]=vec2(0.36534098,0.93087375);kDiskKernel[27]=vec2(0.07473,0.9972038);kDiskKernel[28]=vec2(-0.22252095,0.9749279);kDiskKernel[29]=vec2(-0.50000006,0.8660254);kDiskKernel[30]=vec2(-0.73305196,0.6801727);kDiskKernel[31]=vec2(-0.90096885,0.43388382);kDiskKernel[32]=vec2(-0.98883086,0.14904208);kDiskKernel[33]=vec2(-0.9888308,-0.14904249);kDiskKernel[34]=vec2(-0.90096885,-0.43388376);kDiskKernel[35]=vec2(-0.73305184,-0.6801728);kDiskKernel[36]=vec2(-0.4999999,-0.86602545);kDiskKernel[37]=vec2(-0.222521,-0.9749279);kDiskKernel[38]=vec2(0.07473029,-0.99720377);kDiskKernel[39]=vec2(0.36534148,-0.9308736);kDiskKernel[40]=vec2(0.6234897,-0.7818316);kDiskKernel[41]=vec2(0.8262388,-0.56332);kDiskKernel[42]=vec2(0.9555729,-0.29475483);}\n#endif\n#if QUALITY == 3\nconst int kSampleCount=71;vec2 kDiskKernel[kSampleCount];void initKernel(){kDiskKernel[0]=vec2(0,0);kDiskKernel[1]=vec2(0.2758621,0.0);kDiskKernel[2]=vec2(0.1719972,0.21567768);kDiskKernel[3]=vec2(-0.061385095,0.26894566);kDiskKernel[4]=vec2(-0.24854316,0.1196921);kDiskKernel[5]=vec2(-0.24854316,-0.11969208);kDiskKernel[6]=vec2(-0.061384983,-0.2689457);kDiskKernel[7]=vec2(0.17199717,-0.21567771);kDiskKernel[8]=vec2(0.51724136,0.0);kDiskKernel[9]=vec2(0.46601835,0.22442262);kDiskKernel[10]=vec2(0.32249472,0.40439558);kDiskKernel[11]=vec2(0.11509705,0.50427306);kDiskKernel[12]=vec2(-0.11509704,0.50427306);kDiskKernel[13]=vec2(-0.3224948,0.40439552);kDiskKernel[14]=vec2(-0.46601835,0.22442265);kDiskKernel[15]=vec2(-0.51724136,0.0);kDiskKernel[16]=vec2(-0.46601835,-0.22442262);kDiskKernel[17]=vec2(-0.32249463,-0.40439564);kDiskKernel[18]=vec2(-0.11509683,-0.5042731);kDiskKernel[19]=vec2(0.11509732,-0.504273);kDiskKernel[20]=vec2(0.32249466,-0.40439564);kDiskKernel[21]=vec2(0.46601835,-0.22442262);kDiskKernel[22]=vec2(0.7586207,0.0);kDiskKernel[23]=vec2(0.7249173,0.22360738);kDiskKernel[24]=vec2(0.6268018,0.4273463);kDiskKernel[25]=vec2(0.47299224,0.59311354);kDiskKernel[26]=vec2(0.27715522,0.7061801);kDiskKernel[27]=vec2(0.056691725,0.75649947);kDiskKernel[28]=vec2(-0.168809,0.7396005);kDiskKernel[29]=vec2(-0.3793104,0.65698475);kDiskKernel[30]=vec2(-0.55610836,0.51599306);kDiskKernel[31]=vec2(-0.6834936,0.32915324);kDiskKernel[32]=vec2(-0.7501475,0.113066405);kDiskKernel[33]=vec2(-0.7501475,-0.11306671);kDiskKernel[34]=vec2(-0.6834936,-0.32915318);kDiskKernel[35]=vec2(-0.5561083,-0.5159932);kDiskKernel[36]=vec2(-0.37931028,-0.6569848);kDiskKernel[37]=vec2(-0.16880904,-0.7396005);kDiskKernel[38]=vec2(0.056691945,-0.7564994);kDiskKernel[39]=vec2(0.2771556,-0.7061799);kDiskKernel[40]=vec2(0.47299215,-0.59311366);kDiskKernel[41]=vec2(0.62680185,-0.4273462);kDiskKernel[42]=vec2(0.72491735,-0.22360711);kDiskKernel[43]=vec2(1.0,0.0);kDiskKernel[44]=vec2(0.9749279,0.22252093);kDiskKernel[45]=vec2(0.90096885,0.43388376);kDiskKernel[46]=vec2(0.7818315,0.6234898);kDiskKernel[47]=vec2(0.6234898,0.7818315);kDiskKernel[48]=vec2(0.43388364,0.9009689);kDiskKernel[49]=vec2(0.22252098,0.9749279);kDiskKernel[50]=vec2(0.0,1.0);kDiskKernel[51]=vec2(-0.22252095,0.9749279);kDiskKernel[52]=vec2(-0.43388385,0.90096885);kDiskKernel[53]=vec2(-0.62349,0.7818314);kDiskKernel[54]=vec2(-0.7818317,0.62348956);kDiskKernel[55]=vec2(-0.90096885,0.43388382);kDiskKernel[56]=vec2(-0.9749279,0.22252093);kDiskKernel[57]=vec2(-1.0,0.0);kDiskKernel[58]=vec2(-0.9749279,-0.22252087);kDiskKernel[59]=vec2(-0.90096885,-0.43388376);kDiskKernel[60]=vec2(-0.7818314,-0.6234899);kDiskKernel[61]=vec2(-0.6234896,-0.7818316);kDiskKernel[62]=vec2(-0.43388346,-0.900969);kDiskKernel[63]=vec2(-0.22252055,-0.974928);kDiskKernel[64]=vec2(0.0,-1.0);kDiskKernel[65]=vec2(0.2225215,-0.9749278);kDiskKernel[66]=vec2(0.4338835,-0.90096897);kDiskKernel[67]=vec2(0.6234897,-0.7818316);kDiskKernel[68]=vec2(0.78183144,-0.62348986);kDiskKernel[69]=vec2(0.90096885,-0.43388376);kDiskKernel[70]=vec2(0.9749279,-0.22252086);}\n#endif\nuniform sampler2D u_cocTexture;uniform vec2 u_cocTexelSize;uniform float u_rcpAspect;uniform float u_maxCoC;varying vec2 v_uv;void main(){initKernel();vec4 samp0=texture2D(u_cocTexture,v_uv);\n#ifndef USE_FLOAT\nsamp0=samp0*2.0-1.0;samp0=sign(samp0)*samp0*samp0;\n#endif\nvec4 bgAcc=vec4(0.0);vec4 fgAcc=vec4(0.0);for(int si=0;si<kSampleCount;si++){vec2 disp=kDiskKernel[si]*u_maxCoC;float dist=length(disp);vec2 duv=vec2(disp.x*u_rcpAspect,disp.y);vec4 samp=texture2D(u_cocTexture,v_uv+duv);\n#ifndef USE_FLOAT\nsamp=samp*2.0-1.0;samp=sign(samp)*samp*samp;\n#endif\nfloat bgCoC=max(min(samp0.a,samp.a),0.0);float margin=u_cocTexelSize.y*2.0;float bgWeight=clamp((bgCoC-dist+margin)/margin,0.0,1.0);float fgWeight=clamp((-samp.a-dist+margin)/margin,0.0,1.0);fgWeight*=step(u_cocTexelSize.y,-samp.a);bgAcc+=vec4(samp.rgb,1.0)*bgWeight;fgAcc+=vec4(samp.rgb,1.0)*fgWeight;}bgAcc.rgb/=bgAcc.a+step(bgAcc.a,0.0);fgAcc.rgb/=fgAcc.a+step(fgAcc.a,0.0);bgAcc.a=smoothstep(u_cocTexelSize.y,u_cocTexelSize.y*2.0,samp0.a);fgAcc.a*=3.14159265359/float(kSampleCount);vec3 rgb=vec3(0.0);rgb=mix(rgb,bgAcc.rgb,clamp(bgAcc.a,0.0,1.0));rgb=mix(rgb,fgAcc.rgb,clamp(fgAcc.a,0.0,1.0));float alpha=(1.0-clamp(bgAcc.a,0.0,1.0))*(1.0-clamp(fgAcc.a,0.0,1.0));gl_FragColor=vec4(rgb,alpha);}", bokehBlurShader = "#define GLSLIFY 1\nuniform sampler2D u_bokehTexture;uniform vec2 u_bokehTexelSize;varying vec2 v_uv;void main(){vec4 duv=u_bokehTexelSize.xyxy*vec4(1.0,1.0,-1.0,0.0);vec4 acc;acc=texture2D(u_bokehTexture,v_uv-duv.xy);acc+=texture2D(u_bokehTexture,v_uv-duv.wy)*2.0;acc+=texture2D(u_bokehTexture,v_uv-duv.zy);acc+=texture2D(u_bokehTexture,v_uv+duv.zw)*2.0;acc+=texture2D(u_bokehTexture,v_uv)*4.0;acc+=texture2D(u_bokehTexture,v_uv+duv.xw)*2.0;acc+=texture2D(u_bokehTexture,v_uv+duv.zy);acc+=texture2D(u_bokehTexture,v_uv+duv.wy)*2.0;acc+=texture2D(u_bokehTexture,v_uv+duv.xy);gl_FragColor=acc*0.0625;}", bokehFragmentShader = "#define GLSLIFY 1\nvarying vec2 v_uv;uniform sampler2D u_texture;uniform sampler2D u_blurTexture;uniform float u_amount;void main(){vec4 cs=texture2D(u_texture,v_uv);vec4 cb=texture2D(u_blurTexture,v_uv);vec3 rgb=cs.rgb*cb.a+cb.rgb;gl_FragColor=mix(cs,vec4(rgb,cs.a),u_amount);}", Bokeh = function(e) {
    _inherits(r, PostEffect);
    var t = _createSuper(r);
    function r() {
        var e;
        _classCallCheck(this, r);
        for (var i = arguments.length, n = new Array(i), a = 0; a < i; a++)
            n[a] = arguments[a];
        return _defineProperty(_assertThisInitialized(e = t.call.apply(t, [this].concat(n))), "amount", 1),
        _defineProperty(_assertThisInitialized(e), "fNumber", .07),
        _defineProperty(_assertThisInitialized(e), "focusDistance", 5),
        _defineProperty(_assertThisInitialized(e), "useCameraFov", !1),
        _defineProperty(_assertThisInitialized(e), "focalLength", .463),
        _defineProperty(_assertThisInitialized(e), "kFilmHeight", 36),
        _defineProperty(_assertThisInitialized(e), "quality", 1),
        _defineProperty(_assertThisInitialized(e), "_prevQuality", -1),
        _defineProperty(_assertThisInitialized(e), "useFloatTexture", !1),
        _defineProperty(_assertThisInitialized(e), "_prevUseFloatTexture", null),
        _defineProperty(_assertThisInitialized(e), "useAdditionalBlur", !0),
        _defineProperty(_assertThisInitialized(e), "_halfWidth", 0),
        _defineProperty(_assertThisInitialized(e), "_halfHeight", 0),
        e
    }
    return _createClass(r, [{
        key: "init",
        value: function(e) {
            Object.assign(this, {
                sharedUniforms: {
                    u_depthTexture: {
                        value: null
                    },
                    u_texelSize: {
                        value: null
                    },
                    u_focusDistance: {
                        value: 0
                    },
                    u_fNumber: {
                        value: 0
                    },
                    u_lensCoeff: {
                        value: 0
                    },
                    u_maxCoC: {
                        value: 0
                    },
                    u_rcpMaxCoC: {
                        value: 0
                    },
                    u_rcpAspect: {
                        value: 0
                    },
                    u_cameraNear: {
                        value: 0
                    },
                    u_cameraFar: {
                        value: 0
                    },
                    u_amount: {
                        value: 0
                    },
                    u_halfTexelSize: {
                        value: new Vector2
                    }
                }
            }, e),
            _get(_getPrototypeOf(r.prototype), "init", this).call(this),
            this.rt2 = fboHelper.createRenderTarget(1, 1),
            this.rt3 = fboHelper.createRenderTarget(1, 1),
            this.cocMaterial = fboHelper.createRawShaderMaterial({
                uniforms: {
                    u_texture: {
                        value: null
                    },
                    u_hashNoise: {
                        value: 0
                    },
                    u_depthTexture: this.sharedUniforms.u_depthTexture,
                    u_texelSize: this.sharedUniforms.u_texelSize,
                    u_focusDistance: this.sharedUniforms.u_focusDistance,
                    u_lensCoeff: this.sharedUniforms.u_lensCoeff,
                    u_maxCoC: this.sharedUniforms.u_maxCoC,
                    u_rcpMaxCoC: this.sharedUniforms.u_rcpMaxCoC,
                    u_cameraNear: this.sharedUniforms.u_cameraNear,
                    u_cameraFar: this.sharedUniforms.u_cameraFar
                },
                fragmentShader: bokehCocShader
            }),
            this.simMaterial = fboHelper.createRawShaderMaterial({
                uniforms: {
                    u_cocTexture: {
                        value: null
                    },
                    u_cocTexelSize: this.sharedUniforms.u_halfTexelSize,
                    u_rcpAspect: this.sharedUniforms.u_rcpAspect,
                    u_maxCoC: this.sharedUniforms.u_maxCoC
                },
                fragmentShader: bokehSimShader
            }),
            this.blurMaterial = fboHelper.createRawShaderMaterial({
                uniforms: {
                    u_bokehTexture: {
                        value: null
                    },
                    u_bokehTexelSize: this.sharedUniforms.u_halfTexelSize
                },
                fragmentShader: bokehBlurShader
            }),
            this.material = fboHelper.createRawShaderMaterial({
                uniforms: {
                    u_texture: {
                        value: null
                    },
                    u_blurTexture: {
                        value: null
                    },
                    u_amount: this.sharedUniforms.u_amount
                },
                fragmentShader: fboHelper.precisionPrefix + bokehFragmentShader
            })
        }
    }, {
        key: "dispose",
        value: function() {
            this.rt1 && this.rt1.dispose(),
            this.rt2.dispose(),
            this.rt3.dispose()
        }
    }, {
        key: "needsRender",
        value: function() {
            return this.amount > 0
        }
    }, {
        key: "_calculateFocalLength",
        value: function(e, t) {
            return .5 * t / Math.tan(.5 * e)
        }
    }, {
        key: "_calculateMaxCoCRadius",
        value: function(e, t) {
            var r = 4 * t + 6;
            return Math.min(.05, r / e)
        }
    }, {
        key: "setPostprocessing",
        value: function(e) {
            _get(_getPrototypeOf(r.prototype), "setPostprocessing", this).call(this, e);
            var t = e.width
              , i = e.height
              , n = Math.ceil(t / 2)
              , a = Math.ceil(i / 2);
            this._halfWidth = n,
            this._halfHeight = a,
            this.rt1 && this.rt1.setSize(n, a),
            this.rt2.setSize(n, a),
            this.rt3.setSize(n, a),
            this.sharedUniforms.u_halfTexelSize.value.set(1 / n, 1 / a)
        }
    }, {
        key: "render",
        value: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
              , i = this._prevQuality !== this.quality
              , n = this._prevUseFloatTexture !== this.useFloatTexture
              , a = this.useCameraFov ? this._calculateFocalLength(e.sharedUniforms.u_cameraFovRad.value, e.camera.getFilmHeight()) : this.focalLength
              , o = this.focusDistance
              , s = this.fNumber
              , l = a * a / (s * (o - a) * this.kFilmHeight * 2)
              , u = this._calculateMaxCoCRadius(e.height, this.quality);
            this.sharedUniforms.u_amount.value = this.amount,
            this.sharedUniforms.u_texelSize.value = e.sharedUniforms.u_texelSize.value,
            this.sharedUniforms.u_depthTexture.value = e.sharedUniforms.u_sceneDepthTexture.value,
            this.sharedUniforms.u_cameraNear.value = e.sharedUniforms.u_cameraNear.value,
            this.sharedUniforms.u_cameraFar.value = e.sharedUniforms.u_cameraFar.value,
            this.sharedUniforms.u_focusDistance.value = o,
            this.sharedUniforms.u_fNumber.value = s,
            this.sharedUniforms.u_lensCoeff.value = l,
            this.sharedUniforms.u_maxCoC.value = u,
            this.sharedUniforms.u_rcpMaxCoC.value = 1 / u,
            this.sharedUniforms.u_rcpAspect.value = e.height / e.width,
            n && (this.rt1 && this.rt1.dispose(),
            this.rt1 = fboHelper.createRenderTarget(this._halfWidth, this._halfHeight, !1, this.useFloatTexture)),
            e.fromTexture.minFilter = e.fromTexture.magFilter = NearestFilter,
            n && (this.cocMaterial.defines.USE_FLOAT = this.useFloatTexture,
            this.cocMaterial.needsUpdate = !0),
            this.cocMaterial.uniforms.u_hashNoise.value = (this.cocMaterial.uniforms.u_hashNoise.value + 1.2415) % 100,
            this.cocMaterial.uniforms.u_texture.value = e.fromTexture,
            e.renderMaterial(this.cocMaterial, this.rt1),
            e.fromTexture.minFilter = e.fromTexture.magFilter = LinearFilter,
            this.simMaterial.defines.QUALITY = this.quality,
            this.simMaterial.uniforms.u_cocTexture.value = this.rt1.texture,
            i && (this.simMaterial.needsUpdate = !0),
            n && (this.simMaterial.defines.USE_FLOAT = this.useFloatTexture,
            this.simMaterial.needsUpdate = !0),
            e.renderMaterial(this.simMaterial, this.rt2),
            this.useAdditionalBlur && (this.blurMaterial.uniforms.u_bokehTexture.value = this.rt2.texture,
            e.renderMaterial(this.blurMaterial, this.rt3)),
            this.material.uniforms.u_blurTexture.value = this.useAdditionalBlur ? this.rt3.texture : this.rt2.texture,
            this._prevQuality = this.quality,
            this._prevUseFloatTexture = this.useFloatTexture,
            _get(_getPrototypeOf(r.prototype), "render", this).call(this, e, t, e.fromTexture)
        }
    }]),
    r
}(), frag$4 = "#define GLSLIFY 1\nuniform sampler2D u_texture;uniform sampler2D u_screenPaintTexture;uniform vec2 u_screenPaintTexelSize;uniform float u_amount;uniform float u_rgbShift;uniform float u_multiplier;varying vec2 v_uv;void main(){vec4 data=texture2D(u_screenPaintTexture,v_uv);float weight=(data.z+data.w)*0.5;vec2 vel=(0.5-data.xy-0.001)*2.*weight;vec4 color=vec4(texture2D(u_texture,v_uv+(vel*(u_amount))*u_screenPaintTexelSize).ra,texture2D(u_texture,v_uv+(vel*(u_amount+u_rgbShift))*u_screenPaintTexelSize).g,texture2D(u_texture,v_uv+(vel*(u_amount+u_rgbShift*2.))*u_screenPaintTexelSize).b).rbag;color.rgb=mix(color.rgb,color.rgb*u_multiplier,weight);gl_FragColor=color;}", ScreenPaintDistortion = function(e) {
    _inherits(r, PostEffect);
    var t = _createSuper(r);
    function r() {
        var e;
        _classCallCheck(this, r);
        for (var i = arguments.length, n = new Array(i), a = 0; a < i; a++)
            n[a] = arguments[a];
        return _defineProperty(_assertThisInitialized(e = t.call.apply(t, [this].concat(n))), "screenPaint", null),
        _defineProperty(_assertThisInitialized(e), "amount", 20),
        _defineProperty(_assertThisInitialized(e), "rgbShift", 1),
        _defineProperty(_assertThisInitialized(e), "multiplier", 1.25),
        e
    }
    return _createClass(r, [{
        key: "init",
        value: function(e) {
            if (Object.assign(this, e),
            _get(_getPrototypeOf(r.prototype), "init", this).call(this),
            !this.screenPaint)
                throw new Error("screenPaint is required");
            this.material = fboHelper.createRawShaderMaterial({
                uniforms: {
                    u_texture: {
                        value: null
                    },
                    u_screenPaintTexture: this.screenPaint.sharedUniforms.u_currPaintTexture,
                    u_screenPaintTexelSize: this.screenPaint.sharedUniforms.u_paintTexelSize,
                    u_amount: {
                        value: 0
                    },
                    u_rgbShift: {
                        value: 0
                    },
                    u_multiplier: {
                        value: 0
                    }
                },
                fragmentShader: frag$4
            })
        }
    }, {
        key: "needsRender",
        value: function(e) {
            return this.amount > 0
        }
    }, {
        key: "syncCamera",
        value: function(e) {
            this.needsSync = !0,
            e && (e.matrixWorldInverse.decompose(this._position, this._quaternion, this._scale),
            this.projectionViewMatrix.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
            this.projectionViewInverseMatrix.copy(this.projectionViewMatrix).invert()),
            this.prevProjectionViewMatrix.copy(this.projectionViewMatrix)
        }
    }, {
        key: "render",
        value: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            this.material.uniforms.u_amount.value = this.amount,
            this.material.uniforms.u_rgbShift.value = this.rgbShift,
            this.material.uniforms.u_multiplier.value = this.multiplier,
            _get(_getPrototypeOf(r.prototype), "render", this).call(this, e, t)
        }
    }]),
    r
}(), ShaderHelper = function() {
    function e() {
        _classCallCheck(this, e)
    }
    return _createClass(e, [{
        key: "glslifyStrip",
        value: function(e) {
            return e.replace(/#define\sGLSLIFY\s./, "")
        }
    }, {
        key: "addChunk",
        value: function(e, t) {
            ShaderChunk[e] = this.glslifyStrip(t)
        }
    }, {
        key: "_wrapInclude",
        value: function(e) {
            return "#include <" + e + ">"
        }
    }, {
        key: "insertBefore",
        value: function(e, t, r, i) {
            var n = i ? this._wrapInclude(t) : t;
            return e.replace(t, this.glslifyStrip(r) + "\n" + n)
        }
    }, {
        key: "insertAfter",
        value: function(e, t, r, i) {
            var n = i ? this._wrapInclude(t) : t;
            return e.replace(n, n + "\n" + this.glslifyStrip(r) + "\n")
        }
    }, {
        key: "replace",
        value: function(e, t, r, i) {
            var n = i ? this._wrapInclude(t) : t;
            return e.replace(n, "\n" + this.glslifyStrip(r) + "\n")
        }
    }]),
    e
}(), shaderHelper = new ShaderHelper, getBlueNoiseShader = "#define GLSLIFY 1\nuniform sampler2D u_blueNoiseTexture;uniform vec2 u_blueNoiseTexelSize;uniform vec2 u_blueNoiseCoordOffset;vec3 getBlueNoise(vec2 coord){return texture2D(u_blueNoiseTexture,coord*u_blueNoiseTexelSize+u_blueNoiseCoordOffset).rgb;}vec3 getStaticBlueNoise(vec2 coord){return texture2D(u_blueNoiseTexture,coord*u_blueNoiseTexelSize).rgb;}", BlueNoise = function() {
    function e() {
        _classCallCheck(this, e),
        _defineProperty(this, "sharedUniforms", {
            u_blueNoiseTexture: {
                value: null
            },
            u_blueNoiseLinearTexture: {
                value: null
            },
            u_blueNoiseTexelSize: {
                value: null
            },
            u_blueNoiseCoordOffset: {
                value: new Vector2
            }
        }),
        _defineProperty(this, "TEXTURE_SIZE", 128)
    }
    return _createClass(e, [{
        key: "preInit",
        value: function() {
            var e = new Texture;
            e.generateMipmaps = !1,
            e.minFilter = e.magFilter = LinearFilter,
            e.wrapS = e.wrapT = RepeatWrapping;
            var t = new Texture(properties.loader.add(settings.TEXTURE_PATH + "LDR_RGB1_0.png", {
                weight: 55,
                onLoad: function() {
                    t.needsUpdate = !0,
                    e.needsUpdate = !0
                }
            }).content);
            e.image = t.image,
            t.generateMipmaps = !1,
            t.minFilter = t.magFilter = NearestFilter,
            t.wrapS = t.wrapT = RepeatWrapping,
            this.sharedUniforms.u_blueNoiseTexture.value = t,
            this.sharedUniforms.u_blueNoiseLinearTexture.value = e,
            this.sharedUniforms.u_blueNoiseTexelSize.value = new Vector2(1 / this.TEXTURE_SIZE,1 / this.TEXTURE_SIZE),
            shaderHelper.addChunk("getBlueNoise", getBlueNoiseShader)
        }
    }, {
        key: "update",
        value: function(e) {
            this.sharedUniforms.u_blueNoiseCoordOffset.value.set(Math.random(), Math.random())
        }
    }]),
    e
}(), blueNoise = new BlueNoise, Ease = function() {
    function e() {
        _classCallCheck(this, e)
    }
    return _createClass(e, [{
        key: "quadIn",
        value: function(e) {
            return e * e
        }
    }, {
        key: "quadOut",
        value: function(e) {
            return e * (2 - e)
        }
    }, {
        key: "quadInOut",
        value: function(e) {
            return (e *= 2) < 1 ? .5 * e * e : -.5 * (--e * (e - 2) - 1)
        }
    }, {
        key: "cubicIn",
        value: function(e) {
            return e * e * e
        }
    }, {
        key: "cubicOut",
        value: function(e) {
            return --e * e * e + 1
        }
    }, {
        key: "cubicInOut",
        value: function(e) {
            return (e *= 2) < 1 ? .5 * e * e * e : .5 * ((e -= 2) * e * e + 2)
        }
    }, {
        key: "quartIn",
        value: function(e) {
            return e * e * e * e
        }
    }, {
        key: "quartOut",
        value: function(e) {
            return 1 - --e * e * e * e
        }
    }, {
        key: "quartInOut",
        value: function(e) {
            return (e *= 2) < 1 ? .5 * e * e * e * e : -.5 * ((e -= 2) * e * e * e - 2)
        }
    }, {
        key: "quintIn",
        value: function(e) {
            return e * e * e * e * e
        }
    }, {
        key: "quintOut",
        value: function(e) {
            return --e * e * e * e * e + 1
        }
    }, {
        key: "quintInOut",
        value: function(e) {
            return (e *= 2) < 1 ? .5 * e * e * e * e * e : .5 * ((e -= 2) * e * e * e * e + 2)
        }
    }, {
        key: "sineIn",
        value: function(e) {
            return 1 - Math.cos(e * Math.PI / 2)
        }
    }, {
        key: "sineOut",
        value: function(e) {
            return Math.sin(e * Math.PI / 2)
        }
    }, {
        key: "sineInOut",
        value: function(e) {
            return .5 * (1 - Math.cos(Math.PI * e))
        }
    }, {
        key: "expoIn",
        value: function(e) {
            return 0 === e ? 0 : Math.pow(1024, e - 1)
        }
    }, {
        key: "expoOut",
        value: function(e) {
            return 1 === e ? 1 : 1 - Math.pow(2, -10 * e)
        }
    }, {
        key: "expoInOut",
        value: function(e) {
            return 0 === e ? 0 : 1 === e ? 1 : (e *= 2) < 1 ? .5 * Math.pow(1024, e - 1) : .5 * (2 - Math.pow(2, -10 * (e - 1)))
        }
    }, {
        key: "circIn",
        value: function(e) {
            return 1 - Math.sqrt(1 - e * e)
        }
    }, {
        key: "circOut",
        value: function(e) {
            return Math.sqrt(1 - --e * e)
        }
    }, {
        key: "circInOut",
        value: function(e) {
            return (e *= 2) < 1 ? -.5 * (Math.sqrt(1 - e * e) - 1) : .5 * (Math.sqrt(1 - (e -= 2) * e) + 1)
        }
    }, {
        key: "elasticIn",
        value: function(e) {
            var t, r = .1;
            return 0 === e ? 0 : 1 === e ? 1 : (!r || r < 1 ? (r = 1,
            t = .1) : t = .4 * Math.asin(1 / r) / (2 * Math.PI),
            -r * Math.pow(2, 10 * (e -= 1)) * Math.sin(2 * (e - t) * Math.PI / .4))
        }
    }, {
        key: "elasticOut",
        value: function(e) {
            var t, r = .1;
            return 0 === e ? 0 : 1 === e ? 1 : (!r || r < 1 ? (r = 1,
            t = .1) : t = .4 * Math.asin(1 / r) / (2 * Math.PI),
            r * Math.pow(2, -10 * e) * Math.sin(2 * (e - t) * Math.PI / .4) + 1)
        }
    }, {
        key: "elasticInOut",
        value: function(e) {
            var t, r = .1;
            return 0 === e ? 0 : 1 === e ? 1 : (!r || r < 1 ? (r = 1,
            t = .1) : t = .4 * Math.asin(1 / r) / (2 * Math.PI),
            (e *= 2) < 1 ? -.5 * r * Math.pow(2, 10 * (e -= 1)) * Math.sin(2 * (e - t) * Math.PI / .4) : r * Math.pow(2, -10 * (e -= 1)) * Math.sin(2 * (e - t) * Math.PI / .4) * .5 + 1)
        }
    }, {
        key: "backIn",
        value: function(e) {
            var t = 1.70158;
            return e * e * ((t + 1) * e - t)
        }
    }, {
        key: "backOut",
        value: function(e) {
            var t = 1.70158;
            return --e * e * ((t + 1) * e + t) + 1
        }
    }, {
        key: "backInOut",
        value: function(e) {
            var t = 2.5949095;
            return (e *= 2) < 1 ? .5 * e * e * ((t + 1) * e - t) : .5 * ((e -= 2) * e * ((t + 1) * e + t) + 2)
        }
    }, {
        key: "bounceIn",
        value: function(e) {
            return 1 - this.bounceOut(1 - e)
        }
    }, {
        key: "bounceOut",
        value: function(e) {
            return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375
        }
    }, {
        key: "bounceInOut",
        value: function(e) {
            return e < .5 ? .5 * this.bounceIn(2 * e) : .5 * this.bounceOut(2 * e - 1) + .5
        }
    }, {
        key: "cubicBezier",
        value: function(e, t, r, i, n) {
            if (e <= 0)
                return 0;
            if (e >= 1)
                return 1;
            if (t === r && i === n)
                return e;
            var a, o, s, l, u = function(e, t, r, i) {
                return 1 / (3 * t * e * e + 2 * r * e + i)
            }, c = 1 - 3 * i + 3 * t - 0, h = 3 * i - 6 * t + 0, d = 3 * t - 0, p = 1 - 3 * n + 3 * r - 0, f = 3 * n - 6 * r + 0, m = 3 * r - 0, v = e;
            for (a = 0; a < 100; a++)
                o = c * ((l = v) * l * l) + h * (l * l) + d * l + 0,
                (s = u(v, c, h, d)) === 1 / 0 && (s = e),
                v -= (o - e) * s,
                v = Math.min(Math.max(v, 0), 1);
            return function(e, t, r, i, n) {
                var a = e * e;
                return t * (a * e) + r * a + i * e + 0
            }(v, p, f, m)
        }
    }]),
    e
}(), ease = new Ease, fragmentShader = "#define GLSLIFY 1\nvarying vec2 v_uv;uniform sampler2D u_texture;uniform vec3 u_bgColor;uniform float u_opacity;uniform float u_vignetteFrom;uniform float u_vignetteTo;uniform vec2 u_vignetteAspect;uniform vec3 u_vignetteColor;uniform float u_saturation;uniform float u_contrast;uniform float u_brightness;uniform vec3 u_tintColor;uniform float u_tintOpacity;uniform float u_ditherSeed;float hash13(vec3 p3){p3=fract(p3*.1031);p3+=dot(p3,p3.yzx+33.33);return fract((p3.x+p3.y)*p3.z);}vec3 screen(vec3 cb,vec3 cs){return cb+cs-(cb*cs);}vec3 colorDodge(vec3 cb,vec3 cs){return mix(min(vec3(1.0),cb/(1.0-cs)),vec3(1.0),step(vec3(1.0),cs));}void main(){vec2 uv=v_uv;vec3 color=texture2D(u_texture,uv).rgb;float luma=dot(color,vec3(0.299,0.587,0.114));color=mix(vec3(luma),color,1.0+u_saturation);color=0.5+(1.0+u_contrast)*(color-0.5);color+=u_brightness;color=mix(color,screen(colorDodge(color,u_tintColor),u_tintColor),u_tintOpacity);float d=length((uv-0.5)*u_vignetteAspect)*2.0;color=mix(color,u_vignetteColor,smoothstep(u_vignetteFrom,u_vignetteTo,d));gl_FragColor=vec4(mix(u_bgColor,color,u_opacity)+hash13(vec3(gl_FragCoord.xy,u_ditherSeed))/255.0,1.0);}", transitionFragmentShader = "#define GLSLIFY 1\nvarying vec2 v_uv;uniform sampler2D u_texture;uniform sampler2D u_cacheTexture;uniform vec2 u_aspect;uniform float u_transitionRatio;void main(){vec2 uv=v_uv-0.5;float transitionRatioInverse=1.0-u_transitionRatio;uv*=u_aspect;float d=length(uv);float oriDist=d;float distortedDist=d*3.1415926*2.5*transitionRatioInverse;float distortion=cos(distortedDist*distortedDist);uv*=mix(1.0,distortion*distortion,u_transitionRatio);uv/=u_aspect;vec4 color=texture2D(u_texture,uv+0.5);vec4 sceneColor=texture2D(u_cacheTexture,uv*(1.0-u_transitionRatio*0.75)+0.5);float blend=smoothstep(0.4,0.6,transitionRatioInverse);color=mix(color,sceneColor,blend);gl_FragColor=color;}", Final = function(e) {
    _inherits(r, PostEffect);
    var t = _createSuper(r);
    function r() {
        var e;
        _classCallCheck(this, r);
        for (var i = arguments.length, n = new Array(i), a = 0; a < i; a++)
            n[a] = arguments[a];
        return _defineProperty(_assertThisInitialized(e = t.call.apply(t, [this].concat(n))), "vignetteFrom", .6),
        _defineProperty(_assertThisInitialized(e), "vignetteTo", 1.6),
        _defineProperty(_assertThisInitialized(e), "vignetteAspect", new Vector2),
        _defineProperty(_assertThisInitialized(e), "vignetteColor", new Color),
        _defineProperty(_assertThisInitialized(e), "saturation", 1),
        _defineProperty(_assertThisInitialized(e), "contrast", 0),
        _defineProperty(_assertThisInitialized(e), "brightness", 1),
        _defineProperty(_assertThisInitialized(e), "tintColor", new Color),
        _defineProperty(_assertThisInitialized(e), "tintOpacity", 1),
        _defineProperty(_assertThisInitialized(e), "bgColor", new Color),
        _defineProperty(_assertThisInitialized(e), "opacity", 1),
        _defineProperty(_assertThisInitialized(e), "transitionRatio", 1),
        _defineProperty(_assertThisInitialized(e), "cacheRenderTarget", null),
        e
    }
    return _createClass(r, [{
        key: "init",
        value: function(e) {
            Object.assign(this, e),
            _get(_getPrototypeOf(r.prototype), "init", this).call(this),
            this.material = fboHelper.createRawShaderMaterial({
                uniforms: {
                    u_texture: {
                        value: null
                    },
                    u_vignetteFrom: {
                        value: 0
                    },
                    u_vignetteTo: {
                        value: 0
                    },
                    u_vignetteAspect: {
                        value: this.vignetteAspect
                    },
                    u_vignetteColor: {
                        value: this.vignetteColor
                    },
                    u_saturation: {
                        value: 0
                    },
                    u_contrast: {
                        value: 0
                    },
                    u_brightness: {
                        value: 0
                    },
                    u_tintColor: {
                        value: this.tintColor
                    },
                    u_tintOpacity: {
                        value: 0
                    },
                    u_bgColor: {
                        value: this.bgColor
                    },
                    u_opacity: {
                        value: 0
                    },
                    u_ditherSeed: {
                        value: 0
                    }
                },
                fragmentShader
            }),
            this.cacheRenderTarget = fboHelper.createRenderTarget(1, 1),
            this.transitionMaterial = fboHelper.createRawShaderMaterial({
                uniforms: Object.assign({
                    u_texture: {
                        value: null
                    },
                    u_cacheTexture: {
                        value: this.cacheRenderTarget.texture
                    },
                    u_transitionRatio: {
                        value: 0
                    },
                    u_aspect: {
                        value: new Vector2
                    }
                }, blueNoise.sharedUniforms),
                fragmentShader: transitionFragmentShader
            })
        }
    }, {
        key: "startTransition",
        value: function(e) {
            var t = e.width
              , r = e.height;
            this.cacheRenderTarget.setSize(t, r),
            fboHelper.copy(e.fromRenderTarget.texture, this.cacheRenderTarget),
            e.swap(),
            this.transitionRatio = 0
        }
    }, {
        key: "render",
        value: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
              , r = e.width
              , i = e.height
              , n = this.material.uniforms;
            n.u_vignetteFrom.value = this.vignetteFrom,
            n.u_vignetteTo.value = this.vignetteTo;
            var a = i / Math.sqrt(r * r + i * i);
            this.vignetteAspect.set(r / i * a, a),
            n.u_saturation.value = this.saturation - 1,
            n.u_contrast.value = this.contrast,
            n.u_brightness.value = this.brightness - 1,
            n.u_tintOpacity.value = this.tintOpacity,
            n.u_opacity.value = this.opacity,
            n.u_ditherSeed.value = 1e3 * Math.random();
            var o = this.transitionRatio
              , s = o < 1;
            this.material.uniforms.u_texture.value = e.fromTexture,
            s ? (e.renderMaterial(this.material, e.toRenderTarget),
            e.swap(),
            this.transitionMaterial.uniforms.u_texture.value = e.fromTexture,
            this.transitionMaterial.uniforms.u_transitionRatio.value = o,
            this.transitionMaterial.uniforms.u_aspect.value.copy(this.vignetteAspect),
            e.renderMaterial(this.transitionMaterial, t ? null : e.toRenderTarget)) : (e.renderMaterial(this.material, t ? null : e.toRenderTarget),
            e.swap())
        }
    }]),
    r
}(), easuFrag = "#define GLSLIFY 1\nuniform sampler2D u_texture;uniform vec2 u_inResolution;uniform vec2 u_outResolution;vec3 FsrEasuCF(vec2 p){return texture2D(u_texture,p).rgb;}void FsrEasuCon(out vec4 con0,out vec4 con1,out vec4 con2,out vec4 con3,vec2 inputViewportInPixels,vec2 inputSizeInPixels,vec2 outputSizeInPixels){con0=vec4(inputViewportInPixels.x/outputSizeInPixels.x,inputViewportInPixels.y/outputSizeInPixels.y,.5*inputViewportInPixels.x/outputSizeInPixels.x-.5,.5*inputViewportInPixels.y/outputSizeInPixels.y-.5);con1=vec4(1,1,1,-1)/inputSizeInPixels.xyxy;con2=vec4(-1,2,1,2)/inputSizeInPixels.xyxy;con3=vec4(0,4,0,0)/inputSizeInPixels.xyxy;}void FsrEasuTapF(inout vec3 aC,inout float aW,vec2 off,vec2 dir,vec2 len,float lob,float clp,vec3 c){vec2 v=vec2(dot(off,dir),dot(off,vec2(-dir.y,dir.x)));v*=len;float d2=min(dot(v,v),clp);float wB=.4*d2-1.;float wA=lob*d2-1.;wB*=wB;wA*=wA;wB=1.5625*wB-.5625;float w=wB*wA;aC+=c*w;aW+=w;}void FsrEasuSetF(inout vec2 dir,inout float len,float w,float lA,float lB,float lC,float lD,float lE){float lenX=max(abs(lD-lC),abs(lC-lB));float dirX=lD-lB;dir.x+=dirX*w;lenX=clamp(abs(dirX)/lenX,0.,1.);lenX*=lenX;len+=lenX*w;float lenY=max(abs(lE-lC),abs(lC-lA));float dirY=lE-lA;dir.y+=dirY*w;lenY=clamp(abs(dirY)/lenY,0.,1.);lenY*=lenY;len+=lenY*w;}void FsrEasuF(out vec3 pix,vec2 ip,vec4 con0,vec4 con1,vec4 con2,vec4 con3){vec2 pp=ip*con0.xy+con0.zw;vec2 fp=floor(pp);pp-=fp;vec2 p0=fp*con1.xy+con1.zw;vec2 p1=p0+con2.xy;vec2 p2=p0+con2.zw;vec2 p3=p0+con3.xy;vec4 off=vec4(-.5,.5,-.5,.5)*con1.xxyy;vec3 bC=FsrEasuCF(p0+off.xw);float bL=bC.g+0.5*(bC.r+bC.b);vec3 cC=FsrEasuCF(p0+off.yw);float cL=cC.g+0.5*(cC.r+cC.b);vec3 iC=FsrEasuCF(p1+off.xw);float iL=iC.g+0.5*(iC.r+iC.b);vec3 jC=FsrEasuCF(p1+off.yw);float jL=jC.g+0.5*(jC.r+jC.b);vec3 fC=FsrEasuCF(p1+off.yz);float fL=fC.g+0.5*(fC.r+fC.b);vec3 eC=FsrEasuCF(p1+off.xz);float eL=eC.g+0.5*(eC.r+eC.b);vec3 kC=FsrEasuCF(p2+off.xw);float kL=kC.g+0.5*(kC.r+kC.b);vec3 lC=FsrEasuCF(p2+off.yw);float lL=lC.g+0.5*(lC.r+lC.b);vec3 hC=FsrEasuCF(p2+off.yz);float hL=hC.g+0.5*(hC.r+hC.b);vec3 gC=FsrEasuCF(p2+off.xz);float gL=gC.g+0.5*(gC.r+gC.b);vec3 oC=FsrEasuCF(p3+off.yz);float oL=oC.g+0.5*(oC.r+oC.b);vec3 nC=FsrEasuCF(p3+off.xz);float nL=nC.g+0.5*(nC.r+nC.b);vec2 dir=vec2(0.);float len=0.;FsrEasuSetF(dir,len,(1.-pp.x)*(1.-pp.y),bL,eL,fL,gL,jL);FsrEasuSetF(dir,len,pp.x*(1.-pp.y),cL,fL,gL,hL,kL);FsrEasuSetF(dir,len,(1.-pp.x)*pp.y,fL,iL,jL,kL,nL);FsrEasuSetF(dir,len,pp.x*pp.y,gL,jL,kL,lL,oL);vec2 dir2=dir*dir;float dirR=dir2.x+dir2.y;bool zro=dirR<(1./32768.);dirR=inversesqrt(dirR);dirR=zro ? 1. : dirR;dir.x=zro ? 1. : dir.x;dir*=vec2(dirR);len=len*.5;len*=len;float stretch=dot(dir,dir)/(max(abs(dir.x),abs(dir.y)));vec2 len2=vec2(1.+(stretch-1.0)*len,1.-.5*len);float lob=.5-.29*len;float clp=1./lob;vec3 min4=min(min(fC,gC),min(jC,kC));vec3 max4=max(max(fC,gC),max(jC,kC));vec3 aC=vec3(0);float aW=0.;FsrEasuTapF(aC,aW,vec2(0.,-1.)-pp,dir,len2,lob,clp,bC);FsrEasuTapF(aC,aW,vec2(1.,-1.)-pp,dir,len2,lob,clp,cC);FsrEasuTapF(aC,aW,vec2(-1.,1.)-pp,dir,len2,lob,clp,iC);FsrEasuTapF(aC,aW,vec2(0.,1.)-pp,dir,len2,lob,clp,jC);FsrEasuTapF(aC,aW,vec2(0.,0.)-pp,dir,len2,lob,clp,fC);FsrEasuTapF(aC,aW,vec2(-1.,0.)-pp,dir,len2,lob,clp,eC);FsrEasuTapF(aC,aW,vec2(1.,1.)-pp,dir,len2,lob,clp,kC);FsrEasuTapF(aC,aW,vec2(2.,1.)-pp,dir,len2,lob,clp,lC);FsrEasuTapF(aC,aW,vec2(2.,0.)-pp,dir,len2,lob,clp,hC);FsrEasuTapF(aC,aW,vec2(1.,0.)-pp,dir,len2,lob,clp,gC);FsrEasuTapF(aC,aW,vec2(1.,2.)-pp,dir,len2,lob,clp,oC);FsrEasuTapF(aC,aW,vec2(0.,2.)-pp,dir,len2,lob,clp,nC);pix=min(max4,max(min4,aC/aW));}void main(){vec3 c;vec4 con0,con1,con2,con3;FsrEasuCon(con0,con1,con2,con3,u_inResolution,u_inResolution,u_outResolution);FsrEasuF(c,gl_FragCoord.xy,con0,con1,con2,con3);gl_FragColor=vec4(c.xyz,1);}", frag$3 = "#define GLSLIFY 1\nuniform sampler2D u_texture;uniform vec2 u_outResolution;uniform float u_sharpness;\n#define FSR_RCAS_LIMIT (0.25-(1.0/16.0))\nvec4 FsrRcasLoadF(vec2 p);void FsrRcasCon(out float con,float sharpness){con=exp2(-sharpness);}vec3 FsrRcasF(vec2 ip,float con){vec2 sp=vec2(ip);vec3 b=FsrRcasLoadF(sp+vec2(0,-1)).rgb;vec3 d=FsrRcasLoadF(sp+vec2(-1,0)).rgb;vec3 e=FsrRcasLoadF(sp).rgb;vec3 f=FsrRcasLoadF(sp+vec2(1,0)).rgb;vec3 h=FsrRcasLoadF(sp+vec2(0,1)).rgb;float bL=b.g+.5*(b.b+b.r);float dL=d.g+.5*(d.b+d.r);float eL=e.g+.5*(e.b+e.r);float fL=f.g+.5*(f.b+f.r);float hL=h.g+.5*(h.b+h.r);float nz=.25*(bL+dL+fL+hL)-eL;nz=clamp(abs(nz)/(max(max(bL,dL),max(eL,max(fL,hL)))-min(min(bL,dL),min(eL,min(fL,hL)))),0.,1.);nz=1.-.5*nz;vec3 mn4=min(b,min(f,h));vec3 mx4=max(b,max(f,h));vec2 peakC=vec2(1.,-4.);vec3 hitMin=mn4/(4.*mx4);vec3 hitMax=(peakC.x-mx4)/(4.*mn4+peakC.y);vec3 lobeRGB=max(-hitMin,hitMax);float lobe=max(-FSR_RCAS_LIMIT,min(max(lobeRGB.r,max(lobeRGB.g,lobeRGB.b)),0.))*con;\n#ifdef FSR_RCAS_DENOISE\nlobe*=nz;\n#endif\nreturn(lobe*(b+d+h+f)+e)/(4.*lobe+1.);}vec4 FsrRcasLoadF(vec2 p){return texture2D(u_texture,p/u_outResolution.xy);}void main(){vec2 uv=gl_FragCoord.xy/u_outResolution.xy;float con;FsrRcasCon(con,u_sharpness);vec3 col=FsrRcasF(gl_FragCoord.xy,con);gl_FragColor=vec4(col,1.);}", Fsr$1 = function() {
    function e() {
        _classCallCheck(this, e),
        _defineProperty(this, "sharpness", 1),
        _defineProperty(this, "_easuMaterial", void 0),
        _defineProperty(this, "_material", void 0),
        _defineProperty(this, "_inResolution", new Vector2),
        _defineProperty(this, "_outResolution", new Vector2),
        _defineProperty(this, "_cacheRenderTarget", null),
        this._cacheRenderTarget = fboHelper.createRenderTarget(1, 1),
        this._easuMaterial = fboHelper.createRawShaderMaterial({
            uniforms: {
                u_texture: {
                    value: null
                },
                u_inResolution: {
                    value: this._inResolution
                },
                u_outResolution: {
                    value: this._outResolution
                }
            },
            fragmentShader: easuFrag
        }),
        this._material = fboHelper.createRawShaderMaterial({
            uniforms: {
                u_texture: {
                    value: this._cacheRenderTarget.texture
                },
                u_outResolution: this._easuMaterial.uniforms.u_outResolution,
                u_sharpness: {
                    value: 0
                }
            },
            fragmentShader: frag$3
        })
    }
    return _createClass(e, [{
        key: "render",
        value: function(e, t) {
            var r, i, n = e.image.width, a = e.image.height;
            this._material.uniforms.u_sharpness.value = this.sharpness,
            this._inResolution.width === n && this._inResolution.height === a || this._inResolution.set(n, a),
            t ? (r = t.width,
            i = t.height) : (r = fboHelper.renderer.domElement.width,
            i = fboHelper.renderer.domElement.height),
            this._outResolution.width === r && this._outResolution.height === i || (this._outResolution.set(r, i),
            this._cacheRenderTarget.setSize(r, i)),
            this._easuMaterial.uniforms.u_texture.value = e,
            fboHelper.render(this._easuMaterial, this._cacheRenderTarget),
            t || (fboHelper.renderer.setRenderTarget(null),
            fboHelper.renderer.setViewport(0, 0, this._outResolution.x, this._outResolution.y)),
            fboHelper.render(this._material, t)
        }
    }]),
    e
}(), Fsr = function(e) {
    _inherits(r, PostEffect);
    var t = _createSuper(r);
    function r() {
        var e;
        _classCallCheck(this, r);
        for (var i = arguments.length, n = new Array(i), a = 0; a < i; a++)
            n[a] = arguments[a];
        return _defineProperty(_assertThisInitialized(e = t.call.apply(t, [this].concat(n))), "sharpness", 1),
        _defineProperty(_assertThisInitialized(e), "fsr", void 0),
        e
    }
    return _createClass(r, [{
        key: "init",
        value: function(e) {
            Object.assign(this, e),
            _get(_getPrototypeOf(r.prototype), "init", this).call(this),
            this.fsr = new Fsr$1
        }
    }, {
        key: "render",
        value: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            this.fsr.sharpness = this.sharpness,
            this.fsr.render(e.fromTexture, t ? null : e.toRenderTarget),
            e.swap()
        }
    }]),
    r
}(), channelMixerFrag = "#define GLSLIFY 1\nuniform sampler2D u_texture;uniform vec4 u_channelMixerR;uniform vec4 u_channelMixerG;uniform vec4 u_channelMixerB;uniform vec4 u_channelMixerA;varying vec2 v_uv;void main(){vec4 color=texture2D(u_texture,v_uv);gl_FragColor=vec4(dot(color,u_channelMixerR),dot(color,u_channelMixerG),dot(color,u_channelMixerB),dot(color,u_channelMixerA));}", TextureHelper = function() {
    function e() {
        _classCallCheck(this, e),
        _defineProperty(this, "blackTexture", void 0),
        _defineProperty(this, "whiteTexture", void 0),
        _defineProperty(this, "transparentTexture", void 0),
        _defineProperty(this, "channelMixerMaterial", void 0)
    }
    return _createClass(e, [{
        key: "init",
        value: function() {
            this.blackTexture = this._createPixelTexture([0, 0, 0, 255]),
            this.whiteTexture = this._createPixelTexture([255, 255, 255, 255]),
            this.transparentTexture = this._createPixelTexture([0, 0, 0, 0])
        }
    }, {
        key: "_createPixelTexture",
        value: function(e) {
            return fboHelper.createDataTexture(new Uint8Array(e), 1, 1, !1, !0)
        }
    }, {
        key: "mixChannels",
        value: function(e, t) {
            var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : -1
              , i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : -1
              , n = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : -1
              , a = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : -1;
            this.channelMixerMaterial || (this.channelMixerMaterial = new RawShaderMaterial({
                uniforms: {
                    u_texture: {
                        value: null
                    },
                    u_channelMixerR: {
                        value: new Vector4
                    },
                    u_channelMixerG: {
                        value: new Vector4
                    },
                    u_channelMixerB: {
                        value: new Vector4
                    },
                    u_channelMixerA: {
                        value: new Vector4
                    }
                },
                vertexShader: fboHelper.vertexShader,
                fragmentShader: fboHelper.precisionPrefix + channelMixerFrag,
                blending: CustomBlending,
                blendEquation: AddEquation,
                blendDst: OneFactor,
                blendSrc: OneFactor,
                blendEquationAlpha: AddEquation,
                blendDstAlpha: OneFactor,
                blendSrcAlpha: OneFactor
            })),
            this.channelMixerMaterial.uniforms.u_texture.value = e,
            this.channelMixerMaterial.uniforms.u_channelMixerR.value.set(+(r % 4 == 0), +(r % 4 == 1), +(r % 4 == 2), +(r % 4 == 3)).multiplyScalar(r < 0 ? 0 : 1),
            this.channelMixerMaterial.uniforms.u_channelMixerG.value.set(+(i % 4 == 0), +(i % 4 == 1), +(i % 4 == 2), +(i % 4 == 3)).multiplyScalar(i < 0 ? 0 : 1),
            this.channelMixerMaterial.uniforms.u_channelMixerB.value.set(+(n % 4 == 0), +(n % 4 == 1), +(n % 4 == 2), +(n % 4 == 3)).multiplyScalar(n < 0 ? 0 : 1),
            this.channelMixerMaterial.uniforms.u_channelMixerA.value.set(+(a % 4 == 0), +(a % 4 == 1), +(a % 4 == 2), +(a % 4 == 3)).multiplyScalar(a < 0 ? 0 : 1);
            var o = fboHelper.getColorState();
            fboHelper.renderer.autoClear = !1,
            fboHelper.render(this.channelMixerMaterial, t),
            fboHelper.setColorState(o)
        }
    }]),
    e
}(), textureHelper = new TextureHelper, XHRItem = properties.loader.ITEM_CLASSES.xhr, BufItem = function(e) {
    _inherits(r, XHRItem);
    var t = _createSuper(r);
    function r(e, i) {
        return _classCallCheck(this, r),
        t.call(this, e, _objectSpread(_objectSpread({}, i), {}, {
            responseType: "arraybuffer"
        }))
    }
    return _createClass(r, [{
        key: "retrieve",
        value: function() {
            return !1
        }
    }, {
        key: "_onLoad",
        value: function() {
            if (!this.content) {
                for (var e = this.xmlhttp.response, t = new Uint32Array(e,0,1)[0], i = JSON.parse(String.fromCharCode.apply(null, new Uint8Array(e,4,t))), n = i.vertexCount, a = i.indexCount, o = 4 + t, s = new BufferGeometry, l = i.attributes, u = !1, c = {}, h = 0, d = l.length; h < d; h++) {
                    var p = l[h]
                      , f = p.id
                      , m = "indices" === f ? a : n
                      , v = p.componentSize
                      , g = window[p.storageType]
                      , _ = new g(e,o,m * v)
                      , y = g.BYTES_PER_ELEMENT
                      , x = void 0;
                    if (p.needsPack) {
                        var b = p.packedComponents
                          , S = b.length
                          , w = 1 << 8 * y
                          , M = 0 === p.storageType.indexOf("Int") ? .5 * w : 0
                          , T = 1 / w;
                        x = new Float32Array(m * v);
                        for (var C = 0, E = 0; C < m; C++)
                            for (var P = 0; P < S; P++) {
                                var A = b[P];
                                x[E] = (_[E] + M) * T * A.delta + A.from,
                                E++
                            }
                    } else
                        c[f] = o,
                        x = _;
                    "normal" === f && (u = !0),
                    "indices" === f ? s.setIndex(new BufferAttribute(x,1)) : s.setAttribute(f, new BufferAttribute(x,v)),
                    o += m * v * y
                }
                var k = i.meshType
                  , L = [];
                if (i.sceneData) {
                    for (var R = i.sceneData, D = new Object3D, I = [], O = "Mesh" === k ? 3 : "LineSegments" === k ? 2 : 1, N = 0, F = R.length; N < F; N++) {
                        var B = R[N]
                          , z = void 0;
                        if (0 == B.vertexCount)
                            z = new Object3D;
                        else {
                            var U = new BufferGeometry
                              , V = s.index
                              , G = V.array
                              , H = G.constructor
                              , W = H.BYTES_PER_ELEMENT;
                            U.setIndex(new BufferAttribute(new G.constructor(G.buffer,B.faceIndex * V.itemSize * W * O + (c.indices || 0),B.faceCount * V.itemSize * O),V.itemSize));
                            for (var $ = 0, j = U.index.array.length; $ < j; $++)
                                U.index.array[$] -= B.vertexIndex;
                            for (var q in s.attributes)
                                W = (H = (G = (V = s.attributes[q]).array).constructor).BYTES_PER_ELEMENT,
                                U.setAttribute(q, new BufferAttribute(new G.constructor(G.buffer,B.vertexIndex * V.itemSize * W + (c[q] || 0),B.vertexCount * V.itemSize),V.itemSize));
                            z = "Mesh" === k ? new Mesh(U,new MeshNormalMaterial({
                                flatShading: !u
                            })) : "LineSegments" === k ? new LineSegments(U,new LineBasicMaterial) : new Points(U,new PointsMaterial({
                                sizeAttenuation: !1,
                                size: 2
                            })),
                            I.push(z)
                        }
                        B.parentIndex > -1 ? L[B.parentIndex].add(z) : D.add(z),
                        z.position.fromArray(B.position),
                        z.quaternion.fromArray(B.quaternion),
                        z.scale.fromArray(B.scale),
                        z.name = B.name,
                        z.userData.material = B.material,
                        L[N] = z
                    }
                    s.userData.meshList = I,
                    s.userData.sceneObject = D
                }
                this.content = s
            }
            this.xmlhttp = void 0,
            _get(_getPrototypeOf(r.prototype), "_onLoad", this).call(this, this)
        }
    }]),
    r
}();
BufItem.type = "buf",
BufItem.extensions = ["buf"],
BufItem.responseType = "arraybuffer";
var ImageItem = properties.loader.ITEM_CLASSES.image
  , TextureItem = function(e) {
    _inherits(r, ImageItem);
    var t = _createSuper(r);
    function r(e, i) {
        var n;
        _classCallCheck(this, r);
        var a = i.content || new Texture(new Image);
        switch (i.content = a.image,
        a.minFilter = i.minFilter || LinearMipMapLinearFilter,
        a.minFilter) {
        case NearestMipMapNearestFilter:
        case NearestMipMapLinearFilter:
        case LinearMipMapNearestFilter:
        case LinearMipMapLinearFilter:
            a.generateMipmaps = !0,
            a.anisotropy = i.anisotropy || properties.renderer.capabilities.getMaxAnisotropy();
            break;
        default:
            a.generateMipmaps = !1
        }
        return a.flipY = void 0 === i.flipY || i.flipY,
        i.wrap ? a.wrapS = a.wrapT = i.wrap : (i.wrapS && (a.wrapS = i.wrapS),
        i.wrapT && (a.wrapT = i.wrapT)),
        (n = t.call(this, e, i)).content = a,
        n
    }
    return _createClass(r, [{
        key: "retrieve",
        value: function() {
            return !1
        }
    }, {
        key: "load",
        value: function() {
            this.isStartLoaded = !0;
            var e = this.content.image;
            e.onload = this.boundOnLoad,
            e.src = this.url
        }
    }, {
        key: "_onLoad",
        value: function() {
            delete this.content.image.onload,
            this.width = this.content.image.width,
            this.height = this.content.image.height,
            this.content.needsUpdate = !0,
            this.onPost ? this.onPost.call(this, this.content, this.onPostLoadingSignal) : this._onLoadComplete()
        }
    }]),
    r
}();
TextureItem.type = "texture",
TextureItem.extensions = [];
var AnyItem = properties.loader.ITEM_CLASSES.any
  , ThreeLoaderItem = function(e) {
    _inherits(r, AnyItem);
    var t = _createSuper(r);
    function r(e, i) {
        var n;
        return _classCallCheck(this, r),
        i.loadFunc = function() {}
        ,
        i.hasLoading = void 0 === i.hasLoading || i.hasLoading,
        n = t.call(this, e, i),
        !i.loader && console && (console.error || console.log)("loader is required."),
        n.loadFunc = n._loadFunc.bind(_assertThisInitialized(n)),
        n
    }
    return _createClass(r, [{
        key: "_loadFunc",
        value: function(e, t, r) {
            this.loader.load(e, this._onLoaderLoad.bind(this, t), this._onLoaderLoading.bind(this, r))
        }
    }, {
        key: "_onLoaderLoad",
        value: function(e, t) {
            this.content = t,
            e(t)
        }
    }, {
        key: "_onLoaderLoading",
        value: function(e, t) {
            e.dispatch(t.loaded / t.total)
        }
    }]),
    r
}();
ThreeLoaderItem.type = "three-loader",
ThreeLoaderItem.extensions = [];
var shader = "#define GLSLIFY 1\nuniform vec2 u_glPositionOffset;vec4 glPositionOffset(vec4 glPosition){return glPosition+vec4(u_glPositionOffset*glPosition.w,0.0,0.0);}"
  , GlPositionOffset = function() {
    function e() {
        _classCallCheck(this, e),
        _defineProperty(this, "offset", new Vector2),
        _defineProperty(this, "sharedUniforms", {
            u_glPositionOffset: {
                value: null
            }
        })
    }
    return _createClass(e, [{
        key: "init",
        value: function() {
            this.sharedUniforms.u_glPositionOffset.value = this.offset,
            shaderHelper.addChunk("glPositionOffset", shader)
        }
    }, {
        key: "setOffset",
        value: function(e, t) {
            return this.offset.set(e, t)
        }
    }]),
    e
}()
  , glPositionOffset = new GlPositionOffset
  , MathUtils = function() {
    function e() {
        _classCallCheck(this, e),
        _defineProperty(this, "PI", Math.PI),
        _defineProperty(this, "PI2", 2 * this.PI),
        _defineProperty(this, "HALF_PI", .5 * this.PI),
        _defineProperty(this, "DEG2RAD", this.PI / 180),
        _defineProperty(this, "RAD2DEG", 180 / this.PI)
    }
    return _createClass(e, [{
        key: "step",
        value: function(e, t) {
            return t < e ? 0 : 1
        }
    }, {
        key: "clamp",
        value: function(e, t, r) {
            return e < t ? t : e > r ? r : e
        }
    }, {
        key: "mix",
        value: function(e, t, r) {
            return e + (t - e) * r
        }
    }, {
        key: "cMix",
        value: function(e, t, r) {
            return e + (t - e) * this.clamp(r, 0, 1)
        }
    }, {
        key: "unMix",
        value: function(e, t, r) {
            return (r - e) / (t - e)
        }
    }, {
        key: "cUnMix",
        value: function(e, t, r) {
            return this.clamp((r - e) / (t - e), 0, 1)
        }
    }, {
        key: "saturate",
        value: function(e) {
            return this.clamp(e, 0, 1)
        }
    }, {
        key: "fit",
        value: function(e, t, r, i, n, a) {
            return e = this.cUnMix(t, r, e),
            a && (e = a(e)),
            i + e * (n - i)
        }
    }, {
        key: "loop",
        value: function(e, t, r) {
            return r -= t,
            ((e -= t) < 0 ? (r - Math.abs(e) % r) % r : e % r) + t
        }
    }, {
        key: "normalize",
        value: function(e, t, r) {
            return Math.max(0, Math.min(1, e - t / r - t))
        }
    }, {
        key: "smoothstep",
        value: function(e, t, r) {
            return (r = this.cUnMix(e, t, r)) * r * (3 - 2 * r)
        }
    }, {
        key: "fract",
        value: function(e) {
            return e - Math.floor(e)
        }
    }, {
        key: "hash",
        value: function(e) {
            return this.fract(43758.5453123 * Math.sin(e))
        }
    }, {
        key: "hash2",
        value: function(e, t) {
            return this.fract(43758.5453 * Math.sin(12.9898 * e + 4.1414 * t))
        }
    }, {
        key: "sign",
        value: function(e) {
            return e ? e < 0 ? -1 : 1 : 0
        }
    }, {
        key: "isPowerOfTwo",
        value: function(e) {
            return (e & -e) === e
        }
    }, {
        key: "powerTwoCeilingBase",
        value: function(e) {
            return Math.ceil(Math.log(e) / Math.log(2))
        }
    }, {
        key: "powerTwoCeiling",
        value: function(e) {
            return this.isPowerOfTwo(e) ? e : 1 << this.powerTwoCeilingBase(e)
        }
    }, {
        key: "powerTwoFloorBase",
        value: function(e) {
            return Math.floor(Math.log(e) / Math.log(2))
        }
    }, {
        key: "powerTwoFloor",
        value: function(e) {
            return this.isPowerOfTwo(e) ? e : 1 << this.powerTwoFloorBase(e)
        }
    }, {
        key: "latLngBearing",
        value: function(e, t, r, i) {
            var n = Math.sin(i - t) * Math.cos(r)
              , a = Math.cos(e) * Math.sin(r) - Math.sin(e) * Math.cos(r) * Math.cos(i - t);
            return Math.atan2(n, a)
        }
    }, {
        key: "distanceTo",
        value: function(e, t) {
            return Math.sqrt(e * e + t * t)
        }
    }, {
        key: "distanceSqrTo",
        value: function(e, t) {
            return e * e + t * t
        }
    }, {
        key: "distanceTo3",
        value: function(e, t, r) {
            return Math.sqrt(e * e + t * t + r * r)
        }
    }, {
        key: "distanceSqrTo3",
        value: function(e, t, r) {
            return e * e + t * t + r * r
        }
    }, {
        key: "latLngDistance",
        value: function(e, t, r, i) {
            var n = Math.sin((r - e) / 2)
              , a = Math.sin((i - t) / 2)
              , o = n * n + Math.cos(e) * Math.cos(r) * a * a;
            return 2 * Math.atan2(Math.sqrt(o), Math.sqrt(1 - o))
        }
    }, {
        key: "cubicBezier",
        value: function(e, t, r, i, n) {
            var a = 3 * (t - e)
              , o = 3 * (r - t) - a
              , s = n * n;
            return s * n * (i - e - a - o) + o * s + a * n + e
        }
    }, {
        key: "cubicBezierFn",
        value: function(e, t, r, i) {
            var n = 3 * (t - e)
              , a = 3 * (r - t) - n
              , o = i - e - n - a;
            return function(t) {
                var r = t * t;
                return o * (r * t) + a * r + n * t + e
            }
        }
    }, {
        key: "normalizeAngle",
        value: function(e) {
            return (e = (e += this.PI) < 0 ? this.PI2 - Math.abs(e % PI2) : e % this.PI2) - this.PI
        }
    }, {
        key: "lerp",
        value: function(e, t, r) {
            return e * (1 - r) + t * r
        }
    }, {
        key: "closestAngleTo",
        value: function(e, t) {
            return e + this.normalizeAngle(t - e)
        }
    }, {
        key: "randomRange",
        value: function(e, t) {
            return e + Math.random() * (t - e)
        }
    }, {
        key: "randomRangeInt",
        value: function(e, t) {
            return Math.floor(this.randomRange(e, t + 1))
        }
    }, {
        key: "padZero",
        value: function(e, t) {
            return e.toString().length >= t ? e : (Math.pow(10, t) + Math.floor(e)).toString().substring(1)
        }
    }, {
        key: "getSeedRandomFn",
        value: function(e) {
            for (var t, r = 1779033703, i = 3144134277, n = 1013904242, a = 2773480762, o = 0; o < e.length; o++)
                t = e.charCodeAt(o),
                r = i ^ Math.imul(r ^ t, 597399067),
                i = n ^ Math.imul(i ^ t, 2869860233),
                n = a ^ Math.imul(n ^ t, 951274213),
                a = r ^ Math.imul(a ^ t, 2716044179);
            return _sfc32(Math.imul(n ^ r >>> 18, 597399067), Math.imul(a ^ i >>> 22, 2869860233), Math.imul(r ^ n >>> 17, 951274213), Math.imul(i ^ a >>> 19, 2716044179))
        }
    }]),
    e
}();
function _sfc32(e, t, r, i) {
    return function() {
        var n = ((e |= 0) + (t |= 0) | 0) + (i |= 0) | 0;
        return i = i + 1 | 0,
        e = t ^ t >>> 9,
        t = (r |= 0) + (r << 3) | 0,
        r = (r = r << 21 | r >>> 11) + n | 0,
        (n >>> 0) / 4294967296
    }
}
var math = new MathUtils
  , Input = function() {
    function e() {
        _classCallCheck(this, e),
        _defineProperty(this, "onDowned", new MinSignal$2),
        _defineProperty(this, "onMoved", new MinSignal$2),
        _defineProperty(this, "onUped", new MinSignal$2),
        _defineProperty(this, "onClicked", new MinSignal$2),
        _defineProperty(this, "onWheeled", new MinSignal$2),
        _defineProperty(this, "onKeyPressed", new MinSignal$2),
        _defineProperty(this, "onKeyUped", new MinSignal$2),
        _defineProperty(this, "wasDown", !1),
        _defineProperty(this, "isDown", !1),
        _defineProperty(this, "isMobileScrollingY", !1),
        _defineProperty(this, "downTime", 0),
        _defineProperty(this, "hasClicked", !1),
        _defineProperty(this, "hasMoved", !1),
        _defineProperty(this, "hadMoved", !1),
        _defineProperty(this, "mouseXY", new Vector2),
        _defineProperty(this, "prevMouseXY", new Vector2),
        _defineProperty(this, "mousePixelXY", new Vector2),
        _defineProperty(this, "prevMousePixelXY", new Vector2),
        _defineProperty(this, "downXY", new Vector2),
        _defineProperty(this, "downPixelXY", new Vector2),
        _defineProperty(this, "deltaXY", new Vector2),
        _defineProperty(this, "deltaPixelXY", new Vector2),
        _defineProperty(this, "deltaDownXY", new Vector2),
        _defineProperty(this, "deltaDownPixelXY", new Vector2),
        _defineProperty(this, "deltaDownPixelDistance", 0),
        _defineProperty(this, "wheel", 0),
        _defineProperty(this, "wheelDelta", 0),
        _defineProperty(this, "lastWheelTime", 0),
        _defineProperty(this, "downThroughElems", []),
        _defineProperty(this, "currThroughElems", []),
        _defineProperty(this, "prevThroughElems", []),
        _defineProperty(this, "clickThroughElems", []),
        _defineProperty(this, "pressedKeys", {})
    }
    return _createClass(e, [{
        key: "preInit",
        value: function() {
            var e = document;
            e.addEventListener("mousedown", this._onDown.bind(this)),
            e.addEventListener("touchstart", this._getTouchBound(this, this._onDown, !0)),
            e.addEventListener("mousemove", this._onMove.bind(this)),
            e.addEventListener("touchmove", this._getTouchBound(this, this._onMove, !0)),
            e.addEventListener("mouseup", this._onUp.bind(this)),
            e.addEventListener("touchend", this._getTouchBound(this, this._onUp, !0)),
            e.addEventListener("wheel", this._onWheel.bind(this)),
            e.addEventListener("mousewheel", this._onWheel.bind(this)),
            e.addEventListener("DOMMouseScroll", this._onWheel.bind(this)),
            e.addEventListener("keydown", this._onKeyDown.bind(this)),
            e.addEventListener("keyup", this._onKeyUp.bind(this)),
            window.addEventListener("blur", this._onBlur.bind(this)),
            window.addEventListener("focus", this._onFocus.bind(this))
        }
    }, {
        key: "_onBlur",
        value: function(e) {
            for (var t in this.pressedKeys)
                this.pressedKeys[t] && (this.pressedKeys[t] = !1,
                this.onKeyUped.dispatch(t))
        }
    }, {
        key: "_onFocus",
        value: function(e) {}
    }, {
        key: "_onKeyDown",
        value: function(e) {
            var t = e.code;
            this.pressedKeys[t] || (this.pressedKeys[t] = !0,
            this.onKeyPressed.dispatch(t))
        }
    }, {
        key: "_onKeyUp",
        value: function(e) {
            var t = e.code;
            this.pressedKeys[t] && (this.pressedKeys[t] = !1,
            this.onKeyUped.dispatch(t))
        }
    }, {
        key: "init",
        value: function() {}
    }, {
        key: "update",
        value: function(e) {}
    }, {
        key: "postUpdate",
        value: function(e) {
            this.prevThroughElems.length = 0,
            this.prevThroughElems.concat(this.currThroughElems),
            this.wheelDelta = 0,
            this.prevMouseXY.copy(this.mouseXY),
            this.prevMousePixelXY.copy(this.mousePixelXY),
            this.hadMoved = this.hasMoved,
            this.wasDown = this.isDown
        }
    }, {
        key: "_onWheel",
        value: function(e) {
            var t = +new Date;
            this.lastWheelTime = t;
            var r = this._normalizeWheel(e);
            this._updateWheelData(e, r.spinY, r)
        }
    }, {
        key: "_onDown",
        value: function(e) {
            this.isDown = !0,
            this.downTime = +new Date,
            this.prevThroughElems.length = 0,
            this._setThroughElementsByEvent(e, this.downThroughElems),
            this._getInputXY(e, this.downXY),
            this._getInputPixelXY(e, this.downPixelXY),
            this.deltaXY.set(0, 0),
            this.deltaPixelXY.set(0, 0),
            this._getInputXY(e, this.mouseXY),
            this._onMove(e),
            this.onDowned.dispatch(e)
        }
    }, {
        key: "_onMove",
        value: function(e) {
            if (this._getInputXY(e, this.mouseXY),
            this._getInputPixelXY(e, this.mousePixelXY),
            this.deltaXY.copy(this.mouseXY).sub(this.prevMouseXY),
            this.deltaPixelXY.copy(this.mousePixelXY).sub(this.prevMousePixelXY),
            this.hasMoved = !0,
            !0 === this.isDown && (this.deltaDownXY.copy(this.mouseXY).sub(this.downXY),
            this.deltaDownPixelXY.copy(this.mousePixelXY).sub(this.downPixelXY),
            this.deltaDownPixelDistance = this.deltaDownPixelXY.length(),
            !0 === browser.isMobile && (this.isMobileScrollingY = Math.abs(this.deltaPixelXY.y) > .1,
            this.isMobileScrollingY))) {
                var t = this._normalizeWheel({
                    deltaX: this.deltaXY.x,
                    deltaY: this.deltaXY.y
                })
                  , r = t.pixelY;
                this._updateWheelData(e, r, t)
            }
            this._setThroughElementsByEvent(e, this.currThroughElems),
            this.onMoved.dispatch(e)
        }
    }, {
        key: "_onUp",
        value: function(e) {
            var t = e.clientX - this.downPixelXY.x
              , r = e.clientY - this.downPixelXY.y;
            Math.sqrt(t * t + r * r) < 40 && +new Date - this.downTime < 300 && (this._setThroughElementsByEvent(e, this.clickThroughElems),
            this._getInputXY(e, this.mouseXY),
            this.hasClicked = !0,
            this.onClicked.dispatch(e)),
            this.deltaXY.set(0, 0),
            this.deltaPixelXY.set(0, 0),
            this.deltaDownXY.set(0, 0),
            this.deltaDownPixelXY.set(0, 0),
            this.deltaDownPixelDistance = 0,
            this.isDown = !1,
            this.isMobileScrollingY = !1,
            this.onUped.dispatch(e)
        }
    }, {
        key: "_updateWheelData",
        value: function(e, t, r) {
            var i = t * (!0 === browser.isMobile ? -100 : 1);
            this.wheelDelta += i < 0 ? Math.floor(i) : Math.ceil(i),
            this.wheel += this.wheelDelta,
            this.onWheeled.dispatch(e.target, this.wheelDelta, r)
        }
    }, {
        key: "_getTouchBound",
        value: function(e, t, r) {
            return function(i) {
                r && i.preventDefault && i.preventDefault(),
                t.call(e, i.changedTouches[0] || i.touches[0])
            }
        }
    }, {
        key: "_getInputXY",
        value: function(e, t) {
            return t.set(e.clientX / window.innerWidth * 2 - 1, 1 - e.clientY / window.innerHeight * 2),
            t
        }
    }, {
        key: "_getInputPixelXY",
        value: function(e, t) {
            t.set(e.clientX, e.clientY)
        }
    }, {
        key: "_setThroughElementsByEvent",
        value: function(e, t) {
            var r = e.target;
            for (t.length = 0; r.parentNode; )
                t.push(r),
                r = r.parentNode
        }
    }, {
        key: "hasThroughElem",
        value: function(e, t) {
            for (var r = this[t + "ThroughElems"] || this.currThroughElems, i = r.length; i--; )
                if (r[i] === e)
                    return !0;
            return !1
        }
    }, {
        key: "hasThroughElemWithClass",
        value: function(e, t) {
            for (var r = this[t + "ThroughElems"] || this.currThroughElems, i = r.length; i--; )
                if (r[i].classList.contains(e))
                    return r[i];
            return null
        }
    }, {
        key: "_normalizeWheel",
        value: function(e) {
            var t = window.innerHeight
              , r = 0
              , i = 0
              , n = 0
              , a = 0;
            return "detail"in e && (i = e.detail),
            "wheelDelta"in e && (i = -e.wheelDelta / 120),
            "wheelDeltaY"in e && (i = -e.wheelDeltaY / 120),
            "wheelDeltaX"in e && (r = -e.wheelDeltaX / 120),
            "axis"in e && e.axis === e.HORIZONTAL_AXIS && (r = i,
            i = 0),
            n = 10 * r,
            a = 10 * i,
            "deltaY"in e && (a = e.deltaY),
            "deltaX"in e && (n = e.deltaX),
            (n || a) && e.deltaMode && (1 === e.deltaMode ? (n *= 40,
            a *= 40) : (n *= t,
            a *= t)),
            n && !r && (r = n < 1 ? -1 : 1),
            a && !i && (i = a < 1 ? -1 : 1),
            {
                spinX: r,
                spinY: i,
                pixelX: n,
                pixelY: a
            }
        }
    }]),
    e
}()
  , input = new Input
  , frag$2 = "#define GLSLIFY 1\nuniform sampler2D u_lowPaintTexture;uniform sampler2D u_prevPaintTexture;uniform vec2 u_paintTexelSize;uniform vec4 u_drawFrom;uniform vec4 u_drawTo;uniform float u_pushStrength;uniform vec3 u_dissipations;uniform float u_time;varying vec2 v_uv;vec2 sdSegment(in vec2 p,in vec2 a,in vec2 b){vec2 pa=p-a,ba=b-a;float h=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);return vec2(length(pa-ba*h),h);}\n#ifdef USE_NOISE\nuniform float u_curlScale;uniform float u_curlStrength;vec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}float mod289(float x){return x-floor(x*(1.0/289.0))*289.0;}vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}float permute(float x){return mod289(((x*34.0)+1.0)*x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}float taylorInvSqrt(float r){return 1.79284291400159-0.85373472095314*r;}vec4 grad4(float j,vec4 ip){const vec4 ones=vec4(1.0,1.0,1.0,-1.0);vec4 p,s;p.xyz=floor(fract(vec3(j)*ip.xyz)*7.0)*ip.z-1.0;p.w=1.5-dot(abs(p.xyz),ones.xyz);s=vec4(lessThan(p,vec4(0.0)));p.xyz=p.xyz+(s.xyz*2.0-1.0)*s.www;return p;}\n#define F4 0.309016994374947451\nvec4 simplexNoiseDerivatives(vec4 v){const vec4 C=vec4(0.138196601125011,0.276393202250021,0.414589803375032,-0.447213595499958);vec4 i=floor(v+dot(v,vec4(F4)));vec4 x0=v-i+dot(i,C.xxxx);vec4 i0;vec3 isX=step(x0.yzw,x0.xxx);vec3 isYZ=step(x0.zww,x0.yyz);i0.x=isX.x+isX.y+isX.z;i0.yzw=1.0-isX;i0.y+=isYZ.x+isYZ.y;i0.zw+=1.0-isYZ.xy;i0.z+=isYZ.z;i0.w+=1.0-isYZ.z;vec4 i3=clamp(i0,0.0,1.0);vec4 i2=clamp(i0-1.0,0.0,1.0);vec4 i1=clamp(i0-2.0,0.0,1.0);vec4 x1=x0-i1+C.xxxx;vec4 x2=x0-i2+C.yyyy;vec4 x3=x0-i3+C.zzzz;vec4 x4=x0+C.wwww;i=mod289(i);float j0=permute(permute(permute(permute(i.w)+i.z)+i.y)+i.x);vec4 j1=permute(permute(permute(permute(i.w+vec4(i1.w,i2.w,i3.w,1.0))+i.z+vec4(i1.z,i2.z,i3.z,1.0))+i.y+vec4(i1.y,i2.y,i3.y,1.0))+i.x+vec4(i1.x,i2.x,i3.x,1.0));vec4 ip=vec4(1.0/294.0,1.0/49.0,1.0/7.0,0.0);vec4 p0=grad4(j0,ip);vec4 p1=grad4(j1.x,ip);vec4 p2=grad4(j1.y,ip);vec4 p3=grad4(j1.z,ip);vec4 p4=grad4(j1.w,ip);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;p4*=taylorInvSqrt(dot(p4,p4));vec3 values0=vec3(dot(p0,x0),dot(p1,x1),dot(p2,x2));vec2 values1=vec2(dot(p3,x3),dot(p4,x4));vec3 m0=max(0.5-vec3(dot(x0,x0),dot(x1,x1),dot(x2,x2)),0.0);vec2 m1=max(0.5-vec2(dot(x3,x3),dot(x4,x4)),0.0);vec3 temp0=-6.0*m0*m0*values0;vec2 temp1=-6.0*m1*m1*values1;vec3 mmm0=m0*m0*m0;vec2 mmm1=m1*m1*m1;float dx=temp0[0]*x0.x+temp0[1]*x1.x+temp0[2]*x2.x+temp1[0]*x3.x+temp1[1]*x4.x+mmm0[0]*p0.x+mmm0[1]*p1.x+mmm0[2]*p2.x+mmm1[0]*p3.x+mmm1[1]*p4.x;float dy=temp0[0]*x0.y+temp0[1]*x1.y+temp0[2]*x2.y+temp1[0]*x3.y+temp1[1]*x4.y+mmm0[0]*p0.y+mmm0[1]*p1.y+mmm0[2]*p2.y+mmm1[0]*p3.y+mmm1[1]*p4.y;float dz=temp0[0]*x0.z+temp0[1]*x1.z+temp0[2]*x2.z+temp1[0]*x3.z+temp1[1]*x4.z+mmm0[0]*p0.z+mmm0[1]*p1.z+mmm0[2]*p2.z+mmm1[0]*p3.z+mmm1[1]*p4.z;float dw=temp0[0]*x0.w+temp0[1]*x1.w+temp0[2]*x2.w+temp1[0]*x3.w+temp1[1]*x4.w+mmm0[0]*p0.w+mmm0[1]*p1.w+mmm0[2]*p2.w+mmm1[0]*p3.w+mmm1[1]*p4.w;return vec4(dx,dy,dz,dw)*49.0;}vec3 curl(in vec3 p,in float noiseTime,in float persistence){vec4 xNoisePotentialDerivatives=vec4(0.0);vec4 yNoisePotentialDerivatives=vec4(0.0);vec4 zNoisePotentialDerivatives=vec4(0.0);for(int i=0;i<2;++i){float twoPowI=pow(2.0,float(i));float scale=0.5*twoPowI*pow(persistence,float(i));xNoisePotentialDerivatives+=simplexNoiseDerivatives(vec4(p*twoPowI,noiseTime))*scale;yNoisePotentialDerivatives+=simplexNoiseDerivatives(vec4((p+vec3(123.4,129845.6,-1239.1))*twoPowI,noiseTime))*scale;zNoisePotentialDerivatives+=simplexNoiseDerivatives(vec4((p+vec3(-9519.0,9051.0,-123.0))*twoPowI,noiseTime))*scale;}return vec3(zNoisePotentialDerivatives[1]-yNoisePotentialDerivatives[2],xNoisePotentialDerivatives[2]-zNoisePotentialDerivatives[0],yNoisePotentialDerivatives[0]-xNoisePotentialDerivatives[1]);}\n#endif\nvoid main(){vec2 res=sdSegment(gl_FragCoord.xy,u_drawFrom.xy,u_drawTo.xy);vec2 radiusWeight=mix(u_drawFrom.zw,u_drawTo.zw,res.y);float d=1.0-smoothstep(-0.01,radiusWeight.x,res.x);vec4 lowData=texture2D(u_lowPaintTexture,v_uv);vec2 velInv=(0.5-lowData.xy)*u_pushStrength;\n#ifdef USE_NOISE\nvec2 noise=curl(vec3(gl_FragCoord.xy*u_curlScale,100.0),u_time,0.2).xy;velInv+=noise*u_curlStrength*(lowData.z+lowData.w)*0.5;\n#endif\nvec4 data=texture2D(u_prevPaintTexture,v_uv+velInv*u_paintTexelSize);data.xy-=0.5;vec4 delta=(u_dissipations.xxyz-1.0)*data;vec2 newVel=clamp((u_drawTo.xy-u_drawFrom.xy)*0.2,vec2(-0.5),vec2(0.5))*d;delta+=vec4(newVel,radiusWeight.yy*d);delta=sign(delta)*max(vec4(0.004),abs(delta));data+=delta;data.xy+=0.5;gl_FragColor=clamp(data,vec4(0.0),vec4(1.0));}"
  , blur9VaryingVertexShader = "#define GLSLIFY 1\nattribute vec3 position;uniform vec2 u_delta;varying vec2 v_uv[9];void main(){vec2 uv=position.xy*0.5+0.5;v_uv[0]=uv;vec2 delta=u_delta;v_uv[1]=uv-delta;v_uv[2]=uv+delta;delta+=u_delta;v_uv[3]=uv-delta;v_uv[4]=uv+delta;delta+=u_delta;v_uv[5]=uv-delta;v_uv[6]=uv+delta;delta+=u_delta;v_uv[7]=uv-delta;v_uv[8]=uv+delta;gl_Position=vec4(position,1.0);}"
  , blur9VaryingFragmentShader = "#define GLSLIFY 1\nuniform sampler2D u_texture;varying vec2 v_uv[9];void main(){vec4 color=texture2D(u_texture,v_uv[0])*0.1633;color+=texture2D(u_texture,v_uv[1])*0.1531;color+=texture2D(u_texture,v_uv[2])*0.1531;color+=texture2D(u_texture,v_uv[3])*0.12245;color+=texture2D(u_texture,v_uv[4])*0.12245;color+=texture2D(u_texture,v_uv[5])*0.0918;color+=texture2D(u_texture,v_uv[6])*0.0918;color+=texture2D(u_texture,v_uv[7])*0.051;color+=texture2D(u_texture,v_uv[8])*0.051;gl_FragColor=color;}"
  , blur9FragmentShader = "#define GLSLIFY 1\nuniform sampler2D u_texture;uniform vec2 u_delta;varying vec2 v_uv;void main(){vec4 color=texture2D(u_texture,v_uv)*0.1633;vec2 delta=u_delta;color+=texture2D(u_texture,v_uv-delta)*0.1531;color+=texture2D(u_texture,v_uv+delta)*0.1531;delta+=u_delta;color+=texture2D(u_texture,v_uv-delta)*0.12245;color+=texture2D(u_texture,v_uv+delta)*0.12245;delta+=u_delta;color+=texture2D(u_texture,v_uv-delta)*0.0918;color+=texture2D(u_texture,v_uv+delta)*0.0918;delta+=u_delta;color+=texture2D(u_texture,v_uv-delta)*0.051;color+=texture2D(u_texture,v_uv+delta)*0.051;gl_FragColor=color;}"
  , Blur = function() {
    function e() {
        _classCallCheck(this, e),
        _defineProperty(this, "material", null),
        _defineProperty(this, "renderTarget", null)
    }
    return _createClass(e, [{
        key: "getBlur9Material",
        value: function() {
            var e = fboHelper.MAX_VARYING_VECTORS > 8;
            return this.blur9Material || (this.blur9Material = new RawShaderMaterial({
                uniforms: {
                    u_texture: {
                        value: null
                    },
                    u_delta: {
                        value: new Vector2
                    }
                },
                vertexShader: e ? fboHelper.precisionPrefix + blur9VaryingVertexShader : fboHelper.vertexShader,
                fragmentShader: fboHelper.precisionPrefix + (e ? blur9VaryingFragmentShader : blur9FragmentShader)
            })),
            this.blur9Material
        }
    }, {
        key: "blur",
        value: function(e, t, r, i, n, a) {
            var o = Math.ceil(r.width * t) || 0
              , s = Math.ceil(r.height * t) || 0;
            this.material || (this.material = this.getBlur9Material()),
            i || (this.renderTarget = fboHelper.createRenderTarget(1, 1),
            i = this.renderTarget),
            i.setSize(o, s),
            n ? a || n.setSize(r.width, r.height) : n = r,
            this.material.uniforms.u_texture.value = r.texture || r,
            this.material.uniforms.u_delta.value.set(e / o * .25, 0),
            fboHelper.render(this.material, i),
            this.material.uniforms.u_texture.value = i.texture || i,
            this.material.uniforms.u_delta.value.set(0, e / s * .25),
            fboHelper.render(this.material, n)
        }
    }]),
    e
}()
  , blur = new Blur
  , ScreenPaint = function() {
    function e() {
        var t = this;
        _classCallCheck(this, e),
        _defineProperty(this, "_lowRenderTarget", void 0),
        _defineProperty(this, "_prevPaintRenderTarget", void 0),
        _defineProperty(this, "_currPaintRenderTarget", void 0),
        _defineProperty(this, "_material", void 0),
        _defineProperty(this, "_distortionMaterial", void 0),
        _defineProperty(this, "_fromDrawData", void 0),
        _defineProperty(this, "_toDrawData", void 0),
        _defineProperty(this, "drawEnabled", !0),
        _defineProperty(this, "needsMouseDown", !1),
        _defineProperty(this, "enabled", !0),
        _defineProperty(this, "minRadius", 0),
        _defineProperty(this, "maxRadius", 100),
        _defineProperty(this, "radiusDistanceRange", 100),
        _defineProperty(this, "pushStrength", 25),
        _defineProperty(this, "velocityDissipation", .985),
        _defineProperty(this, "weight1Dissipation", .985),
        _defineProperty(this, "weight2Dissipation", .5),
        _defineProperty(this, "useNoise", !1),
        _defineProperty(this, "curlScale", .1),
        _defineProperty(this, "curlStrength", 5),
        _defineProperty(this, "_prevUseNoise", null),
        _defineProperty(this, "sharedUniforms", {
            u_paintTexelSize: {
                value: new Vector2
            },
            u_prevPaintTexture: {
                value: null
            },
            u_currPaintTexture: {
                value: null
            },
            u_lowPaintTexture: {
                value: null
            }
        }),
        _defineProperty(this, "clear", (function() {
            fboHelper.clearColor(.5, .5, 0, 0, t._lowRenderTarget),
            fboHelper.clearColor(.5, .5, 0, 0, t._currPaintRenderTarget)
        }
        ))
    }
    return _createClass(e, [{
        key: "init",
        value: function() {
            this._lowRenderTarget = fboHelper.createRenderTarget(1, 1),
            this._prevPaintRenderTarget = fboHelper.createRenderTarget(1, 1),
            this._currPaintRenderTarget = fboHelper.createRenderTarget(1, 1),
            this.sharedUniforms.u_lowPaintTexture.value = this._lowRenderTarget.texture,
            this._material = new RawShaderMaterial({
                uniforms: {
                    u_lowPaintTexture: {
                        value: this._lowRenderTarget.texture
                    },
                    u_prevPaintTexture: this.sharedUniforms.u_prevPaintTexture,
                    u_paintTexelSize: this.sharedUniforms.u_paintTexelSize,
                    u_drawFrom: {
                        value: this._fromDrawData = new Vector4(0,0,0,0)
                    },
                    u_drawTo: {
                        value: this._toDrawData = new Vector4(0,0,0,0)
                    },
                    u_pushStrength: {
                        value: 0
                    },
                    u_curlScale: {
                        value: 0
                    },
                    u_curlStrength: {
                        value: 0
                    },
                    u_dissipations: {
                        value: new Vector3
                    },
                    u_time: properties.sharedUniforms.u_time
                },
                vertexShader: fboHelper.vertexShader,
                fragmentShader: fboHelper.precisionPrefix + frag$2
            })
        }
    }, {
        key: "resize",
        value: function(e, t) {
            var r = e >> 2
              , i = t >> 2
              , n = e >> 4
              , a = t >> 4;
            r === this._currPaintRenderTarget.width && i === this._currPaintRenderTarget.height || (this._currPaintRenderTarget.setSize(r, i),
            this._prevPaintRenderTarget.setSize(r, i),
            this._lowRenderTarget.setSize(n, a),
            this.sharedUniforms.u_paintTexelSize.value.set(1 / r, 1 / i),
            this.clear())
        }
    }, {
        key: "update",
        value: function(e) {
            if (this.enabled) {
                this.useNoise !== this._prevUseNoise && (this._material.defines.USE_NOISE = this.useNoise,
                this._material.needsUpdate = !0,
                this._prevUseNoise = this.useNoise);
                var t = this._currPaintRenderTarget.width
                  , r = this._currPaintRenderTarget.height
                  , i = this._prevPaintRenderTarget;
                this._prevPaintRenderTarget = this._currPaintRenderTarget,
                this._currPaintRenderTarget = i,
                this.sharedUniforms.u_prevPaintTexture.value = this._prevPaintRenderTarget.texture,
                this.sharedUniforms.u_currPaintTexture.value = this._currPaintRenderTarget.texture,
                this._material.uniforms.u_drawFrom.value.z = this._material.uniforms.u_drawTo.value.z;
                var n = input.mousePixelXY.distanceTo(input.prevMousePixelXY)
                  , a = math.fit(n, 0, this.radiusDistanceRange, this.minRadius, this.maxRadius);
                input.hadMoved && this.drawEnabled && (!this.needsMouseDown && !browser.isMobile || input.isDown && input.wasDown) || (a = 0),
                a = a / properties.rawHeight * r,
                this._material.uniforms.u_pushStrength.value = this.pushStrength,
                this._material.uniforms.u_curlScale.value = this.curlScale,
                this._material.uniforms.u_curlStrength.value = this.curlStrength,
                this._material.uniforms.u_dissipations.value.set(this.velocityDissipation, this.weight1Dissipation, this.weight2Dissipation),
                this._fromDrawData.copy(this._toDrawData),
                this._toDrawData.set((input.mouseXY.x + 1) * t / 2, (input.mouseXY.y + 1) * r / 2, a, 1),
                fboHelper.render(this._material, this._currPaintRenderTarget),
                fboHelper.copy(this._currPaintRenderTarget.texture, this._lowRenderTarget),
                blur.blur(4, 1, this._lowRenderTarget)
            }
        }
    }]),
    e
}()
  , screenPaint = new ScreenPaint
  , Simple1DNoise = function() {
    function e() {
        _classCallCheck(this, e),
        _defineProperty(this, "_scale", 1),
        _defineProperty(this, "_amplitude", 1),
        _defineProperty(this, "_r", []);
        for (var t = 0; t < e.MAX_VERTICES; ++t)
            this._r.push(Math.random() - .5)
    }
    return _createClass(e, [{
        key: "getVal",
        value: function(t) {
            var r = t * this._scale
              , i = Math.floor(r)
              , n = r - i
              , a = n * n * (3 - 2 * n)
              , o = i & e.MAX_VERTICES_MASK
              , s = o + 1 & e.MAX_VERTICES_MASK;
            return math.mix(this._r[o], this._r[s], a) * this._amplitude
        }
    }, {
        key: "amplitude",
        get: function() {
            return this._amplitude
        },
        set: function(e) {
            this._amplitude = e
        }
    }, {
        key: "scale",
        get: function() {
            return this._scale
        },
        set: function(e) {
            this._scale = e
        }
    }]),
    e
}();
_defineProperty(Simple1DNoise, "MAX_VERTICES", 256),
_defineProperty(Simple1DNoise, "MAX_VERTICES_MASK", Simple1DNoise.MAX_VERTICES - 1);
var _e$1 = new Euler
  , _v = new Vector3
  , BrownianMotion = function() {
    function e() {
        _classCallCheck(this, e),
        _defineProperty(this, "_position", new Vector3),
        _defineProperty(this, "_rotation", new Quaternion),
        _defineProperty(this, "_scale", new Vector3(1,1,1)),
        _defineProperty(this, "_matrix", new Matrix4),
        _defineProperty(this, "_enablePositionNoise", !0),
        _defineProperty(this, "_enableRotationNoise", !0),
        _defineProperty(this, "_positionFrequency", .25),
        _defineProperty(this, "_rotationFrequency", .25),
        _defineProperty(this, "_positionAmplitude", .3),
        _defineProperty(this, "_rotationAmplitude", .003),
        _defineProperty(this, "_positionScale", new Vector3(1,1,1)),
        _defineProperty(this, "_rotationScale", new Vector3(1,1,0)),
        _defineProperty(this, "_positionFractalLevel", 3),
        _defineProperty(this, "_rotationFractalLevel", 3),
        _defineProperty(this, "_times", new Float32Array(6)),
        _defineProperty(this, "_noise", new Simple1DNoise),
        this.rehash()
    }
    return _createClass(e, [{
        key: "rehash",
        value: function() {
            for (var e = 0; e < 6; e++)
                this._times[e] = -1e4 * Math.random()
        }
    }, {
        key: "_fbm",
        value: function(e, t) {
            for (var r = 0, i = .5, n = 0; n < t; n++)
                r += i * this._noise.getVal(e),
                e *= 2,
                i *= .5;
            return r
        }
    }, {
        key: "update",
        value: function(t) {
            var r = void 0 === t ? 1e3 / 60 : t;
            if (this._enablePositionNoise) {
                for (var i = 0; i < 3; i++)
                    this._times[i] += this._positionFrequency * r;
                _v.set(this._fbm(this._times[0], this._positionFractalLevel), this._fbm(this._times[1], this._positionFractalLevel), this._fbm(this._times[2], this._positionFractalLevel)),
                _v.multiply(this._positionScale),
                _v.multiplyScalar(this._positionAmplitude * e.FBM_NORM),
                this._position.copy(_v)
            }
            if (this._enableRotationNoise) {
                for (var n = 0; n < 3; n++)
                    this._times[n + 3] += this._rotationFrequency * r;
                _v.set(this._fbm(this._times[3], this._rotationFractalLevel), this._fbm(this._times[4], this._rotationFractalLevel), this._fbm(this._times[5], this._rotationFractalLevel)),
                _v.multiply(this._rotationScale),
                _v.multiplyScalar(this._rotationAmplitude * e.FBM_NORM),
                _e$1.set(_v.x, _v.y, _v.z),
                this._rotation.setFromEuler(_e$1)
            }
            this._matrix.compose(this._position, this._rotation, this._scale)
        }
    }, {
        key: "positionAmplitude",
        get: function() {
            return this._positionAmplitude
        },
        set: function(e) {
            this._positionAmplitude = e
        }
    }, {
        key: "positionFrequency",
        get: function() {
            return this._positionFrequency
        },
        set: function(e) {
            this._positionFrequency = e
        }
    }, {
        key: "rotationAmplitude",
        get: function() {
            return this._rotationAmplitude
        },
        set: function(e) {
            this._rotationAmplitude = e
        }
    }, {
        key: "rotationFrequency",
        get: function() {
            return this._rotationFrequency
        },
        set: function(e) {
            this._rotationFrequency = e
        }
    }, {
        key: "matrix",
        get: function() {
            return this._matrix
        },
        set: function(e) {
            this._matrix = e
        }
    }]),
    e
}();
_defineProperty(BrownianMotion, "FBM_NORM", 1 / .75);
var _changeEvent = {
    type: "change"
}
  , _startEvent = {
    type: "start"
}
  , _endEvent = {
    type: "end"
}
  , OrbitControls = function(e) {
    _inherits(r, EventDispatcher);
    var t = _createSuper(r);
    function r(e, i) {
        var n, a, o, s, l, u, c;
        _classCallCheck(this, r),
        n = t.call(this),
        void 0 === i && console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'),
        i === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),
        n.object = e,
        n.domElement = i,
        n.domElement.style.touchAction = "none",
        n.enabled = !0,
        n.target = new Vector3,
        n.minDistance = 5,
        n.maxDistance = 25,
        n.minZoom = 0,
        n.maxZoom = 1 / 0,
        n.minPolarAngle = 0,
        n.maxPolarAngle = .46 * Math.PI,
        n.minAzimuthAngle = -1 / 0,
        n.maxAzimuthAngle = 1 / 0,
        n.enableDamping = !0,
        n.dampingFactor = .1,
        n.enableZoom = !0,
        n.zoomSpeed = 1,
        n.enableRotate = !0,
        n.rotateSpeed = 1,
        n.enablePan = !1,
        n.panSpeed = 1,
        n.screenSpacePanning = !0,
        n.keyPanSpeed = 7,
        n.autoRotate = !1,
        n.autoRotateSpeed = 2,
        n.keys = {
            LEFT: "ArrowLeft",
            UP: "ArrowUp",
            RIGHT: "ArrowRight",
            BOTTOM: "ArrowDown"
        },
        n.mouseButtons = {
            LEFT: MOUSE.ROTATE,
            MIDDLE: MOUSE.DOLLY,
            RIGHT: MOUSE.PAN
        },
        n.touches = {
            ONE: TOUCH.ROTATE,
            TWO: TOUCH.DOLLY_PAN
        },
        n.target0 = n.target.clone(),
        n.position0 = n.object.position.clone(),
        n.zoom0 = n.object.zoom,
        n.scale = 1,
        n._domElementKeyEvents = null,
        n.getPolarAngle = function() {
            return m.phi
        }
        ,
        n.getAzimuthalAngle = function() {
            return m.theta
        }
        ,
        n.getDistance = function() {
            return this.object.position.distanceTo(this.target)
        }
        ,
        n.listenToKeyEvents = function(e) {
            e.addEventListener("keydown", J),
            this._domElementKeyEvents = e
        }
        ,
        n.saveState = function() {
            h.target0.copy(h.target),
            h.position0.copy(h.object.position),
            h.zoom0 = h.object.zoom
        }
        ,
        n.reset = function() {
            h.target.copy(h.target0),
            h.object.position.copy(h.position0),
            h.object.zoom = h.zoom0,
            h.scale = 1,
            h.object.updateProjectionMatrix(),
            h.dispatchEvent(_changeEvent),
            h.update(),
            p = d.NONE
        }
        ,
        n.update = (a = new Vector3,
        o = (new Quaternion).setFromUnitVectors(e.up, new Vector3(0,1,0)),
        s = o.clone().invert(),
        l = new Vector3,
        u = new Quaternion,
        c = 2 * Math.PI,
        function() {
            var e = h.object.position;
            a.copy(e).sub(h.target),
            a.applyQuaternion(o),
            m.setFromVector3(a),
            h.autoRotate && p === d.NONE && L(2 * Math.PI / 60 / 60 * h.autoRotateSpeed),
            h.enableDamping ? (m.theta += v.theta * h.dampingFactor,
            m.phi += v.phi * h.dampingFactor) : (m.theta += v.theta,
            m.phi += v.phi);
            var t = h.minAzimuthAngle
              , r = h.maxAzimuthAngle;
            isFinite(t) && isFinite(r) && (t < -Math.PI ? t += c : t > Math.PI && (t -= c),
            r < -Math.PI ? r += c : r > Math.PI && (r -= c),
            m.theta = t <= r ? Math.max(t, Math.min(r, m.theta)) : m.theta > (t + r) / 2 ? Math.max(t, m.theta) : Math.min(r, m.theta)),
            m.phi = Math.max(h.minPolarAngle, Math.min(h.maxPolarAngle, m.phi)),
            m.makeSafe();
            var i = h.enableDamping ? (h.scale - 1) * h.dampingFactor + 1 : h.scale;
            return m.radius *= i,
            m.radius = Math.max(h.minDistance, Math.min(h.maxDistance, m.radius)),
            !0 === h.enableDamping ? h.target.addScaledVector(g, h.dampingFactor) : h.target.add(g),
            a.setFromSpherical(m),
            a.applyQuaternion(s),
            e.copy(h.target).add(a),
            h.object.lookAt(h.target),
            !0 === h.enableDamping ? (v.theta *= 1 - h.dampingFactor,
            v.phi *= 1 - h.dampingFactor,
            g.multiplyScalar(1 - h.dampingFactor)) : (v.set(0, 0, 0),
            g.set(0, 0, 0)),
            h.scale = h.scale / i,
            !!(_ || l.distanceToSquared(h.object.position) > f || 8 * (1 - u.dot(h.object.quaternion)) > f) && (h.dispatchEvent(_changeEvent),
            l.copy(h.object.position),
            u.copy(h.object.quaternion),
            _ = !1,
            !0)
        }
        ),
        n.dispose = function() {
            h.domElement.removeEventListener("contextmenu", Q),
            h.domElement.removeEventListener("pointerdown", q),
            h.domElement.removeEventListener("pointercancel", K),
            h.domElement.removeEventListener("wheel", Z),
            h.domElement.removeEventListener("pointermove", X),
            h.domElement.removeEventListener("pointerup", Y),
            null !== h._domElementKeyEvents && h._domElementKeyEvents.removeEventListener("keydown", J)
        }
        ;
        var h = _assertThisInitialized(n)
          , d = {
            NONE: -1,
            ROTATE: 0,
            DOLLY: 1,
            PAN: 2,
            TOUCH_ROTATE: 3,
            TOUCH_PAN: 4,
            TOUCH_DOLLY_PAN: 5,
            TOUCH_DOLLY_ROTATE: 6
        }
          , p = d.NONE
          , f = 1e-6
          , m = new Spherical
          , v = new Spherical
          , g = new Vector3
          , _ = !1
          , y = new Vector2
          , x = new Vector2
          , b = new Vector2
          , S = new Vector2
          , w = new Vector2
          , M = new Vector2
          , T = new Vector2
          , C = new Vector2
          , E = new Vector2
          , P = []
          , A = {};
        function k() {
            return Math.pow(.95, h.zoomSpeed)
        }
        function L(e) {
            v.theta -= e
        }
        function R(e) {
            v.phi -= e
        }
        var D, I = (D = new Vector3,
        function(e, t) {
            D.setFromMatrixColumn(t, 0),
            D.multiplyScalar(-e),
            g.add(D)
        }
        ), O = function() {
            var e = new Vector3;
            return function(t, r) {
                !0 === h.screenSpacePanning ? e.setFromMatrixColumn(r, 1) : (e.setFromMatrixColumn(r, 0),
                e.crossVectors(h.object.up, e)),
                e.multiplyScalar(t),
                g.add(e)
            }
        }(), N = function() {
            var e = new Vector3;
            return function(t, r) {
                var i = h.domElement;
                if (h.object.isPerspectiveCamera) {
                    var n = h.object.position;
                    e.copy(n).sub(h.target);
                    var a = e.length();
                    a *= Math.tan(h.object.fov / 2 * Math.PI / 180),
                    I(2 * t * a / i.clientHeight, h.object.matrix),
                    O(2 * r * a / i.clientHeight, h.object.matrix)
                } else
                    h.object.isOrthographicCamera ? (I(t * (h.object.right - h.object.left) / h.object.zoom / i.clientWidth, h.object.matrix),
                    O(r * (h.object.top - h.object.bottom) / h.object.zoom / i.clientHeight, h.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),
                    h.enablePan = !1)
            }
        }();
        function F(e) {
            h.object.isPerspectiveCamera ? h.scale /= e : h.object.isOrthographicCamera ? (h.object.zoom = Math.max(h.minZoom, Math.min(h.maxZoom, h.object.zoom * e)),
            h.object.updateProjectionMatrix(),
            _ = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
            h.enableZoom = !1)
        }
        function B(e) {
            h.object.isPerspectiveCamera ? h.scale *= e : h.object.isOrthographicCamera ? (h.object.zoom = Math.max(h.minZoom, Math.min(h.maxZoom, h.object.zoom / e)),
            h.object.updateProjectionMatrix(),
            _ = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
            h.enableZoom = !1)
        }
        function z(e) {
            y.set(e.clientX, e.clientY)
        }
        function U(e) {
            S.set(e.clientX, e.clientY)
        }
        function V() {
            if (1 === P.length)
                y.set(P[0].pageX, P[0].pageY);
            else {
                var e = .5 * (P[0].pageX + P[1].pageX)
                  , t = .5 * (P[0].pageY + P[1].pageY);
                y.set(e, t)
            }
        }
        function G() {
            if (1 === P.length)
                S.set(P[0].pageX, P[0].pageY);
            else {
                var e = .5 * (P[0].pageX + P[1].pageX)
                  , t = .5 * (P[0].pageY + P[1].pageY);
                S.set(e, t)
            }
        }
        function H() {
            var e = P[0].pageX - P[1].pageX
              , t = P[0].pageY - P[1].pageY
              , r = Math.sqrt(e * e + t * t);
            T.set(0, r)
        }
        function W(e) {
            if (1 == P.length)
                x.set(e.pageX, e.pageY);
            else {
                var t = re(e)
                  , r = .5 * (e.pageX + t.x)
                  , i = .5 * (e.pageY + t.y);
                x.set(r, i)
            }
            b.subVectors(x, y).multiplyScalar(h.rotateSpeed);
            var n = h.domElement;
            L(2 * Math.PI * b.x / n.clientHeight),
            R(2 * Math.PI * b.y / n.clientHeight),
            y.copy(x)
        }
        function $(e) {
            if (1 === P.length)
                w.set(e.pageX, e.pageY);
            else {
                var t = re(e)
                  , r = .5 * (e.pageX + t.x)
                  , i = .5 * (e.pageY + t.y);
                w.set(r, i)
            }
            M.subVectors(w, S).multiplyScalar(h.panSpeed),
            N(M.x, M.y),
            S.copy(w)
        }
        function j(e) {
            var t = re(e)
              , r = e.pageX - t.x
              , i = e.pageY - t.y
              , n = Math.sqrt(r * r + i * i);
            C.set(0, n),
            E.set(0, Math.pow(C.y / T.y, h.zoomSpeed)),
            F(E.y),
            T.copy(C)
        }
        function q(e) {
            !1 !== h.enabled && (0 === P.length && (h.domElement.setPointerCapture(e.pointerId),
            h.domElement.addEventListener("pointermove", X),
            h.domElement.addEventListener("pointerup", Y)),
            function(e) {
                P.push(e)
            }(e),
            "touch" === e.pointerType ? function(e) {
                switch (te(e),
                P.length) {
                case 1:
                    switch (h.touches.ONE) {
                    case TOUCH.ROTATE:
                        if (!1 === h.enableRotate)
                            return;
                        V(),
                        p = d.TOUCH_ROTATE;
                        break;
                    case TOUCH.PAN:
                        if (!1 === h.enablePan)
                            return;
                        G(),
                        p = d.TOUCH_PAN;
                        break;
                    default:
                        p = d.NONE
                    }
                    break;
                case 2:
                    switch (h.touches.TWO) {
                    case TOUCH.DOLLY_PAN:
                        if (!1 === h.enableZoom && !1 === h.enablePan)
                            return;
                        h.enableZoom && H(),
                        h.enablePan && G(),
                        p = d.TOUCH_DOLLY_PAN;
                        break;
                    case TOUCH.DOLLY_ROTATE:
                        if (!1 === h.enableZoom && !1 === h.enableRotate)
                            return;
                        h.enableZoom && H(),
                        h.enableRotate && V(),
                        p = d.TOUCH_DOLLY_ROTATE;
                        break;
                    default:
                        p = d.NONE
                    }
                    break;
                default:
                    p = d.NONE
                }
                p !== d.NONE && h.dispatchEvent(_startEvent)
            }(e) : function(e) {
                var t;
                switch (e.button) {
                case 0:
                    t = h.mouseButtons.LEFT;
                    break;
                case 1:
                    t = h.mouseButtons.MIDDLE;
                    break;
                case 2:
                    t = h.mouseButtons.RIGHT;
                    break;
                default:
                    t = -1
                }
                switch (t) {
                case MOUSE.DOLLY:
                    if (!1 === h.enableZoom)
                        return;
                    !function(e) {
                        T.set(e.clientX, e.clientY)
                    }(e),
                    p = d.DOLLY;
                    break;
                case MOUSE.ROTATE:
                    if (e.ctrlKey || e.metaKey || e.shiftKey) {
                        if (!1 === h.enablePan)
                            return;
                        U(e),
                        p = d.PAN
                    } else {
                        if (!1 === h.enableRotate)
                            return;
                        z(e),
                        p = d.ROTATE
                    }
                    break;
                case MOUSE.PAN:
                    if (e.ctrlKey || e.metaKey || e.shiftKey) {
                        if (!1 === h.enableRotate)
                            return;
                        z(e),
                        p = d.ROTATE
                    } else {
                        if (!1 === h.enablePan)
                            return;
                        U(e),
                        p = d.PAN
                    }
                    break;
                default:
                    p = d.NONE
                }
                p !== d.NONE && h.dispatchEvent(_startEvent)
            }(e))
        }
        function X(e) {
            !1 !== h.enabled && ("touch" === e.pointerType ? function(e) {
                switch (te(e),
                p) {
                case d.TOUCH_ROTATE:
                    if (!1 === h.enableRotate)
                        return;
                    W(e),
                    h.update();
                    break;
                case d.TOUCH_PAN:
                    if (!1 === h.enablePan)
                        return;
                    $(e),
                    h.update();
                    break;
                case d.TOUCH_DOLLY_PAN:
                    if (!1 === h.enableZoom && !1 === h.enablePan)
                        return;
                    !function(e) {
                        h.enableZoom && j(e),
                        h.enablePan && $(e)
                    }(e),
                    h.update();
                    break;
                case d.TOUCH_DOLLY_ROTATE:
                    if (!1 === h.enableZoom && !1 === h.enableRotate)
                        return;
                    !function(e) {
                        h.enableZoom && j(e),
                        h.enableRotate && W(e)
                    }(e),
                    h.update();
                    break;
                default:
                    p = d.NONE
                }
            }(e) : function(e) {
                if (!1 !== h.enabled)
                    switch (p) {
                    case d.ROTATE:
                        if (!1 === h.enableRotate)
                            return;
                        !function(e) {
                            x.set(e.clientX, e.clientY),
                            b.subVectors(x, y).multiplyScalar(h.rotateSpeed);
                            var t = h.domElement;
                            L(2 * Math.PI * b.x / t.clientHeight),
                            R(2 * Math.PI * b.y / t.clientHeight),
                            y.copy(x),
                            h.update()
                        }(e);
                        break;
                    case d.DOLLY:
                        if (!1 === h.enableZoom)
                            return;
                        !function(e) {
                            C.set(e.clientX, e.clientY),
                            E.subVectors(C, T),
                            E.y > 0 ? F(k()) : E.y < 0 && B(k()),
                            T.copy(C),
                            h.update()
                        }(e);
                        break;
                    case d.PAN:
                        if (!1 === h.enablePan)
                            return;
                        !function(e) {
                            w.set(e.clientX, e.clientY),
                            M.subVectors(w, S).multiplyScalar(h.panSpeed),
                            N(M.x, M.y),
                            S.copy(w),
                            h.update()
                        }(e)
                    }
            }(e))
        }
        function Y(e) {
            ee(e),
            0 === P.length && (h.domElement.releasePointerCapture(e.pointerId),
            h.domElement.removeEventListener("pointermove", X),
            h.domElement.removeEventListener("pointerup", Y)),
            h.dispatchEvent(_endEvent),
            p = d.NONE
        }
        function K(e) {
            ee(e)
        }
        function Z(e) {
            !1 !== h.enabled && !1 !== h.enableZoom && p === d.NONE && (h.dispatchEvent(_startEvent),
            function(e) {
                e.deltaY < 0 ? B(k()) : e.deltaY > 0 && F(k()),
                h.update()
            }(e),
            h.dispatchEvent(_endEvent))
        }
        function J(e) {
            !1 !== h.enabled && !1 !== h.enablePan && function(e) {
                var t = !1;
                switch (e.code) {
                case h.keys.UP:
                    N(0, h.keyPanSpeed),
                    t = !0;
                    break;
                case h.keys.BOTTOM:
                    N(0, -h.keyPanSpeed),
                    t = !0;
                    break;
                case h.keys.LEFT:
                    N(h.keyPanSpeed, 0),
                    t = !0;
                    break;
                case h.keys.RIGHT:
                    N(-h.keyPanSpeed, 0),
                    t = !0
                }
                t && (e.preventDefault(),
                h.update())
            }(e)
        }
        function Q(e) {
            h.enabled
        }
        function ee(e) {
            delete A[e.pointerId];
            for (var t = 0; t < P.length; t++)
                if (P[t].pointerId == e.pointerId)
                    return void P.splice(t, 1)
        }
        function te(e) {
            var t = A[e.pointerId];
            void 0 === t && (t = new Vector2,
            A[e.pointerId] = t),
            t.set(e.pageX, e.pageY)
        }
        function re(e) {
            var t = e.pointerId === P[0].pointerId ? P[1] : P[0];
            return A[t.pointerId]
        }
        return h.domElement.addEventListener("contextmenu", Q),
        h.domElement.addEventListener("pointerdown", q),
        h.domElement.addEventListener("pointercancel", K),
        h.domElement.addEventListener("wheel", Z, {
            passive: !1
        }),
        n.update(),
        n
    }
    return _createClass(r)
}()
  , DeviceOrientationControls = function() {
    function e(t) {
        _classCallCheck(this, e),
        _defineProperty(this, "object", null),
        _defineProperty(this, "enabled", !0),
        _defineProperty(this, "hasValue", !1),
        _defineProperty(this, "deviceOrientation", {}),
        _defineProperty(this, "screenOrientation", 0),
        _defineProperty(this, "alphaOffset", 0),
        _defineProperty(this, "zee", new Vector3(0,0,1)),
        _defineProperty(this, "euler", new Euler),
        _defineProperty(this, "q0", new Quaternion),
        _defineProperty(this, "q1", new Quaternion(-Math.sqrt(.5),0,0,Math.sqrt(.5))),
        _defineProperty(this, "_onBoundDeviceOrientationChangeEvent", void 0),
        _defineProperty(this, "_onBoundScreenOrientationChangeEvent", void 0),
        this.object = t,
        this.object.rotation.reorder("YXZ"),
        this._onBoundDeviceOrientationChangeEvent = this._onDeviceOrientationChangeEvent.bind(this),
        this._onBoundScreenOrientationChangeEvent = this._onScreenOrientationChangeEvent.bind(this),
        this.connect()
    }
    return _createClass(e, [{
        key: "_onDeviceOrientationChangeEvent",
        value: function(e) {
            this.deviceOrientation = e
        }
    }, {
        key: "_onScreenOrientationChangeEvent",
        value: function() {
            this.screenOrientation = window.orientation || 0
        }
    }, {
        key: "setObjectQuaternion",
        value: function(e, t, r, i, n) {
            this.euler.set(r, t, -i, "YXZ"),
            e.setFromEuler(this.euler),
            e.multiply(this.q1),
            e.multiply(this.q0.setFromAxisAngle(this.zee, -n))
        }
    }, {
        key: "connect",
        value: function() {
            this._onBoundScreenOrientationChangeEvent(),
            void 0 !== window.DeviceOrientationEvent && "function" == typeof window.DeviceOrientationEvent.requestPermission ? window.DeviceOrientationEvent.requestPermission().then((function(e) {
                "granted" == e && (window.addEventListener("orientationchange", this._onBoundScreenOrientationChangeEvent, !1),
                window.addEventListener("deviceorientation", this._onBoundDeviceOrientationChangeEvent, !1))
            }
            )).catch((function(e) {}
            )) : (window.addEventListener("orientationchange", this._onBoundScreenOrientationChangeEvent, !1),
            window.addEventListener("deviceorientation", this._onBoundDeviceOrientationChangeEvent, !1)),
            this.enabled = !0
        }
    }, {
        key: "disconnect",
        value: function() {
            window.removeEventListener("orientationchange", this._onBoundScreenOrientationChangeEvent, !1),
            window.removeEventListener("deviceorientation", this._onBoundDeviceOrientationChangeEvent, !1),
            this.enabled = !1
        }
    }, {
        key: "update",
        value: function() {
            if (!1 !== this.enabled) {
                var e = this.deviceOrientation;
                if (e) {
                    var t = e.alpha ? MathUtils$1.degToRad(e.alpha) + this.alphaOffset : 0
                      , r = e.beta ? MathUtils$1.degToRad(e.beta) : 0
                      , i = e.gamma ? MathUtils$1.degToRad(e.gamma) : 0
                      , n = this.screenOrientation ? MathUtils$1.degToRad(this.screenOrientation) : 0;
                    this.setObjectQuaternion(this.object.quaternion, t, r, i, n),
                    this.hasValue = e.alpha && e.beta && e.gamma
                }
            }
        }
    }, {
        key: "dispose",
        value: function() {
            this.disconnect()
        }
    }]),
    e
}()
  , CameraControls = function() {
    function e() {
        _classCallCheck(this, e),
        _defineProperty(this, "useOrbitControls", !0)
    }
    return _createClass(e, [{
        key: "preInit",
        value: function(e) {
            var t = this;
            this.DEFAULT_CAMERA_POSITION = new Vector3(0,9,15),
            this.DEFAULT_LOOKAT_POSITION = new Vector3(0,1,0),
            this._brownianMotion = null,
            this._orbitControls = null,
            this._orbitCamera = null,
            this._camera = null,
            this._deviceOrientationControls = null,
            this._baseDeviceControlQuaternion = null,
            this._targetDeviceControlQuaternion = null,
            this._deviceOrientationCamera = null,
            this._hasDeviceOrientationControlValues = !1,
            this._q = new Quaternion,
            this._e = new Euler,
            this._v1 = new Vector3,
            this._v2 = new Vector3,
            this._camera = properties.camera,
            this._camera.position.copy(this.DEFAULT_CAMERA_POSITION),
            this._brownianMotion = new BrownianMotion,
            !0 === this.useOrbitControls && (this._orbitCamera = this._camera.clone(),
            this._orbitControls = new OrbitControls(this._orbitCamera,properties.canvas),
            this._orbitControls.enableDamping = !0,
            this._orbitControls.target0.copy(this.DEFAULT_LOOKAT_POSITION),
            this._orbitControls.reset()),
            browser.isMobile && (this._deviceOrientationCamera = new Camera,
            this._baseDeviceControlQuaternion = new Quaternion,
            this._targetDeviceControlQuaternion = new Quaternion,
            this._deviceOrientationControls = new DeviceOrientationControls(this._deviceOrientationCamera),
            properties.onFirstClicked.addOnce((function() {
                t._deviceOrientationControls.connect()
            }
            )))
        }
    }, {
        key: "init",
        value: function() {}
    }, {
        key: "resize",
        value: function(e, t) {}
    }, {
        key: "update",
        value: function(e) {
            if (this._camera.matrix.identity(),
            this._camera.matrix.decompose(this._camera.position, this._camera.quaternion, this._camera.scale),
            this._camera.position.copy(this.DEFAULT_CAMERA_POSITION),
            this._camera.lookAt(this.DEFAULT_LOOKAT_POSITION),
            browser.isMobile && this._deviceOrientationControls.update(),
            !0 === this.useOrbitControls && (this._orbitControls.update(),
            this._orbitCamera.updateMatrix(),
            this._orbitCamera.matrix.decompose(this._camera.position, this._camera.quaternion, this._camera.scale)),
            this._v1.set(0, 0, -1).applyQuaternion(this._camera.quaternion),
            !0 === this.useOrbitControls ? this.cameraDistance = this._v2.copy(this._orbitControls.target).sub(this._camera.position).dot(this._v1) : this.cameraDistance = this._v2.copy(this.DEFAULT_LOOKAT_POSITION).sub(this._camera.position).dot(this._v1),
            browser.isMobile)
                this._deviceOrientationControls.update(),
                this._deviceOrientationControls.hasValue && (this._hasDeviceOrientationControlValues || (this._targetDeviceControlQuaternion.copy(this._deviceOrientationCamera.quaternion),
                this._baseDeviceControlQuaternion.copy(this._deviceOrientationCamera.quaternion)),
                this._targetDeviceControlQuaternion.slerp(this._deviceOrientationCamera.quaternion, .08),
                this._baseDeviceControlQuaternion.slerp(this._targetDeviceControlQuaternion, .08),
                this._q.copy(this._baseDeviceControlQuaternion).invert().multiply(this._targetDeviceControlQuaternion),
                this._hasDeviceOrientationControlValues = !0,
                this._camera.quaternion.multiply(this._q));
            else {
                this._camera.translateZ(-1 * this.cameraDistance);
                var t = input.mouseXY.y * properties.cameraLookStrength
                  , r = -input.mouseXY.x * properties.cameraLookStrength;
                properties.cameraLookX += (t - properties.cameraLookX) * properties.cameraLookEaseDamp,
                properties.cameraLookY += (r - properties.cameraLookY) * properties.cameraLookEaseDamp,
                this._e.set(properties.cameraLookX, properties.cameraLookY, 0),
                this._q.setFromEuler(this._e),
                this._camera.quaternion.multiply(this._q),
                this._camera.translateZ(this.cameraDistance)
            }
            this._camera.matrix.compose(this._camera.position, this._camera.quaternion, this._camera.scale),
            this._brownianMotion.positionAmplitude = properties.cameraShakePositionStrength,
            this._brownianMotion.positionFrequency = properties.cameraShakePositionSpeed,
            this._brownianMotion.rotationAmplitude = properties.cameraShakeRotationStrength,
            this._brownianMotion.rotationFrequency = properties.cameraShakeRotationSpeed,
            this._brownianMotion.update(e),
            this._camera.matrix.multiply(this._brownianMotion.matrix),
            this._camera.matrix.decompose(this._camera.position, this._camera.quaternion, this._camera.scale),
            this._v1.set(0, 0, -1).applyQuaternion(this._camera.quaternion),
            properties.cameraDistance = this._v2.copy(this._orbitControls.target).sub(this._camera.position).dot(this._v1)
        }
    }]),
    e
}()
  , cameraControls = new CameraControls
  , _v1$1 = new Vector3;
new Vector3;
var _q = new Quaternion
  , ThirdControls = function() {
    function e() {
        _classCallCheck(this, e),
        _defineProperty(this, "dialPosition", new Vector2),
        _defineProperty(this, "velocity", new Vector3),
        _defineProperty(this, "offset", new Vector3),
        _defineProperty(this, "domControlsDial", document.querySelector(".btn-dial")),
        _defineProperty(this, "domControlsKnob", document.querySelector(".btn-dial-knob")),
        _defineProperty(this, "_downId", -1),
        _defineProperty(this, "_dialRect", void 0),
        _defineProperty(this, "_dialX", 0),
        _defineProperty(this, "_dialY", 0),
        _defineProperty(this, "_dialXEase", 0),
        _defineProperty(this, "_dialYEase", 0),
        _defineProperty(this, "_dragRadius", 70)
    }
    return _createClass(e, [{
        key: "init",
        value: function() {
            var e = this;
            this.domControlsDial.addEventListener("pointerdown", (function(t) {
                e._downId = t.pointerId,
                e._dialX = math.clamp((t.clientX - e._dialRect.left - e._dialRect.width / 2) / e._dragRadius, -1, 1),
                e._dialY = math.clamp(-(t.clientY - e._dialRect.top - e._dialRect.height / 2) / e._dragRadius, -1, 1)
            }
            )),
            document.addEventListener("pointermove", (function(t) {
                e._downId === t.pointerId && (e._dialX = math.clamp((t.clientX - e._dialRect.left - e._dialRect.width / 2) / e._dragRadius, -1, 1),
                e._dialY = math.clamp(-(t.clientY - e._dialRect.top - e._dialRect.height / 2) / e._dragRadius, -1, 1))
            }
            )),
            document.addEventListener("pointerup", (function(t) {
                e._downId === t.pointerId && (e._downId = -1,
                e._dialX = 0,
                e._dialY = 0)
            }
            )),
            this.resize(properties.rawWidth, properties.rawHeight)
        }
    }, {
        key: "resize",
        value: function(e, t) {
            this._getBoundingClientRect()
        }
    }, {
        key: "update",
        value: function(e) {
            this._dialRect && 0 === this._dialRect.width && this._getBoundingClientRect();
            var t = input.pressedKeys
              , r = this.dialPosition;
            if (this.offset.set(0, 0, 0),
            t.KeyW || t.ArrowUp || t.KeyS || t.ArrowDown || t.KeyA || t.ArrowLeft || t.KeyD || t.ArrowRight)
                (t.KeyW || t.ArrowUp) && (r.y += 1),
                (t.KeyS || t.ArrowDown) && (r.y -= 1),
                (t.KeyA || t.ArrowLeft) && (r.x -= 1),
                (t.KeyD || t.ArrowRight) && (r.x += 1),
                r.x = math.clamp(r.x, -1, 1),
                r.y = math.clamp(r.y, -1, 1),
                r.length() > 0 && r.normalize();
            else if (this._dialRect) {
                if (r.x = this._dialX,
                r.y = this._dialY,
                this._dialXEase -= .2 * (this._dialXEase - this._dialX),
                this._dialYEase -= .2 * (this._dialYEase - this._dialY),
                r.length() > 0) {
                    var i = Math.min(1, r.length());
                    r.normalize().multiplyScalar(i)
                }
            } else
                r.set(0, 0);
            this._dialRect && (this.domControlsKnob.style.transform = "translate3d(" + this._dialXEase * this._dragRadius + "px, " + -this._dialYEase * this._dragRadius + "px, 0)"),
            this.velocity.multiplyScalar(Math.pow(.15, e)),
            _q.copy(properties.camera.quaternion),
            _v1$1.set(r.x, r.y, 0).applyQuaternion(_q),
            _v1$1.y = 0,
            _v1$1.length() > 0 && (_v1$1.normalize(),
            _v1$1.multiplyScalar(e * math.fit(properties.startRatio, .75, 1, 0, 12)),
            this.velocity.add(_v1$1)),
            _v1$1.copy(this.velocity).multiplyScalar(e),
            this.offset.add(_v1$1)
        }
    }, {
        key: "_getBoundingClientRect",
        value: function() {
            browser.isMobile && (this._dialRect = this.domControlsDial.getBoundingClientRect())
        }
    }]),
    e
}()
  , thirdControls = new ThirdControls
  , Support = function() {
    function e() {
        _classCallCheck(this, e)
    }
    return _createClass(e, [{
        key: "isSupported",
        value: function() {
            var e;
            return properties._isSupportedDevice = !0,
            properties._isSupportedBrowser = (browser.isChrome || browser.isSafari || browser.isEdge || browser.isFirefox || browser.isOpera) && !browser.isIE,
            properties._isSupportedWebGL = this.checkSupportWebGL(),
            browser.isMobile && this.checkSupportMobileOrientation(),
            !1 === (e = (!0 === settings.IS_API_MODE || properties._isSupportedDevice && properties._isSupportedBrowser) && properties._isSupportedWebGL) && this.notSupported(),
            e
        }
    }, {
        key: "notSupported",
        value: function() {
            properties._isSupportedDevice ? properties._isSupportedBrowser ? properties._isSupportedWebGL || this._addNotSupported("webgl") : this._addNotSupported("browser") : this._addNotSupported("device")
        }
    }, {
        key: "checkSupportWebGL",
        value: function() {
            if (!(properties.canvas instanceof HTMLCanvasElement))
                return !1;
            if (settings.USE_WEBGL2 && window.WebGL2RenderingContext)
                try {
                    return properties.gl = properties.canvas.getContext("webgl2", properties.webglOpts),
                    settings.RENDER_TARGET_FLOAT_TYPE = browser.isIOS ? HalfFloatType : FloatType,
                    settings.DATA_FLOAT_TYPE = FloatType,
                    !0
                } catch (t) {
                    return console.error(t),
                    !1
                }
            if (settings.USE_WEBGL2 = !1,
            window.WebGLRenderingContext)
                try {
                    var e = properties.gl = properties.canvas.getContext("webgl", properties.webglOpts) || properties.canvas.getContext("experimental-webgl", properties.webglOpts);
                    return (e.getExtension("OES_texture_float") || e.getExtension("OES_texture_half_float")) && e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS) ? (settings.RENDER_TARGET_FLOAT_TYPE = browser.isIOS || !e.getExtension("OES_texture_float") ? HalfFloatType : FloatType,
                    settings.DATA_FLOAT_TYPE = FloatType,
                    !0) : (settings.USE_FLOAT_PACKING = !0,
                    settings.RENDER_TARGET_FLOAT_TYPE = settings.DATA_FLOAT_TYPE = UnsignedByteType,
                    !1)
                } catch (t) {
                    return console.error(t),
                    !1
                }
            return !1
        }
    }, {
        key: "checkSupportMobileOrientation",
        value: function() {
            var e = this
              , t = window.matchMedia("(orientation: portrait)")
              , r = function(t) {
                var r = t.matches ? "portrait" : "landscape";
                "portrait" === r ? properties._isSupportedMobileOrientation = !0 : "landscape" === r && (properties._isSupportedMobileOrientation = !1),
                properties._isSupported && !properties._isSupportedMobileOrientation ? e._addNotSupported("orientation") : e._removeNotSupported("orientation")
            };
            window.addEventListener("load", (function() {
                r(t)
            }
            )),
            t.addEventListener("change", (function(e) {
                r(e)
            }
            ))
        }
    }, {
        key: "_removeNotSupported",
        value: function(e) {
            properties._isSupported && document.documentElement.classList.remove("not-supported"),
            e && document.documentElement.classList.remove("not-supported--".concat(e))
        }
    }, {
        key: "_addNotSupported",
        value: function(e) {
            return console.error(new Error("[".concat(settings.GLOBAL_ID, "]: NOT SUPPORTED (").concat(e.toUpperCase(), ")"))),
            !0 === settings.IS_API_MODE ? void 0 : (document.documentElement.classList.add("not-supported"),
            void (e && document.documentElement.classList.add("not-supported--".concat(e))))
        }
    }]),
    e
}()
  , support = new Support
  , Lights = function() {
    function e() {
        _classCallCheck(this, e),
        _defineProperty(this, "container", new Object3D),
        _defineProperty(this, "colorHex1", "#7777ff"),
        _defineProperty(this, "colorHex2", "#ff7777"),
        _defineProperty(this, "color1", new Color),
        _defineProperty(this, "color2", new Color),
        _defineProperty(this, "spotLight", void 0),
        _defineProperty(this, "spotLightTarget", void 0),
        _defineProperty(this, "brownianMotion", void 0)
    }
    return _createClass(e, [{
        key: "preInit",
        value: function() {
            ShaderChunk.lights_fragment_begin = ShaderChunk.lights_fragment_begin.replace(", spotLightShadow.shadowBias,", ", spotLightShadow.shadowBias - blueNoise.z * 0.0001,"),
            ShaderChunk.lights_fragment_begin = ShaderChunk.lights_fragment_begin.replace("vSpotShadowCoord[ i ]", "vSpotShadowCoord[ i ] + vec4((blueNoise.xy - 0.5)/1024.0 * 25.0, 0.0, 0.0)"),
            this.spotLight = new SpotLight(16777215,1,30,60 / 180 * Math.PI,1),
            this.spotLight.position.set(0, 8, 0),
            this.spotLight.castShadow = !0,
            this.spotLight.shadow.mapSize.width = 512,
            this.spotLight.shadow.mapSize.height = 512,
            this.spotLight.shadow.camera.near = 1,
            this.spotLight.shadow.camera.far = 50,
            this.spotLight.shadow.bias = -1e-4,
            this.container.add(this.spotLight),
            this.spotLightTarget = this.spotLight.target,
            this.container.add(this.spotLightTarget),
            this.brownianMotion = new BrownianMotion
        }
    }, {
        key: "init",
        value: function() {}
    }, {
        key: "resize",
        value: function(e, t) {}
    }, {
        key: "update",
        value: function(e) {
            this.brownianMotion.positionAmplitude = 1,
            this.brownianMotion.positionFrequency = .5,
            this.brownianMotion.update(e),
            this.color1.setStyle(this.colorHex1),
            this.color2.setStyle(this.colorHex2),
            this.spotLight.intensity = 3 * Math.max(0, .75 + this.brownianMotion._position.x),
            this.spotLight.color.copy(this.color1).lerp(this.color2, math.smoothstep(-.25, .25, this.brownianMotion._position.y))
        }
    }]),
    e
}()
  , lights = new Lights
  , legPositionVert = "#define GLSLIFY 1\nattribute vec3 position;attribute vec3 footPosition;attribute vec4 footQuaternion;attribute vec3 jointPosition;attribute vec3 jointDirection;attribute float activeRatio;attribute float legIndex;uniform float u_legCount;varying vec3 v_footPosition;varying vec4 v_footQuaternion;varying vec3 v_jointPosition;varying vec3 v_jointDirection;varying float v_activeRatio;varying float v_legIndex;varying vec2 v_baseUv;void main(){vec2 pos=position.xy;pos.y=(pos.y+legIndex)/u_legCount;gl_Position=vec4(pos*2.0-1.0,0.0,1.0);v_footPosition=footPosition;v_footQuaternion=footQuaternion;v_jointPosition=jointPosition;v_jointDirection=jointDirection;v_activeRatio=activeRatio;v_legIndex=legIndex;v_baseUv=position.xy;}"
  , legPositionFrag = "#define GLSLIFY 1\nuniform sampler2D u_baseLegPositionTexture;uniform float u_legCount;uniform float u_tentaclePerLegCount;uniform float u_tentacleNodeCount;uniform vec2 u_simTexelSize;uniform float u_time;uniform float u_loopTimeStrength;varying vec3 v_footPosition;varying vec4 v_footQuaternion;varying vec3 v_jointPosition;varying vec3 v_jointDirection;varying float v_activeRatio;varying float v_legIndex;varying vec2 v_baseUv;vec3 getQBezierPos(vec3 a,vec3 b,vec3 c,float t){float ti=1.0-t;return ti*ti*a+2.0*ti*t*b+t*t*c;}vec3 qrotate(vec4 q,vec3 v){return v+2.0*cross(q.xyz,cross(q.xyz,v)+q.w*v);}vec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}float mod289(float x){return x-floor(x*(1.0/289.0))*289.0;}vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}float permute(float x){return mod289(((x*34.0)+1.0)*x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}float taylorInvSqrt(float r){return 1.79284291400159-0.85373472095314*r;}vec4 grad4(float j,vec4 ip){const vec4 ones=vec4(1.0,1.0,1.0,-1.0);vec4 p,s;p.xyz=floor(fract(vec3(j)*ip.xyz)*7.0)*ip.z-1.0;p.w=1.5-dot(abs(p.xyz),ones.xyz);s=vec4(lessThan(p,vec4(0.0)));p.xyz=p.xyz+(s.xyz*2.0-1.0)*s.www;return p;}\n#define F4 0.309016994374947451\nvec4 simplexNoiseDerivatives(vec4 v_0){const vec4 C=vec4(0.138196601125011,0.276393202250021,0.414589803375032,-0.447213595499958);vec4 i=floor(v_0+dot(v_0,vec4(F4)));vec4 x0=v_0-i+dot(i,C.xxxx);vec4 i0;vec3 isX=step(x0.yzw,x0.xxx);vec3 isYZ=step(x0.zww,x0.yyz);i0.x=isX.x+isX.y+isX.z;i0.yzw=1.0-isX;i0.y+=isYZ.x+isYZ.y;i0.zw+=1.0-isYZ.xy;i0.z+=isYZ.z;i0.w+=1.0-isYZ.z;vec4 i3=clamp(i0,0.0,1.0);vec4 i2=clamp(i0-1.0,0.0,1.0);vec4 i1=clamp(i0-2.0,0.0,1.0);vec4 x1=x0-i1+C.xxxx;vec4 x2=x0-i2+C.yyyy;vec4 x3=x0-i3+C.zzzz;vec4 x4=x0+C.wwww;i=mod289(i);float j0=permute(permute(permute(permute(i.w)+i.z)+i.y)+i.x);vec4 j1=permute(permute(permute(permute(i.w+vec4(i1.w,i2.w,i3.w,1.0))+i.z+vec4(i1.z,i2.z,i3.z,1.0))+i.y+vec4(i1.y,i2.y,i3.y,1.0))+i.x+vec4(i1.x,i2.x,i3.x,1.0));vec4 ip=vec4(1.0/294.0,1.0/49.0,1.0/7.0,0.0);vec4 p0=grad4(j0,ip);vec4 p1=grad4(j1.x,ip);vec4 p2=grad4(j1.y,ip);vec4 p3=grad4(j1.z,ip);vec4 p4=grad4(j1.w,ip);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;p4*=taylorInvSqrt(dot(p4,p4));vec3 values0=vec3(dot(p0,x0),dot(p1,x1),dot(p2,x2));vec2 values1=vec2(dot(p3,x3),dot(p4,x4));vec3 m0=max(0.5-vec3(dot(x0,x0),dot(x1,x1),dot(x2,x2)),0.0);vec2 m1=max(0.5-vec2(dot(x3,x3),dot(x4,x4)),0.0);vec3 temp0=-6.0*m0*m0*values0;vec2 temp1=-6.0*m1*m1*values1;vec3 mmm0=m0*m0*m0;vec2 mmm1=m1*m1*m1;float dx=temp0[0]*x0.x+temp0[1]*x1.x+temp0[2]*x2.x+temp1[0]*x3.x+temp1[1]*x4.x+mmm0[0]*p0.x+mmm0[1]*p1.x+mmm0[2]*p2.x+mmm1[0]*p3.x+mmm1[1]*p4.x;float dy=temp0[0]*x0.y+temp0[1]*x1.y+temp0[2]*x2.y+temp1[0]*x3.y+temp1[1]*x4.y+mmm0[0]*p0.y+mmm0[1]*p1.y+mmm0[2]*p2.y+mmm1[0]*p3.y+mmm1[1]*p4.y;float dz=temp0[0]*x0.z+temp0[1]*x1.z+temp0[2]*x2.z+temp1[0]*x3.z+temp1[1]*x4.z+mmm0[0]*p0.z+mmm0[1]*p1.z+mmm0[2]*p2.z+mmm1[0]*p3.z+mmm1[1]*p4.z;float dw=temp0[0]*x0.w+temp0[1]*x1.w+temp0[2]*x2.w+temp1[0]*x3.w+temp1[1]*x4.w+mmm0[0]*p0.w+mmm0[1]*p1.w+mmm0[2]*p2.w+mmm1[0]*p3.w+mmm1[1]*p4.w;return vec4(dx,dy,dz,dw)*49.0;}vec3 curl(in vec3 p,in float noiseTime,in float persistence){vec4 xNoisePotentialDerivatives=vec4(0.0);vec4 yNoisePotentialDerivatives=vec4(0.0);vec4 zNoisePotentialDerivatives=vec4(0.0);for(int i=0;i<2;++i){float twoPowI=pow(2.0,float(i));float scale=0.5*twoPowI*pow(persistence,float(i));xNoisePotentialDerivatives+=simplexNoiseDerivatives(vec4(p*twoPowI,noiseTime))*scale;yNoisePotentialDerivatives+=simplexNoiseDerivatives(vec4((p+vec3(123.4,129845.6,-1239.1))*twoPowI,noiseTime))*scale;zNoisePotentialDerivatives+=simplexNoiseDerivatives(vec4((p+vec3(-9519.0,9051.0,-123.0))*twoPowI,noiseTime))*scale;}return vec3(zNoisePotentialDerivatives[1]-yNoisePotentialDerivatives[2],xNoisePotentialDerivatives[2]-zNoisePotentialDerivatives[0],yNoisePotentialDerivatives[0]-xNoisePotentialDerivatives[1]);}vec4 hash42(vec2 p){vec4 p4=fract(vec4(p.xyxy)*vec4(.1031,.1030,.0973,.1099));p4+=dot(p4,p4.wzxy+33.33);return fract((p4.xxyz+p4.yzzw)*p4.zywx);}float cUnMix(float a,float b,float v){return clamp((v-a)/(b-a),0.0,1.0);}void main(){float tentaclePositionRatio=v_baseUv.x*v_activeRatio;vec4 tentacleRands=hash42(vec2(v_baseUv.y,0.0));vec3 fromDir=v_jointDirection;vec3 toDir=vec3(0.0,1.0,0.0);float dist=length(v_footPosition-v_jointPosition);vec3 midPos=(v_jointPosition+v_footPosition+mix(fromDir*(1.0-tentaclePositionRatio)*(1.0+1.0*tentacleRands.x+u_loopTimeStrength*sin(u_time*(tentacleRands.z+1.0)+tentacleRands.y*6.2831853)*0.75),toDir,v_activeRatio*mix(0.25,0.5,tentacleRands.w))*dist)*0.5;vec3 basePosition=texture2D(u_baseLegPositionTexture,vec2(tentaclePositionRatio,v_baseUv.y)).xyz;basePosition=qrotate(v_footQuaternion,basePosition*8.0);basePosition.y*=cUnMix(0.7,1.0,v_activeRatio);basePosition+=v_footPosition;vec3 pos=getQBezierPos(v_jointPosition,midPos,v_footPosition,tentaclePositionRatio);vec3 noise=curl(vec3(v_baseUv.y*100.0,-tentaclePositionRatio,v_legIndex*100.0),tentaclePositionRatio*2.0-v_activeRatio-u_time*mix(0.1,0.75,v_baseUv.y),0.02)*0.1*cUnMix(0.0,0.2,tentaclePositionRatio)*cUnMix(1.0,0.5,tentaclePositionRatio)*u_loopTimeStrength;pos+=noise;float blendBasePositionRatio=cUnMix(0.85,1.0,smoothstep(0.0,0.85,tentaclePositionRatio));pos=mix(pos,basePosition,blendBasePositionRatio);gl_FragColor=vec4(pos,length(noise));}"
  , legRotationVert = "#define GLSLIFY 1\nattribute vec3 position;attribute float legIndex;uniform float u_legCount;uniform float u_iteration;uniform vec2 u_simTexelSize;varying vec2 v_uv;void main(){vec2 pos=vec2(position.x*u_simTexelSize.x+1.0-(u_iteration+1.0)*u_simTexelSize.x,(position.y+legIndex)/u_legCount);gl_Position=vec4(pos*2.0-1.0,0.0,1.0);v_uv=pos;}"
  , legRotationFrag = "#define GLSLIFY 1\nuniform sampler2D u_positionTexture;uniform sampler2D u_rotationTexture;uniform vec2 u_simTexelSize;uniform float u_iteration;varying vec2 v_uv;vec3 getQBezierPos(vec3 a,vec3 b,vec3 c,float t){float ti=1.0-t;return ti*ti*a+2.0*ti*t*b+t*t*c;}vec3 qrotate(vec4 q,vec3 v){return v+2.0*cross(q.xyz,cross(q.xyz,v)+q.w*v);}void main(){vec3 prevNodePos=texture2D(u_positionTexture,v_uv+vec2(-u_simTexelSize.x*2.0,0.0)).xyz;vec3 nextNodePos=texture2D(u_positionTexture,v_uv+vec2(u_simTexelSize.x*2.0,0.0)).xyz;vec3 T=normalize(nextNodePos-prevNodePos);vec3 N;if(u_iteration<0.5){vec3 toDir=vec3(0.0,1.0,0.0);N=toDir;}else{N=texture2D(u_rotationTexture,v_uv+vec2(u_simTexelSize.x,0.0)).xyz;}vec3 B=normalize(cross(N,T));N=normalize(cross(T,B));gl_FragColor=vec4(N,1.0);}"
  , legsTransformShader = "#define GLSLIFY 1\nuniform sampler2D u_positionTexture;uniform sampler2D u_rotationTexture;uniform vec2 u_simTexelSize;attribute vec2 instanceUvOffset;float calcMonsterLegTransform(out vec3 pos,out mat3 TBN){vec2 simUv=vec2(position.x,0.5*u_simTexelSize.y)+instanceUvOffset;vec4 nodeInfo=texture2D(u_positionTexture,simUv);vec3 splinePos=nodeInfo.xyz;vec3 prevNodePos=texture2D(u_positionTexture,simUv+vec2(-u_simTexelSize.x,0.0)).xyz;vec3 nextNodePos=texture2D(u_positionTexture,simUv+vec2(u_simTexelSize.x,0.0)).xyz;vec3 T=normalize(nextNodePos-prevNodePos);vec3 N=texture2D(u_rotationTexture,simUv).xyz;vec3 B=normalize(cross(N,T));TBN=mat3(T,B,N);float tentacleRatio=(simUv.x-u_simTexelSize.x*0.5)/(1.0-u_simTexelSize.x);pos=TBN*vec3(0.0,position.y,position.z)*mix(0.125,0.08,tentacleRatio*tentacleRatio)*smoothstep(1.0,0.75,tentacleRatio)+splinePos;return tentacleRatio;}"
  , legsVert = "#define GLSLIFY 1\n#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\nvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#include <calcMonsterLegTransform>\nvoid main(){vec3 pos;mat3 TBN;float tentacleRatio=calcMonsterLegTransform(pos,TBN);\n#include <uv_vertex>\n#include <uv2_vertex>\n#include <color_vertex>\n#include <morphcolor_vertex>\nvec3 objectNormal=TBN*normal;\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#include <normal_vertex>\nvec3 transformed=pos;\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\nvViewPosition=-mvPosition.xyz;\n#include <worldpos_vertex>\n#include <shadowmap_vertex>\n#include <fog_vertex>\n#ifdef USE_TRANSMISSION\nvWorldPosition=worldPosition.xyz;\n#endif\n}"
  , legsFrag = "#define GLSLIFY 1\nvec3 blueNoise;\n#define STANDARD\n#ifdef PHYSICAL\n#define IOR\n#define SPECULAR\n#endif\nuniform vec3 diffuse;uniform vec3 emissive;uniform float roughness;uniform float metalness;uniform float opacity;\n#ifdef IOR\nuniform float ior;\n#endif\n#ifdef SPECULAR\nuniform float specularIntensity;uniform vec3 specularColor;\n#ifdef USE_SPECULARINTENSITYMAP\nuniform sampler2D specularIntensityMap;\n#endif\n#ifdef USE_SPECULARCOLORMAP\nuniform sampler2D specularColorMap;\n#endif\n#endif\n#ifdef USE_CLEARCOAT\nuniform float clearcoat;uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\nuniform vec3 sheenColor;uniform float sheenRoughness;\n#ifdef USE_SHEENCOLORMAP\nuniform sampler2D sheenColorMap;\n#endif\n#ifdef USE_SHEENROUGHNESSMAP\nuniform sampler2D sheenRoughnessMap;\n#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#include <getBlueNoise>\nvoid main(){blueNoise=getBlueNoise(gl_FragCoord.xy);\n#include <clipping_planes_fragment>\nvec4 diffuseColor=vec4(diffuse,opacity);ReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));vec3 totalEmissiveRadiance=emissive;\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <color_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <roughnessmap_fragment>\n#include <metalnessmap_fragment>\n#include <normal_fragment_begin>\n#include <normal_fragment_maps>\n#include <clearcoat_normal_fragment_begin>\n#include <clearcoat_normal_fragment_maps>\n#include <emissivemap_fragment>\n#include <lights_physical_fragment>\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#include <aomap_fragment>\nvec3 totalDiffuse=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse;vec3 totalSpecular=reflectedLight.directSpecular+reflectedLight.indirectSpecular;\n#include <transmission_fragment>\nvec3 outgoingLight=totalDiffuse+totalSpecular+totalEmissiveRadiance;\n#ifdef USE_SHEEN\nfloat sheenEnergyComp=1.0-0.157*max3(material.sheenColor);outgoingLight=outgoingLight*sheenEnergyComp+sheenSpecular;\n#endif\n#ifdef USE_CLEARCOAT\nfloat dotNVcc=saturate(dot(geometry.clearcoatNormal,geometry.viewDir));vec3 Fcc=F_Schlick(material.clearcoatF0,material.clearcoatF90,dotNVcc);outgoingLight=outgoingLight*(1.0-material.clearcoat*Fcc)+clearcoatSpecular*material.clearcoat;\n#endif\n#include <output_fragment>\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n#include <dithering_fragment>\n}"
  , legsDepthVert = "#define GLSLIFY 1\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\n#include <calcMonsterLegTransform>\nvoid main(){vec3 pos;mat3 TBN;float tentacleRatio=calcMonsterLegTransform(pos,TBN);\n#include <uv_vertex>\n#include <skinbase_vertex>\n#ifdef USE_DISPLACEMENTMAP\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinnormal_vertex>\n#endif\nvec3 transformed=pos;\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\nvHighPrecisionZW=gl_Position.zw;}"
  , legsDepthFrag = "#define GLSLIFY 1\n#if DEPTH_PACKING == 3200\nuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;void main(){\n#include <clipping_planes_fragment>\nvec4 diffuseColor=vec4(1.0);\n#if DEPTH_PACKING == 3200\ndiffuseColor.a=opacity;\n#endif\n#include <map_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <logdepthbuf_fragment>\nfloat fragCoordZ=0.5*vHighPrecisionZW[0]/vHighPrecisionZW[1]+0.5;\n#if DEPTH_PACKING == 3200\ngl_FragColor=vec4(vec3(1.0-fragCoordZ),opacity);\n#elif DEPTH_PACKING == 3201\ngl_FragColor=packDepthToRGBA(fragCoordZ);\n#endif\n}"
  , AUDIO_DATA = {
    ui: [{
        id: "hover_0",
        url: "hover_0.mp3",
        isLoopable: !1,
        isPositional: !1,
        isPreload: !0,
        isElem: !1
    }, {
        id: "hover_1",
        url: "hover_1.mp3",
        isLoopable: !1,
        isPositional: !1,
        isPreload: !0,
        isElem: !1
    }],
    sfx: [{
        id: "step_0",
        url: "step_0.mp3",
        isLoopable: !1,
        isPositional: !0,
        isPreload: !0,
        isElem: !1
    }, {
        id: "step_1",
        url: "step_1.mp3",
        isLoopable: !1,
        isPositional: !0,
        isPreload: !0,
        isElem: !1
    }, {
        id: "step_2",
        url: "step_2.mp3",
        isLoopable: !1,
        isPositional: !0,
        isPreload: !0,
        isElem: !1
    }, {
        id: "step_3",
        url: "step_3.mp3",
        isLoopable: !1,
        isPositional: !0,
        isPreload: !0,
        isElem: !1
    }, {
        id: "step_4",
        url: "step_4.mp3",
        isLoopable: !1,
        isPositional: !0,
        isPreload: !0,
        isElem: !1
    }, {
        id: "step_5",
        url: "step_5.mp3",
        isLoopable: !1,
        isPositional: !0,
        isPreload: !0,
        isElem: !1
    }, {
        id: "step_6",
        url: "step_6.mp3",
        isLoopable: !1,
        isPositional: !0,
        isPreload: !0,
        isElem: !1
    }, {
        id: "step_7",
        url: "step_7.mp3",
        isLoopable: !1,
        isPositional: !0,
        isPreload: !0,
        isElem: !1
    }],
    music: [{
        id: "bgm",
        url: "bgm.mp3",
        isLoopable: !0,
        isPositional: !1,
        isPreload: !1,
        isElem: !0
    }]
}
  , AudioGroup = function() {
    function e() {
        _classCallCheck(this, e),
        _defineProperty(this, "id", ""),
        _defineProperty(this, "children", []),
        _defineProperty(this, "volume", 1)
    }
    return _createClass(e, [{
        key: "init",
        value: function(e) {
            Object.assign(this, e)
        }
    }, {
        key: "update",
        value: function(e) {
            e *= this.volume,
            this.children.forEach((function(t) {
                t.setFinalVolume(e)
            }
            ))
        }
    }, {
        key: "add",
        value: function(e) {
            this.children.includes(e) || this.children.push(e)
        }
    }, {
        key: "remove",
        value: function(e) {
            this.children.includes(e) && this.children.splice(this.children.indexOf(e), 1)
        }
    }, {
        key: "play",
        value: function() {
            this.children.forEach((function(e) {
                return e.play()
            }
            ))
        }
    }, {
        key: "stop",
        value: function() {
            this.children.forEach((function(e) {
                return e.stop()
            }
            ))
        }
    }]),
    e
}()
  , AudioItem = function() {
    function e() {
        _classCallCheck(this, e),
        _defineProperty(this, "autoplay", !1),
        _defineProperty(this, "elem", null),
        _defineProperty(this, "id", ""),
        _defineProperty(this, "url", ""),
        _defineProperty(this, "fileSize", 100),
        _defineProperty(this, "isMutable", !1),
        _defineProperty(this, "isPositional", !1),
        _defineProperty(this, "isLoopable", !1),
        _defineProperty(this, "isPreload", !0),
        _defineProperty(this, "onInitialized", new MinSignal$2),
        _defineProperty(this, "onEnded", new MinSignal$2),
        _defineProperty(this, "onPlayed", new MinSignal$2),
        _defineProperty(this, "volume", 1),
        _defineProperty(this, "audioObject", null),
        _defineProperty(this, "hasInitialized", !1),
        _defineProperty(this, "container", null),
        _defineProperty(this, "refDistance", 1),
        _defineProperty(this, "_buffer", null),
        _defineProperty(this, "_originalOnEnd", null)
    }
    return _createClass(e, [{
        key: "preInit",
        value: function(e) {
            Object.assign(this, e),
            this.isPositional && (this.container = new Object3D)
        }
    }, {
        key: "init",
        value: function(e) {
            !0 !== this.hasInitialized && (this.hasInitialized = !0,
            this.audioObject = this.isPositional ? new PositionalAudio(e) : new Audio$1(e),
            this.isPositional && this.container.add(this.audioObject),
            this._originalOnEnd = this.audioObject.onEnded.bind(this.audioObject),
            this.audioObject.onEnded = this.onEnd.bind(this),
            this.isPositional && this.setRefDistance(this.refDistance),
            this.isElem && !this.elem && (this.elem = document.createElement("audio"),
            this.elem.src = this.url),
            this.elem ? (this.elem.loop = this.isLoopable,
            this.audioObject.setMediaElementSource(this.elem),
            this.elem.addEventListener("ended", this.onEnd.bind(this)),
            this.autoplay && this.play()) : (this.audioObject.setLoop(this.isLoopable),
            this._buffer && this.decodeAudioData()),
            this.onInitialized.dispatch(this))
        }
    }, {
        key: "load",
        value: function(e) {
            var t = this;
            if (this.elem)
                this.elem.src = this.url;
            else {
                var r = this.isPreload ? "add" : "load";
                properties.loader[r](this.url, {
                    weight: this.fileSize,
                    type: "xhr",
                    responseType: "arraybuffer",
                    hasLoading: !0,
                    onLoad: function(r) {
                        t._buffer = r,
                        t.hasInitialized && t.decodeAudioData(),
                        e && e()
                    }
                })
            }
        }
    }, {
        key: "setFinalVolume",
        value: function(e) {
            var t;
            null === (t = this.audioObject) || void 0 === t || t.setVolume(e * this.volume)
        }
    }, {
        key: "setPositionObjectParent",
        value: function(e) {
            this.hasInitialized ? e ? e.add(this.audioObject) : this.audioObject.parent && this.audioObject.parent.remove(this.audioObject) : this.positionObjectParent = e
        }
    }, {
        key: "decodeAudioData",
        value: function() {
            var e = this
              , t = this._buffer.slice(0);
            AudioContext.getContext().decodeAudioData(t, (function(t) {
                e.audioObject.setBuffer(t),
                e.autoplay && e.play()
            }
            ))
        }
    }, {
        key: "onEnd",
        value: function() {
            this._originalOnEnd && this._originalOnEnd(),
            this.onEnded.dispatch(this)
        }
    }, {
        key: "play",
        value: function() {
            this.autoplay = !0,
            this.audioObject && !this.audioObject.isPlaying && (this.elem ? (this.elem.play(),
            this.elem.currentTime = .01,
            this.audioObject.isPlaying = !0) : this.audioObject.play(),
            this.onPlayed.dispatch(this))
        }
    }, {
        key: "stop",
        value: function() {
            this.autoplay = !1,
            this.audioObject && this.audioObject.isPlaying && (this.elem ? (this.elem.pause(),
            this.audioObject.isPlaying = !1) : this.audioObject.stop(),
            this.onEnded.dispatch(this))
        }
    }, {
        key: "setRefDistance",
        value: function(e) {
            this.refDistance = e,
            this.isPositional && this.audioObject && this.audioObject.setRefDistance(this.refDistance)
        }
    }]),
    e
}()
  , Audios = function() {
    function e() {
        _classCallCheck(this, e),
        _defineProperty(this, "groups", {}),
        _defineProperty(this, "items", {}),
        _defineProperty(this, "isActive", !0),
        _defineProperty(this, "activeRatio", 0),
        _defineProperty(this, "volume", 0),
        _defineProperty(this, "listener", null),
        _defineProperty(this, "_boundOnBodyClick", null),
        _defineProperty(this, "_onBodyClicked", new MinSignal$2),
        _defineProperty(this, "_onRolloverCount", -1)
    }
    return _createClass(e, [{
        key: "preInit",
        value: function() {
            var e = this;
            this._boundOnBodyClick = function() {
                return e._onBodyClick()
            }
            ,
            input.onDowned.add(this._boundOnBodyClick);
            var t = function(t) {
                var r = new AudioGroup
                  , i = AUDIO_DATA[t];
                r.init({
                    id: t
                }),
                e.groups[t] = r,
                i.forEach((function(r) {
                    var i = new AudioItem;
                    r.url = settings.AUDIO_PATH + r.url,
                    i.preInit(r),
                    i.load((function() {}
                    )),
                    e.items[r.id] = i,
                    e.groups[t].add(i)
                }
                ))
            };
            for (var r in AUDIO_DATA)
                t(r);
            properties.onToggleAudio.add((function(t) {
                e.isActive = t
            }
            ))
        }
    }, {
        key: "init",
        value: function() {
            var e = this;
            this.getListener((function(t) {
                for (var r in e.items)
                    e.items[r].init(t)
            }
            )),
            this.items.bgm.play()
        }
    }, {
        key: "update",
        value: function(e) {
            if (properties.isAudioActive = this.isActive,
            properties.audioActiveRatio = this.activeRatio,
            this.activeRatio = math.saturate(this.activeRatio + (!0 === this.isActive ? 1 : -1) * (2 * e)),
            this.listener)
                for (var t in this.volume = math.saturate(this.volume + (this.isActive ? 1 : -1) * e * .5),
                this.groups)
                    this.groups[t].update(this.volume)
        }
    }, {
        key: "getListener",
        value: function(e) {
            this.listener ? e(this.listener) : this._onBodyClicked.add(e)
        }
    }, {
        key: "_onBodyClick",
        value: function() {
            input.onDowned.remove(this._boundOnBodyClick),
            this.listener = new AudioListener,
            this._onBodyClicked.dispatch(this.listener),
            properties.camera.add(this.listener)
        }
    }, {
        key: "playRollover",
        value: function() {
            this._onRolloverCount = (this._onRolloverCount + 1) % 2,
            this.items["hover_" + this._onRolloverCount].play()
        }
    }]),
    e
}()
  , audios = new Audios
  , _q1 = new Quaternion;
new Quaternion;
var _v1 = new Vector3
  , _v2 = new Vector3;
new Vector3;
var _e = new Euler
  , Monster = function() {
    function e() {
        _classCallCheck(this, e),
        _defineProperty(this, "container", new Object3D),
        _defineProperty(this, "velocity", new Vector3),
        _defineProperty(this, "position", new Vector3),
        _defineProperty(this, "colorHex1", "#5555ff"),
        _defineProperty(this, "colorHex2", "#ff0000"),
        _defineProperty(this, "color1", new Color),
        _defineProperty(this, "color2", new Color),
        _defineProperty(this, "mesh", null),
        _defineProperty(this, "texture", null),
        _defineProperty(this, "LEG_COUNT", 28),
        _defineProperty(this, "TENTACLE_PER_LEG_COUNT", 16),
        _defineProperty(this, "TENTACLE_NODE_COUNT", 64),
        _defineProperty(this, "positionRenderTarget", void 0),
        _defineProperty(this, "prevNormalRenderTarget", void 0),
        _defineProperty(this, "currNormalRenderTarget", void 0),
        _defineProperty(this, "lineMesh", void 0),
        _defineProperty(this, "legsMesh", void 0),
        _defineProperty(this, "positionMesh", void 0),
        _defineProperty(this, "rotationMesh", void 0),
        _defineProperty(this, "rotationMergeMaterial", void 0),
        _defineProperty(this, "footPositionAttribute", void 0),
        _defineProperty(this, "footQuaternionAttribute", void 0),
        _defineProperty(this, "jointPositionAttribute", void 0),
        _defineProperty(this, "jointDirectionAttribute", void 0),
        _defineProperty(this, "activeRatioAttribute", void 0),
        _defineProperty(this, "brownianMotion", void 0),
        _defineProperty(this, "bodyMesh", void 0),
        _defineProperty(this, "bodyMeshPos", void 0),
        _defineProperty(this, "bodyMeshQuat", void 0),
        _defineProperty(this, "bodyControl", void 0),
        _defineProperty(this, "isFirstUpdate", !0),
        _defineProperty(this, "stepAudioItems", []),
        _defineProperty(this, "sharedUniforms", {
            u_baseLegPositionTexture: {
                value: null
            },
            u_positionTexture: {
                value: null
            },
            u_rotationTexture: {
                value: null
            },
            u_legCount: {
                value: null
            },
            u_tentaclePerLegCount: {
                value: null
            },
            u_tentacleNodeCount: {
                value: null
            },
            u_simTexelSize: {
                value: null
            },
            u_loopTime: {
                value: 0
            },
            u_loopTimeStrength: {
                value: 0
            }
        }),
        _defineProperty(this, "loopTimeDirection", 1),
        _defineProperty(this, "lastStepAudioPlayTime", -1),
        _defineProperty(this, "stepAudioIndex", -1),
        _defineProperty(this, "STEP_AUDIO_MAX", 8),
        _defineProperty(this, "HALF_LOOP_TIME_MAX", 90),
        _defineProperty(this, "legs", []),
        _defineProperty(this, "seedRandom", math.getSeedRandomFn("monster7"))
    }
    return _createClass(e, [{
        key: "preInit",
        value: function() {
            var e = this;
            shaderHelper.addChunk("calcMonsterLegTransform", legsTransformShader),
            this.brownianMotion = new BrownianMotion,
            this.bodyMeshPos = new Vector3,
            this.bodyMeshQuat = new Quaternion,
            this.bodyMesh = new Object3D,
            this.bodyMesh.position.y = 2,
            this.container.add(this.bodyMesh),
            this.sharedUniforms.u_legCount.value = this.LEG_COUNT,
            this.sharedUniforms.u_tentaclePerLegCount.value = this.TENTACLE_PER_LEG_COUNT,
            this.sharedUniforms.u_tentacleNodeCount.value = this.TENTACLE_NODE_COUNT,
            this.sharedUniforms.u_simTexelSize.value = new Vector2(1 / this.TENTACLE_NODE_COUNT,1 / (this.TENTACLE_PER_LEG_COUNT * this.LEG_COUNT)),
            this.footPositionAttribute = new InstancedBufferAttribute(new Float32Array(3 * this.LEG_COUNT),3),
            this.footQuaternionAttribute = new InstancedBufferAttribute(new Float32Array(4 * this.LEG_COUNT),4),
            this.jointPositionAttribute = new InstancedBufferAttribute(new Float32Array(3 * this.LEG_COUNT),3),
            this.jointDirectionAttribute = new InstancedBufferAttribute(new Float32Array(3 * this.LEG_COUNT),3),
            this.activeRatioAttribute = new InstancedBufferAttribute(new Float32Array(1 * this.LEG_COUNT),1),
            properties.loader.add(settings.MODEL_PATH + "leg.buf", {
                onLoad: function(t) {
                    return e._onLegLoad(t)
                }
            });
            for (var t = 0; t < this.LEG_COUNT; t++)
                this.legs.push({
                    needsUpdate: !0,
                    activeRatio: 0,
                    angle: 0,
                    disConnectDist: 5 + 3 * this.seedRandom(),
                    speed: 1 + 2 * this.seedRandom(),
                    footQuaternion: new Quaternion,
                    footPosition: new Vector3,
                    jointPosition: new Vector3,
                    jointQuaternion: new Quaternion,
                    jointDirection: new Vector3(0,1,0),
                    jointDirectionVel: new Vector3,
                    rand: this.seedRandom()
                })
        }
    }, {
        key: "_onLegLoad",
        value: function(e) {
            this.positionRenderTarget = fboHelper.createRenderTarget(this.TENTACLE_NODE_COUNT, this.TENTACLE_PER_LEG_COUNT * this.LEG_COUNT, !0, !0),
            this.prevNormalRenderTarget = fboHelper.createRenderTarget(this.TENTACLE_NODE_COUNT, this.TENTACLE_PER_LEG_COUNT * this.LEG_COUNT, !0, !0),
            this.currNormalRenderTarget = fboHelper.createRenderTarget(this.TENTACLE_NODE_COUNT, this.TENTACLE_PER_LEG_COUNT * this.LEG_COUNT, !0, !0),
            this.sharedUniforms.u_positionTexture.value = this.positionRenderTarget.texture;
            for (var t = e.attributes.position.array, r = new Float32Array(t.length / 3 * 4), i = 0, n = t.length / 3; i < n; i++)
                r[4 * i + 0] = t[3 * i + 0],
                r[4 * i + 1] = t[3 * i + 1],
                r[4 * i + 2] = t[3 * i + 2],
                r[4 * i + 3] = 1;
            this.sharedUniforms.u_baseLegPositionTexture.value = fboHelper.createDataTexture(r, this.TENTACLE_NODE_COUNT, this.TENTACLE_PER_LEG_COUNT, !0, !0);
            var a = new PlaneGeometry(1,1).translate(.5, .5, 0)
              , o = new InstancedBufferGeometry;
            for (var s in a.attributes)
                o.setAttribute(s, a.attributes[s]);
            for (var l = new Uint8Array(this.LEG_COUNT), u = 0; u < this.LEG_COUNT; u++)
                l[u] = u;
            o.setIndex(a.index),
            o.setAttribute("footPosition", this.footPositionAttribute),
            o.setAttribute("footQuaternion", this.footQuaternionAttribute),
            o.setAttribute("jointPosition", this.jointPositionAttribute),
            o.setAttribute("jointDirection", this.jointDirectionAttribute),
            o.setAttribute("activeRatio", this.activeRatioAttribute),
            o.setAttribute("legIndex", new InstancedBufferAttribute(l,1)),
            this.positionMesh = new Mesh(o,fboHelper.createRawShaderMaterial({
                uniforms: {
                    u_baseLegPositionTexture: this.sharedUniforms.u_baseLegPositionTexture,
                    u_legCount: this.sharedUniforms.u_legCount,
                    u_tentaclePerLegCount: this.sharedUniforms.u_tentaclePerLegCount,
                    u_tentacleNodeCount: this.sharedUniforms.u_tentacleNodeCount,
                    u_simTexelSize: this.sharedUniforms.u_simTexelSize,
                    u_time: this.sharedUniforms.u_loopTime,
                    u_loopTimeStrength: this.sharedUniforms.u_loopTimeStrength
                },
                vertexShader: legPositionVert,
                fragmentShader: legPositionFrag
            })),
            this.positionMesh.frustumCulled = !1,
            this.rotationMesh = new Mesh(o,fboHelper.createRawShaderMaterial({
                uniforms: {
                    u_positionTexture: this.sharedUniforms.u_positionTexture,
                    u_rotationTexture: this.sharedUniforms.u_rotationTexture,
                    u_legCount: this.sharedUniforms.u_legCount,
                    u_simTexelSize: this.sharedUniforms.u_simTexelSize,
                    u_iteration: {
                        value: 0
                    }
                },
                vertexShader: legRotationVert,
                fragmentShader: legRotationFrag
            })),
            this.rotationMesh.frustumCulled = !1,
            this.rotationMergeMaterial = fboHelper.createRawShaderMaterial({
                uniforms: {
                    u_texture: this.sharedUniforms.u_rotationTexture
                },
                blending: CustomBlending,
                blendEquation: AddEquation,
                blendSrc: OneFactor,
                blendDst: OneFactor,
                blendEquationAlpha: AddEquation,
                blendSrcAlpha: OneFactor,
                blendDstAlpha: OneFactor
            })
        }
    }, {
        key: "init",
        value: function() {
            for (var e = this.TENTACLE_PER_LEG_COUNT * this.LEG_COUNT, t = new Float32Array(2 * e), r = 0; r < e; r++)
                t[2 * r + 1] = r / e;
            var i = new InstancedBufferGeometry
              , n = new CylinderGeometry(.5,.5,1,4,this.TENTACLE_NODE_COUNT - 1).translate(0, .5, 0).scale(1, (this.TENTACLE_NODE_COUNT - 1) / this.TENTACLE_NODE_COUNT, 1).translate(0, .5 / this.TENTACLE_NODE_COUNT, 0).rotateZ(-Math.PI / 2);
            for (var a in n.attributes)
                i.setAttribute(a, n.attributes[a]);
            i.setIndex(n.index),
            i.setAttribute("instanceUvOffset", new InstancedBufferAttribute(t,2));
            var o = new MeshPhysicalMaterial({
                color: this.color1,
                roughness: browser.mobile ? .08 : .9,
                clearcoat: browser.mobile ? 0 : 1,
                clearcoatRoughness: .08,
                sheen: 2,
                sheenColor: this.color2,
                sheenRoughness: .85
            });
            o.color = this.color1,
            o.sheenColor = this.color2,
            this.legsMesh = new Mesh(i,o),
            o.type = "ShaderMaterial",
            o.uniforms = Object.assign(UniformsUtils.merge([ShaderLib.physical.uniforms]), {
                u_positionTexture: this.sharedUniforms.u_positionTexture,
                u_rotationTexture: this.sharedUniforms.u_rotationTexture,
                u_simTexelSize: this.sharedUniforms.u_simTexelSize
            }),
            Object.assign(o.uniforms, blueNoise.sharedUniforms),
            Object.assign(o, {
                vertexShader: legsVert,
                fragmentShader: legsFrag
            });
            var s = new MeshDepthMaterial({
                depthPacking: RGBADepthPacking
            });
            s.type = "ShaderMaterial",
            s.uniforms = Object.assign(UniformsUtils.merge([ShaderLib.depth.uniforms]), {
                u_positionTexture: this.sharedUniforms.u_positionTexture,
                u_rotationTexture: this.sharedUniforms.u_rotationTexture,
                u_simTexelSize: this.sharedUniforms.u_simTexelSize
            }),
            Object.assign(s, {
                vertexShader: legsDepthVert,
                fragmentShader: legsDepthFrag
            }),
            this.legsMesh.customDepthMaterial = s,
            this.legsMesh.frustumCulled = !1,
            this.legsMesh.castShadow = !0,
            this.legsMesh.receiveShadow = !0,
            this.legsMesh.renderOrder = -1,
            this.container.add(this.legsMesh);
            for (var l = 0; l < this.STEP_AUDIO_MAX; l++) {
                var u = audios.items["step_" + l];
                this.stepAudioItems[l] = u,
                this.container.add(u.container)
            }
        }
    }, {
        key: "resize",
        value: function(e, t) {}
    }, {
        key: "update",
        value: function(e) {
            if (properties.hasInitialized) {
                var t = this.footPositionAttribute.array
                  , r = this.footQuaternionAttribute.array
                  , i = this.jointPositionAttribute.array
                  , n = this.jointDirectionAttribute.array
                  , a = this.activeRatioAttribute.array;
                this.brownianMotion.positionAmplitude = 1,
                this.brownianMotion.positionFrequency = .5,
                this.brownianMotion.rotationAmplitude = 1.5,
                this.brownianMotion.rotationFrequency = .8,
                this.brownianMotion.update(e),
                this.bodyMeshPos.copy(this.bodyMesh.position).add(this.brownianMotion._position),
                this.bodyMeshPos.z += math.mix(-18, 0, properties.startRatio),
                this.bodyMeshQuat.copy(this.bodyMesh.quaternion).multiply(this.brownianMotion._rotation),
                this.sharedUniforms.u_loopTime.value = math.loop(this.sharedUniforms.u_loopTime.value + properties.deltaTime, -this.HALF_LOOP_TIME_MAX, this.HALF_LOOP_TIME_MAX),
                this.sharedUniforms.u_loopTimeStrength.value = math.smoothstep(this.HALF_LOOP_TIME_MAX, this.HALF_LOOP_TIME_MAX - 1, Math.abs(this.sharedUniforms.u_loopTime.value));
                for (var o = 0; o < this.LEG_COUNT; o++) {
                    var s = this.legs[o];
                    if (s.needsUpdate && 0 === s.activeRatio) {
                        s.needsUpdate = !1;
                        var l = (o / this.LEG_COUNT + this.seedRandom()) * Math.PI * 2;
                        if (s.angle = l,
                        _v1.set(this.bodyMeshPos.x, 0, this.bodyMeshPos.z),
                        s.footPosition.set(Math.cos(l), 0, Math.sin(l)).multiplyScalar(1 + 5 * this.seedRandom()).add(_v1).toArray(t, 3 * o),
                        _v1.set(0, 1, 0),
                        s.footQuaternion.setFromAxisAngle(_v1, this.seedRandom() * Math.PI * 2).toArray(r, 4 * o),
                        properties.time - this.lastStepAudioPlayTime > .1) {
                            this.lastStepAudioPlayTime = properties.time,
                            this.stepAudioIndex = (this.stepAudioIndex + 1) % this.STEP_AUDIO_MAX;
                            var u = this.stepAudioItems[this.stepAudioIndex];
                            u.play(),
                            u.container.position.copy(s.footPosition)
                        }
                    }
                    s.jointPosition.set(Math.cos(s.angle), 0, Math.sin(s.angle)).multiplyScalar(0).applyQuaternion(this.bodyMeshQuat),
                    s.jointPosition.add(this.bodyMeshPos),
                    s.jointPosition.toArray(i, 3 * o),
                    _v1.copy(s.jointPosition),
                    _v2.copy(s.footPosition),
                    _v1.y = 0,
                    _v2.y = 0;
                    var c = _v1.distanceTo(_v2);
                    _v1.copy(s.footPosition).sub(s.jointPosition),
                    _v1.y += 3 + 3 * math.smoothstep(1, .5, c / s.disConnectDist),
                    s.jointQuaternion.slerp(this.bodyMeshQuat, this.isFirstUpdate ? 1 : .1 + .5 * s.rand),
                    _v1.normalize().applyQuaternion(s.jointQuaternion),
                    this.isFirstUpdate && s.jointDirection.copy(_v1),
                    _q1.setFromUnitVectors(s.jointDirection, _v1),
                    _e.setFromQuaternion(_q1),
                    _v1.copy(_e).multiplyScalar(e),
                    s.jointDirectionVel.multiplyScalar(.8).add(_v1),
                    _v1.copy(s.jointDirectionVel).multiplyScalar(30 * e),
                    _e.x = _v1.x,
                    _e.y = _v1.y,
                    _e.z = _v1.z,
                    _q1.setFromEuler(_e),
                    s.jointDirection.applyQuaternion(_q1),
                    s.jointDirection.toArray(n, 3 * o),
                    c > s.disConnectDist ? (s.activeRatio = Math.max(0, s.activeRatio - e * s.speed * 1.5),
                    s.needsUpdate = !0) : (s.activeRatio = Math.min(1, s.activeRatio + e * s.speed),
                    s.needsUpdate = !1),
                    s.activeRatio = this.isFirstUpdate ? 1 : s.activeRatio,
                    a[o] = s.activeRatio
                }
                this.footPositionAttribute.needsUpdate = !0,
                this.footQuaternionAttribute.needsUpdate = !0,
                this.jointPositionAttribute.needsUpdate = !0,
                this.jointDirectionAttribute.needsUpdate = !0,
                this.activeRatioAttribute.needsUpdate = !0,
                fboHelper.renderMesh(this.positionMesh, this.positionRenderTarget);
                var h = fboHelper.getColorState();
                fboHelper.renderer.autoClear = !0;
                for (var d = 0; d < this.TENTACLE_NODE_COUNT; d++) {
                    d > 1 && (fboHelper.renderer.autoClear = !1);
                    var p = this.prevNormalRenderTarget;
                    this.prevNormalRenderTarget = this.currNormalRenderTarget,
                    this.currNormalRenderTarget = p,
                    this.sharedUniforms.u_rotationTexture.value = this.prevNormalRenderTarget.texture,
                    this.rotationMesh.material.uniforms.u_iteration.value = d,
                    fboHelper.renderMesh(this.rotationMesh, this.currNormalRenderTarget)
                }
                fboHelper.render(this.rotationMergeMaterial, this.currNormalRenderTarget),
                this.sharedUniforms.u_rotationTexture.value = this.currNormalRenderTarget.texture,
                fboHelper.setColorState(h),
                this.color1.setStyle(this.colorHex1),
                this.color2.setStyle(this.colorHex2),
                this.isFirstUpdate = !1
            }
        }
    }]),
    e
}()
  , monster = new Monster
  , GUI = function() {
    function e() {
        _classCallCheck(this, e)
    }
    return _createClass(e, [{
        key: "preInit",
        value: function() {
            window.dat && this._addTextureHelper()
        }
    }, {
        key: "init",
        value: function() {
            if (window.dat) {
                this._post();
                var e = (new dat.GUI).addFolder("mosnter");
                e.addColor(monster, "colorHex1"),
                e.addColor(monster, "colorHex2")
            }
        }
    }, {
        key: "_post",
        value: function() {
            var e = new dat.GUI;
            if (properties.bloom) {
                var t = e.addFolder("bloom");
                t.add(properties, "bloomAmount", 0, 5, 1e-5).listen(),
                t.add(properties, "bloomRadius", -1, 1, 1e-5).listen(),
                t.add(properties, "bloomThreshold", 0, 1, 1e-5).listen(),
                t.add(properties, "bloomSmoothWidth", 0, 2, 1e-5).listen(),
                t.add(properties, "haloWidth", 0, 2, 1e-5).listen(),
                t.add(properties, "haloRGBShift", 0, .2, 1e-5).listen(),
                t.add(properties, "haloStrength", 0, 3, 1e-5).listen(),
                t.add(properties, "haloMaskInner", 0, 1, 1e-5).listen(),
                t.add(properties, "haloMaskOuter", 0, 1, 1e-5).listen()
            }
            if (properties.final) {
                var r = e.addFolder("color");
                r.add(properties, "vignetteFrom", 0, 3, 1e-5).listen(),
                r.add(properties, "vignetteTo", 0, 3, 1e-5).listen(),
                r.addColor(properties, "vignetteColorHex").listen(),
                r.add(properties, "saturation", 0, 3, 1e-5).listen(),
                r.add(properties, "contrast", -1, 3, 1e-5).listen(),
                r.add(properties, "brightness", 0, 2, 1e-5).listen(),
                r.addColor(properties, "tintColorHex").listen(),
                r.add(properties, "tintOpacity", 0, 1, 1e-5).listen()
            }
            if (properties.bokeh) {
                var i = e.addFolder("bokeh");
                i.add(properties, "bokehAmount", 0, 1, 1e-5).listen(),
                i.add(properties, "bokehFNumber", 1e-4, 1, 1e-5).listen(),
                i.add(properties, "bokehFocusDistance", 0, 20, 1e-5).listen(),
                i.add(properties, "bokehFocalLength", 0, 3, 1e-5).listen(),
                i.add(properties, "bokehKFilmHeight", 1e-5, 90, 1e-5).listen(),
                i.add(properties.bokeh, "quality", 0, 3, 1).listen()
            }
            properties.cameraMotionBlur && e.addFolder("cameraMotionBlur").add(properties, "cameraMotionBlurAmount", 0, 3, 1e-5).listen();
            var n = e.addFolder("screenPaint");
            if (n.add(properties, "screenPaintNeedsMouseDown"),
            n.add(properties, "screenPaintMinRadius", 0, 200, 1).listen(),
            n.add(properties, "screenPaintMaxRadius", 0, 300, 1).listen(),
            n.add(properties, "screenPaintRadiusDistanceRange", 0, 300, 1).listen(),
            n.add(properties, "screenPaintPushStrength", 0, 100, 1e-5).listen(),
            n.add(properties, "screenPaintVelocityDissipation", 0, .999, 1e-5).listen(),
            n.add(properties, "screenPaintWeight1Dissipation", 0, .999, 1e-5).listen(),
            n.add(properties, "screenPaintWeight2Dissipation", 0, .999, 1e-5).listen(),
            n.add(properties, "screenPaintUseNoise"),
            n.add(properties, "screenPaintCurlScale", 0, .5, 1e-5).listen(),
            n.add(properties, "screenPaintCurlStrength", 0, 5, 1e-5).listen(),
            properties.screenPaintDistortion) {
                var a = e.addFolder("screenPaintDistortion");
                a.add(properties, "screenPaintDistortionAmount", 0, 100, 1e-5).listen(),
                a.add(properties, "screenPaintDistortionRGBShift", 0, 3, 1e-5).listen(),
                a.add(properties, "screenPaintDistortionMultiplier", 0, 3, 1e-5).listen()
            }
            e.addFolder("upscaler").add(properties, "upscalerSharpness", 0, 1, 1e-5).listen()
        }
    }, {
        key: "_addTextureHelper",
        value: function() {
            var e = dat.GUI.prototype.add;
            dat.GUI.prototype.add = function(t, r) {
                var i = t[r];
                if (i && i.isTexture) {
                    var n, a = function(e) {
                        l.onload = function() {
                            i.image = l,
                            i.needsUpdate = !0
                        }
                        ,
                        l.src = URL.createObjectURL(e)
                    }, o = function() {
                        if (!(+new Date - c < 100)) {
                            c = +new Date;
                            var e = document.createElement("input");
                            e.type = "file",
                            e.style.display = "none",
                            e.onchange = function() {
                                document.body.removeChild(e);
                                var t = e.files[0];
                                a(t)
                            }
                            ,
                            document.body.appendChild(e),
                            e.click()
                        }
                    }, s = function(e) {
                        e.stopPropagation(),
                        e.preventDefault()
                    }, l = new Image, u = {}, c = 0;
                    return l.src = i.image.src,
                    u[r] = o,
                    (n = e.call(this, u, r)).domElement.innerHTML = "",
                    n.domElement.appendChild(l),
                    l.style.width = l.style.height = "26px",
                    n.domElement.dragover = function(e) {
                        e.preventDefault()
                    }
                    ,
                    n.domElement.parentNode.parentNode.style.position = "relative",
                    n.domElement.parentNode.parentNode.ondragenter = n.domElement.parentNode.parentNode.ondragleave = n.domElement.parentNode.parentNode.ondragover = s,
                    n.domElement.parentNode.parentNode.addEventListener("drop", (function(e) {
                        e.stopPropagation(),
                        e.preventDefault();
                        var t = e.dataTransfer.files[0];
                        a(t)
                    }
                    )),
                    n
                }
                return e.apply(this, arguments)
            }
        }
    }]),
    e
}()
  , gui = new GUI
  , vert$1 = "#define GLSLIFY 1\n#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\nvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main(){\n#include <uv_vertex>\n#include <uv2_vertex>\n#include <color_vertex>\n#include <morphcolor_vertex>\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#include <normal_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\nvViewPosition=-mvPosition.xyz;\n#include <worldpos_vertex>\n#include <shadowmap_vertex>\n#include <fog_vertex>\n#ifdef USE_TRANSMISSION\nvWorldPosition=worldPosition.xyz;\n#endif\nvUv=worldPosition.xz*0.15;vUv2=vUv;}"
  , frag$1 = "#define GLSLIFY 1\nvec3 blueNoise;\n#define STANDARD\n#ifdef PHYSICAL\n#define IOR\n#define SPECULAR\n#endif\nuniform vec3 diffuse;uniform vec3 emissive;uniform float roughness;uniform float metalness;uniform float opacity;\n#ifdef IOR\nuniform float ior;\n#endif\n#ifdef SPECULAR\nuniform float specularIntensity;uniform vec3 specularColor;\n#ifdef USE_SPECULARINTENSITYMAP\nuniform sampler2D specularIntensityMap;\n#endif\n#ifdef USE_SPECULARCOLORMAP\nuniform sampler2D specularColorMap;\n#endif\n#endif\n#ifdef USE_CLEARCOAT\nuniform float clearcoat;uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\nuniform vec3 sheenColor;uniform float sheenRoughness;\n#ifdef USE_SHEENCOLORMAP\nuniform sampler2D sheenColorMap;\n#endif\n#ifdef USE_SHEENROUGHNESSMAP\nuniform sampler2D sheenRoughnessMap;\n#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nuniform sampler2D u_noiseTexture;\n#include <getBlueNoise>\nvoid main(){blueNoise=getBlueNoise(gl_FragCoord.xy);vec3 noise3=texture2D(u_noiseTexture,vUv*0.2).rgb;\n#include <clipping_planes_fragment>\nvec4 diffuseColor=vec4(diffuse,opacity);ReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));vec3 totalEmissiveRadiance=emissive;\n#include <logdepthbuf_fragment>\nvec4 sampledDiffuseColor=texture2D(map,vUv);diffuseColor*=sampledDiffuseColor;\n#include <color_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\nvec3 arm=texture2D(roughnessMap,vUv).rgb;float roughnessFactor=roughness;roughnessFactor*=arm.g*(0.2+noise3.y*0.7);float metalnessFactor=smoothstep(0.4,0.75,noise3.z);\n#include <normal_fragment_begin>\nvec3 mapN=texture2D(normalMap,vUv).xyz*2.0-1.0;mapN.xy*=normalScale;normal=perturbNormal2Arb(-vViewPosition,normal,mapN,faceDirection);\n#include <clearcoat_normal_fragment_begin>\n#include <clearcoat_normal_fragment_maps>\n#include <emissivemap_fragment>\n#include <lights_physical_fragment>\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\nfloat ambientOcclusion=(arm.r-1.0)*aoMapIntensity+1.0;reflectedLight.indirectDiffuse*=ambientOcclusion;\n#if defined( USE_ENVMAP ) && defined( STANDARD )\nfloat dotNV=saturate(dot(geometry.normal,geometry.viewDir));reflectedLight.indirectSpecular*=computeSpecularOcclusion(dotNV,ambientOcclusion,material.roughness);\n#endif\nvec3 totalDiffuse=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse;vec3 totalSpecular=reflectedLight.directSpecular+reflectedLight.indirectSpecular;\n#include <transmission_fragment>\nvec3 outgoingLight=totalDiffuse+totalSpecular+totalEmissiveRadiance;\n#ifdef USE_SHEEN\nfloat sheenEnergyComp=1.0-0.157*max3(material.sheenColor);outgoingLight=outgoingLight*sheenEnergyComp+sheenSpecular;\n#endif\n#ifdef USE_CLEARCOAT\nfloat dotNVcc=saturate(dot(geometry.clearcoatNormal,geometry.viewDir));vec3 Fcc=F_Schlick(material.clearcoatF0,material.clearcoatF90,dotNVcc);outgoingLight=outgoingLight*(1.0-material.clearcoat*Fcc)+clearcoatSpecular*material.clearcoat;\n#endif\n#include <output_fragment>\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n#include <dithering_fragment>\n}"
  , Ground = function() {
    function e() {
        _classCallCheck(this, e),
        _defineProperty(this, "container", new Object3D),
        _defineProperty(this, "mesh", void 0),
        _defineProperty(this, "normalMap1", void 0),
        _defineProperty(this, "armMap1", void 0),
        _defineProperty(this, "map1", void 0),
        _defineProperty(this, "noiseTexture", void 0)
    }
    return _createClass(e, [{
        key: "preInit",
        value: function() {
            this.normalMap1 = properties.loader.add(settings.TEXTURE_PATH + "ground/concrete_wall_005_nor_gl_1k.jpg", {
                type: "texture",
                wrap: RepeatWrapping
            }).content,
            this.armMap1 = properties.loader.add(settings.TEXTURE_PATH + "ground/concrete_wall_005_arm_1k.jpg", {
                type: "texture",
                wrap: RepeatWrapping
            }).content,
            this.map1 = properties.loader.add(settings.TEXTURE_PATH + "ground/concrete_wall_005_diff_1k.jpg", {
                type: "texture",
                wrap: RepeatWrapping
            }).content,
            this.noiseTexture = properties.loader.add(settings.TEXTURE_PATH + "noise.png", {
                type: "texture",
                wrap: RepeatWrapping
            }).content
        }
    }, {
        key: "init",
        value: function() {
            var e = new PlaneGeometry(300,300);
            e.rotateX(-Math.PI / 2),
            e.setAttribute("uv2", e.attributes.uv);
            var t = new MeshPhysicalMaterial({
                map: this.map1,
                normalMap: this.normalMap1,
                roughnessMap: this.armMap1,
                metalnessMap: this.armMap1,
                metalness: 1,
                aoMap: this.armMap1,
                normalScale: new Vector2(2,2)
            });
            this.mesh = new Mesh(e,t),
            t.type = "ShaderMaterial",
            t.uniforms = Object.assign(UniformsUtils.merge([ShaderLib.physical.uniforms]), {
                u_noiseTexture: {
                    value: this.noiseTexture
                }
            }),
            Object.assign(t.uniforms, blueNoise.sharedUniforms),
            Object.assign(t, {
                vertexShader: vert$1,
                fragmentShader: frag$1
            }),
            this.mesh.frustumCulled = !1,
            this.mesh.receiveShadow = !0,
            this.container.add(this.mesh)
        }
    }, {
        key: "resize",
        value: function(e, t) {}
    }, {
        key: "update",
        value: function(e) {}
    }]),
    e
}()
  , ground = new Ground
  , vert = "#define GLSLIFY 1\nattribute vec4 a_rands;attribute vec3 a_position;uniform float u_time;uniform float u_opacity;uniform vec2 u_offset;uniform float u_cameraDistance;varying vec2 v_uv;varying float v_blurRatio;varying float v_opacity;vec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}float mod289(float x){return x-floor(x*(1.0/289.0))*289.0;}vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}float permute(float x){return mod289(((x*34.0)+1.0)*x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}float taylorInvSqrt(float r){return 1.79284291400159-0.85373472095314*r;}vec4 grad4(float j,vec4 ip){const vec4 ones=vec4(1.0,1.0,1.0,-1.0);vec4 p,s;p.xyz=floor(fract(vec3(j)*ip.xyz)*7.0)*ip.z-1.0;p.w=1.5-dot(abs(p.xyz),ones.xyz);s=vec4(lessThan(p,vec4(0.0)));p.xyz=p.xyz+(s.xyz*2.0-1.0)*s.www;return p;}\n#define F4 0.309016994374947451\nvec4 simplexNoiseDerivatives(vec4 v){const vec4 C=vec4(0.138196601125011,0.276393202250021,0.414589803375032,-0.447213595499958);vec4 i=floor(v+dot(v,vec4(F4)));vec4 x0=v-i+dot(i,C.xxxx);vec4 i0;vec3 isX=step(x0.yzw,x0.xxx);vec3 isYZ=step(x0.zww,x0.yyz);i0.x=isX.x+isX.y+isX.z;i0.yzw=1.0-isX;i0.y+=isYZ.x+isYZ.y;i0.zw+=1.0-isYZ.xy;i0.z+=isYZ.z;i0.w+=1.0-isYZ.z;vec4 i3=clamp(i0,0.0,1.0);vec4 i2=clamp(i0-1.0,0.0,1.0);vec4 i1=clamp(i0-2.0,0.0,1.0);vec4 x1=x0-i1+C.xxxx;vec4 x2=x0-i2+C.yyyy;vec4 x3=x0-i3+C.zzzz;vec4 x4=x0+C.wwww;i=mod289(i);float j0=permute(permute(permute(permute(i.w)+i.z)+i.y)+i.x);vec4 j1=permute(permute(permute(permute(i.w+vec4(i1.w,i2.w,i3.w,1.0))+i.z+vec4(i1.z,i2.z,i3.z,1.0))+i.y+vec4(i1.y,i2.y,i3.y,1.0))+i.x+vec4(i1.x,i2.x,i3.x,1.0));vec4 ip=vec4(1.0/294.0,1.0/49.0,1.0/7.0,0.0);vec4 p0=grad4(j0,ip);vec4 p1=grad4(j1.x,ip);vec4 p2=grad4(j1.y,ip);vec4 p3=grad4(j1.z,ip);vec4 p4=grad4(j1.w,ip);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;p4*=taylorInvSqrt(dot(p4,p4));vec3 values0=vec3(dot(p0,x0),dot(p1,x1),dot(p2,x2));vec2 values1=vec2(dot(p3,x3),dot(p4,x4));vec3 m0=max(0.5-vec3(dot(x0,x0),dot(x1,x1),dot(x2,x2)),0.0);vec2 m1=max(0.5-vec2(dot(x3,x3),dot(x4,x4)),0.0);vec3 temp0=-6.0*m0*m0*values0;vec2 temp1=-6.0*m1*m1*values1;vec3 mmm0=m0*m0*m0;vec2 mmm1=m1*m1*m1;float dx=temp0[0]*x0.x+temp0[1]*x1.x+temp0[2]*x2.x+temp1[0]*x3.x+temp1[1]*x4.x+mmm0[0]*p0.x+mmm0[1]*p1.x+mmm0[2]*p2.x+mmm1[0]*p3.x+mmm1[1]*p4.x;float dy=temp0[0]*x0.y+temp0[1]*x1.y+temp0[2]*x2.y+temp1[0]*x3.y+temp1[1]*x4.y+mmm0[0]*p0.y+mmm0[1]*p1.y+mmm0[2]*p2.y+mmm1[0]*p3.y+mmm1[1]*p4.y;float dz=temp0[0]*x0.z+temp0[1]*x1.z+temp0[2]*x2.z+temp1[0]*x3.z+temp1[1]*x4.z+mmm0[0]*p0.z+mmm0[1]*p1.z+mmm0[2]*p2.z+mmm1[0]*p3.z+mmm1[1]*p4.z;float dw=temp0[0]*x0.w+temp0[1]*x1.w+temp0[2]*x2.w+temp1[0]*x3.w+temp1[1]*x4.w+mmm0[0]*p0.w+mmm0[1]*p1.w+mmm0[2]*p2.w+mmm1[0]*p3.w+mmm1[1]*p4.w;return vec4(dx,dy,dz,dw)*49.0;}void main(){vec3 pos=a_position;vec3 noiseDirection=vec3(0.5*cos(0.1*u_time),sin(0.05*u_time),0.25);vec3 noise=0.65*noiseDirection*simplexNoiseDerivatives(vec4(0.8*pos,0.05*u_time)).xyz;noise+=0.4*noiseDirection*simplexNoiseDerivatives(vec4(1.12*pos+10.0,0.03*u_time)).xyz;pos+=noise;pos.xz+=(-pos.xz+u_offset+20.0)-mod(-pos.xz+u_offset+20.0,40.0);vec4 mvPosition=modelViewMatrix*vec4(pos,1.0);float blurRatio=smoothstep(0.0,12.0,abs(-mvPosition.z-u_cameraDistance));float scale=0.05*(3.0+blurRatio*blurRatio*16.0);vec3 positionRotated=position.xyz;mvPosition.xyz+=position.xyz*scale;gl_Position=projectionMatrix*mvPosition;v_opacity=u_opacity*a_rands.x*pow(smoothstep(12.0,1.0,length(pos.xz-u_offset))*(1.0-blurRatio*0.85),2.0);v_uv=uv;v_blurRatio=blurRatio;}"
  , frag = "#define GLSLIFY 1\nuniform vec3 u_lightColor;uniform float u_time;varying vec2 v_uv;varying float v_blurRatio;varying float v_opacity;void main(){float d=max(0.0,1.0-length(v_uv-0.5)*2.0);float alpha=smoothstep(0.0,0.45+(1.0-v_blurRatio*v_blurRatio)*0.45,d)*0.5;gl_FragColor=vec4(u_lightColor,alpha*v_opacity);}"
  , Dusts = function() {
    function e() {
        _classCallCheck(this, e),
        _defineProperty(this, "container", new Object3D),
        _defineProperty(this, "mesh", void 0),
        _defineProperty(this, "offset", new Vector2),
        _defineProperty(this, "PARTICLE_COUNT", 512)
    }
    return _createClass(e, [{
        key: "preInit",
        value: function() {}
    }, {
        key: "init",
        value: function() {
            for (var e = new PlaneGeometry(1,1), t = new Float32Array(4 * this.PARTICLE_COUNT), r = new Float32Array(3 * this.PARTICLE_COUNT), i = 0, n = 0, a = 0; i < this.PARTICLE_COUNT; i++)
                r[n + 0] = 40 * (Math.random() - .5),
                r[n + 1] = 10 * Math.random(),
                r[n + 2] = 40 * (Math.random() - .5),
                t[a + 0] = Math.random(),
                t[a + 1] = Math.random(),
                t[a + 2] = Math.random(),
                t[a + 3] = Math.random(),
                n += 3,
                a += 4;
            var o = new InstancedBufferGeometry;
            for (var s in e.attributes)
                o.setAttribute(s, e.attributes[s]);
            o.setIndex(e.getIndex()),
            o.setAttribute("a_rands", new InstancedBufferAttribute(t,4)),
            o.setAttribute("a_position", new InstancedBufferAttribute(r,3));
            var l = new ShaderMaterial({
                uniforms: {
                    u_dustTexture: {
                        value: this.dustTexture
                    },
                    u_time: {
                        value: 0
                    },
                    u_opacity: {
                        value: 0
                    },
                    u_offset: {
                        value: this.offset
                    },
                    u_lightColor: {
                        value: lights.spotLight.color
                    },
                    u_cameraDistance: {
                        value: 0
                    }
                },
                vertexShader: vert,
                fragmentShader: frag,
                depthWrite: !1,
                transparent: !0,
                blending: CustomBlending,
                blendEquation: AddEquation,
                blendSrc: SrcAlphaFactor,
                blendDst: OneFactor,
                blendEquationAlpha: AddEquation,
                blendSrcAlpha: ZeroFactor,
                blendDstAlpha: OneFactor
            });
            this.mesh = new Mesh(o,l),
            this.mesh.frustumCulled = !1,
            this.container.add(this.mesh)
        }
    }, {
        key: "resize",
        value: function(e, t) {}
    }, {
        key: "update",
        value: function(e) {
            this.mesh && (this.mesh.material.uniforms.u_time.value += e,
            this.mesh.material.uniforms.u_opacity.value = 1,
            this.mesh.material.uniforms.u_cameraDistance.value = properties.cameraDistance)
        }
    }]),
    e
}()
  , dusts = new Dusts;
new Vector3;
var Visuals = function() {
    function e() {
        _classCallCheck(this, e),
        _defineProperty(this, "container", new Object3D),
        _defineProperty(this, "cameraOffsetPosition", new Vector3)
    }
    return _createClass(e, [{
        key: "preInit",
        value: function() {
            lights.preInit(),
            ground.preInit(),
            dusts.preInit(),
            monster.preInit(),
            this.container.add(lights.container),
            this.container.add(ground.container),
            this.container.add(dusts.container),
            this.container.add(monster.container)
        }
    }, {
        key: "init",
        value: function() {
            lights.init(),
            ground.init(),
            dusts.init(),
            monster.init()
        }
    }, {
        key: "resize",
        value: function(e, t) {
            lights.resize(e, t),
            ground.resize(e, t),
            dusts.resize(e, t),
            monster.resize(e, t)
        }
    }, {
        key: "update",
        value: function(e) {
            monster.bodyMesh.position.add(thirdControls.offset),
            lights.update(e),
            ground.update(e),
            dusts.update(e),
            monster.update(e),
            lights.container.position.x += .04 * (monster.bodyMesh.position.x - lights.container.position.x),
            lights.container.position.z += .04 * (monster.bodyMesh.position.z - lights.container.position.z),
            lights.spotLight.position.x = 2 * -(monster.bodyMesh.position.x - lights.container.position.x),
            lights.spotLight.position.z = 2 * -(monster.bodyMesh.position.z - lights.container.position.z),
            lights.spotLightTarget.position.x = 2 * (monster.bodyMesh.position.x - lights.container.position.x),
            lights.spotLightTarget.position.z = 2 * (monster.bodyMesh.position.z - lights.container.position.z),
            this.cameraOffsetPosition.x += .2 * (monster.bodyMesh.position.x - this.cameraOffsetPosition.x),
            this.cameraOffsetPosition.z += .2 * (monster.bodyMesh.position.z - this.cameraOffsetPosition.z),
            ground.container.position.x = monster.bodyMesh.position.x,
            ground.container.position.z = monster.bodyMesh.position.z,
            dusts.offset.x = monster.bodyMesh.position.x,
            dusts.offset.y = monster.bodyMesh.position.z,
            properties.camera.position.add(this.cameraOffsetPosition)
        }
    }]),
    e
}()
  , visuals = new Visuals
  , APP = function() {
    function e() {
        _classCallCheck(this, e),
        _defineProperty(this, "settings", settings),
        _defineProperty(this, "properties", properties)
    }
    return _createClass(e, [{
        key: "setCanvas",
        value: function(e) {
            return properties.canvas = e,
            properties._isSupported = support.isSupported(),
            properties._isSupported
        }
    }, {
        key: "preInit",
        value: function() {
            for (var e = 0, t = Object.entries(settings.CROSS_ORIGINS); e < t.length; e++) {
                var r = _slicedToArray(t[e], 2)
                  , i = r[0]
                  , n = r[1];
                properties.loader.setCrossOrigin(i, n)
            }
            properties.loader.register(BufItem),
            properties.loader.register(TextureItem),
            properties.loader.register(ThreeLoaderItem),
            settings.LOOK_DEV_MODE && gui.preInit(),
            this.preInitStage(),
            cameraControls.preInit(),
            input.preInit(),
            visuals.preInit()
        }
    }, {
        key: "preInitStage",
        value: function() {
            properties.width = window.innerWidth,
            properties.height = window.innerHeight,
            properties.renderer = new WebGLRenderer({
                canvas: properties.canvas,
                context: properties.gl
            }),
            properties.scene = new Scene,
            properties.camera = new PerspectiveCamera(50,1,.1,200),
            properties.scene.add(properties.camera),
            properties.renderer.shadowMap.enabled = !0,
            properties.renderer.shadowMap.type = PCFShadowMap,
            properties.sharedUniforms.u_resolution.value = properties.resolution = new Vector2,
            properties.sharedUniforms.u_bgColor.value = properties.bgColor = new Color,
            fboHelper.init(properties.renderer, settings.RENDER_TARGET_FLOAT_TYPE),
            textureHelper.init(),
            properties.postprocessing = new Postprocessing,
            properties.postprocessing.init({
                scene: properties.scene,
                camera: properties.camera
            }),
            blueNoise.preInit(),
            glPositionOffset.init(),
            screenPaint.init(),
            settings.USE_WEBGL2 || (properties.smaa = new Smaa,
            properties.smaa.init(),
            properties.smaa.setTextures(properties.loader.add(settings.TEXTURE_PATH + "smaa-area.png", {
                weight: 32
            }).content, properties.loader.add(settings.TEXTURE_PATH + "smaa-search.png", {
                weight: .1
            }).content),
            properties.postprocessing.queue.push(properties.smaa)),
            properties.bokeh = new Bokeh,
            properties.postprocessing.useDepthTexture && (properties.bokeh.init(),
            properties.bokeh.quality = browser.isMobile ? 0 : 1,
            properties.postprocessing.queue.push(properties.bokeh)),
            properties.bloom = new Bloom,
            properties.bloom.init(),
            properties.postprocessing.queue.push(properties.bloom),
            properties.screenPaintDistortion = new ScreenPaintDistortion,
            properties.screenPaintDistortion.init({
                screenPaint
            }),
            properties.postprocessing.queue.push(properties.screenPaintDistortion),
            properties.final = new Final,
            properties.final.init(),
            properties.postprocessing.queue.push(properties.final),
            settings.UP_SCALE > 1 && (properties.upscaler = new Fsr,
            properties.upscaler.init(),
            properties.postprocessing.queue.push(properties.upscaler)),
            properties.isStageReady = !0
        }
    }, {
        key: "init",
        value: function() {
            properties.smaa && properties.smaa.updateTextures(),
            settings.LOOK_DEV_MODE && gui.init(),
            cameraControls.init(),
            input.init(),
            visuals.init(),
            properties.scene.add(visuals.container),
            this.resize(properties.rawWidth, properties.rawHeight),
            properties.hasInitialized = !0,
            !1 === settings.IS_DEV && !0 !== settings.IS_API_MODE && console.log("%c Created by Lusion: https://lusion.co", "border:2px solid gray; padding:5px; font-family:monospace; font-size:11px;"),
            thirdControls.init()
        }
    }, {
        key: "start",
        value: function() {}
    }, {
        key: "resize",
        value: function(e, t) {
            var r = settings.UP_SCALE
              , i = e
              , n = t
              , a = e * settings.DPR
              , o = t * settings.DPR;
            if (!0 === settings.USE_PIXEL_LIMIT && a * o > settings.MAX_PIXEL_COUNT) {
                var s = a / o;
                o = Math.sqrt(settings.MAX_PIXEL_COUNT / s),
                a = Math.ceil(o * s),
                o = Math.ceil(o)
            }
            properties.rawWidth = i,
            properties.rawHeight = n,
            properties.width = Math.ceil(a / r),
            properties.height = Math.ceil(o / r),
            properties.resolution.set(properties.width, properties.height),
            properties.renderer.setSize(a, o),
            properties.canvas.style.width = "".concat(properties.rawWidth, "px"),
            properties.canvas.style.height = "".concat(properties.rawHeight, "px"),
            properties.camera.aspect = properties.width / properties.height,
            properties.camera.updateProjectionMatrix(),
            properties.postprocessing.setSize(properties.width, properties.height),
            screenPaint.resize(properties.width, properties.height),
            visuals.resize(properties.width, properties.height),
            thirdControls.resize(i, n)
        }
    }, {
        key: "render",
        value: function() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
            properties.time = properties.sharedUniforms.u_time.value += e,
            properties.deltaTime = properties.sharedUniforms.u_deltaTime.value = e,
            blueNoise.update(e),
            input.update(e),
            screenPaint.update(e),
            cameraControls.update(e),
            thirdControls.update(e),
            visuals.update(e),
            properties.renderer.setClearColor(properties.bgColor, 1),
            properties.bgColor.setStyle(properties.bgColorHex),
            properties.bloom.amount = properties.bloomAmount,
            properties.bloom.radius = properties.bloomRadius,
            properties.bloom.threshold = properties.bloomThreshold,
            properties.bloom.smoothWidth = properties.bloomSmoothWidth,
            properties.bloom.haloWidth = properties.haloWidth,
            properties.bloom.haloRGBShift = properties.haloRGBShift,
            properties.bloom.haloStrength = properties.haloStrength,
            properties.bloom.haloMaskInner = properties.haloMaskInner,
            properties.bloom.haloMaskOuter = properties.haloMaskOuter,
            properties.final.vignetteFrom = properties.vignetteFrom,
            properties.final.vignetteTo = properties.vignetteTo,
            properties.final.vignetteColor.setStyle(properties.vignetteColorHex),
            properties.final.saturation = properties.saturation,
            properties.final.contrast = properties.contrast,
            properties.final.brightness = properties.brightness,
            properties.final.tintColor.setStyle(properties.tintColorHex),
            properties.final.tintOpacity = properties.tintOpacity,
            properties.final.bgColor.setStyle(properties.bgColorHex),
            properties.final.opacity = properties.opacity,
            properties.bokeh.amount = properties.bokehAmount,
            properties.bokeh.fNumber = properties.bokehFNumber,
            properties.bokeh.focusDistance = properties.bokehFocusDistance,
            properties.bokeh.focalLength = properties.bokehFocalLength,
            properties.bokeh.kFilmHeight = properties.bokehKFilmHeight,
            screenPaint.needsMouseDown = properties.screenPaintNeedsMouseDown,
            screenPaint.minRadius = properties.screenPaintMinRadius,
            screenPaint.maxRadius = properties.screenPaintMaxRadius,
            screenPaint.radiusDistanceRange = properties.screenPaintRadiusDistanceRange,
            screenPaint.pushStrength = properties.screenPaintPushStrength,
            screenPaint.velocityDissipation = properties.screenPaintVelocityDissipation,
            screenPaint.weight1Dissipation = properties.screenPaintWeight1Dissipation,
            screenPaint.weight2Dissipation = properties.screenPaintWeight2Dissipation,
            screenPaint.useNoise = properties.screenPaintUseNoise,
            screenPaint.curlScale = properties.screenPaintCurlScale,
            screenPaint.curlStrength = properties.screenPaintCurlStrength,
            properties.screenPaintDistortion.amount = properties.screenPaintDistortionAmount,
            properties.screenPaintDistortion.rgbShift = properties.screenPaintDistortionRGBShift,
            properties.screenPaintDistortion.multiplier = properties.screenPaintDistortionMultiplier,
            properties.upscaler && (properties.upscaler.sharpness = properties.upscalerSharpness),
            properties.postprocessing.render(properties.scene, properties.camera, !0),
            window.__debugTexture && fboHelper.debugTo(window.__debugTexture),
            input.postUpdate(e)
        }
    }]),
    e
}()
  , Component = function() {
    function e() {
        _classCallCheck(this, e),
        _defineProperty(this, "isActive", !1),
        _defineProperty(this, "activeRatio", 0),
        _defineProperty(this, "activeTime", 0),
        _defineProperty(this, "pageIndex", null),
        _defineProperty(this, "dom", {
            container: null
        }),
        _defineProperty(this, "addDefaultListeners", !1),
        _defineProperty(this, "isHovered", !1),
        _defineProperty(this, "isDowned", !1),
        _defineProperty(this, "hoverRatio", 0),
        _defineProperty(this, "downRatio", 0)
    }
    return _createClass(e, [{
        key: "prePreInit",
        value: function() {}
    }, {
        key: "preInit",
        value: function(e) {
            Object.assign(this, e),
            !0 === this.addDefaultListeners && (this.addOnClickElement(this.dom.container),
            this.addOnHoverElement(this.dom.container))
        }
    }, {
        key: "init",
        value: function() {}
    }, {
        key: "show",
        value: function() {
            this.isActive = !0
        }
    }, {
        key: "hide",
        value: function() {
            this.isActive = !1
        }
    }, {
        key: "resize",
        value: function(e, t) {}
    }, {
        key: "update",
        value: function(e) {
            this.activeRatio = math.saturate(this.activeRatio + (!0 === this.isActive ? 1 : -1) * (1 * e)),
            this.hoverRatio = math.saturate(this.hoverRatio + (!0 === this.isHovered ? 1 : -1) * (1 * e)),
            this.downRatio = math.saturate(this.downRatio + (!0 === this.isDowned ? 1 : -1) * (1 * e));
            var t = this.activeRatio > 0;
            this.activeTime = Math.max(0, t ? this.activeTime + e : 0),
            null !== this.dom.container && (this.dom.container.classList.toggle("is-active", t),
            this.dom.container.style.opacity = this.activeRatio),
            this.activeRatio
        }
    }, {
        key: "onClick",
        value: function() {}
    }, {
        key: "onRollover",
        value: function() {}
    }, {
        key: "onRollout",
        value: function() {}
    }, {
        key: "addOnClickElement",
        value: function(e) {
            e instanceof HTMLElement != 0 && input.onDowned.add(this._onInputDown.bind(this, e))
        }
    }, {
        key: "addOnHoverElement",
        value: function(e) {
            e instanceof HTMLElement != 0 && input.onMoved.add(this._onInputMove.bind(this, e))
        }
    }, {
        key: "_onInputDown",
        value: function(e) {
            input.hasThroughElem(e, "down") && (this.isDowned = !0,
            this.onClick())
        }
    }, {
        key: "_onInputMove",
        value: function(e) {
            browser.isMobile || (!0 === input.hasThroughElem(e, "move") ? this._onRollover() : this._onRollout())
        }
    }, {
        key: "_onRollover",
        value: function() {
            this.isHovered = !0,
            !0 !== this._hasRolloverTriggered && (this._hasRolloverTriggered = !0,
            this._hasRolloutTriggered = !1,
            this.onRollover())
        }
    }, {
        key: "_onRollout",
        value: function() {
            this.isHovered = !1,
            !0 !== this._hasRolloutTriggered && (this._hasRolloutTriggered = !0,
            this._hasRolloverTriggered = !1,
            this.onRollout())
        }
    }]),
    e
}()
  , Cursor = function(e) {
    _inherits(r, Component);
    var t = _createSuper(r);
    function r() {
        var e;
        _classCallCheck(this, r);
        for (var i = arguments.length, n = new Array(i), a = 0; a < i; a++)
            n[a] = arguments[a];
        return _defineProperty(_assertThisInitialized(e = t.call.apply(t, [this].concat(n))), "addDefaultListeners", !1),
        _defineProperty(_assertThisInitialized(e), "easePosX", 0),
        _defineProperty(_assertThisInitialized(e), "easePosY", 0),
        _defineProperty(_assertThisInitialized(e), "velocityX", 0),
        _defineProperty(_assertThisInitialized(e), "velocityY", 0),
        _defineProperty(_assertThisInitialized(e), "currHoveredElement", null),
        e
    }
    return _createClass(r, [{
        key: "prePreInit",
        value: function() {
            var e = this;
            _get(_getPrototypeOf(r.prototype), "prePreInit", this).call(this),
            this.dom.container = document.querySelector(".cursor"),
            this.dom.cursorInner = document.querySelector(".cursor-inner"),
            !0 !== browser.isMobile ? (document.addEventListener("pointerenter", (function(t) {
                return e.show()
            }
            )),
            document.addEventListener("pointerleave", (function(t) {
                return e.hide()
            }
            )),
            document.addEventListener("pointermove", (function(t) {
                return e.show()
            }
            ))) : this.hide()
        }
    }, {
        key: "preInit",
        value: function(e) {
            var t = this;
            _get(_getPrototypeOf(r.prototype), "preInit", this).call(this, e),
            _construct(Array, _toConsumableArray(new Set(new Array(Array.from(document.querySelectorAll(".btn")),document.querySelector(".credits-logo"),document.querySelector(".loading-logo"),document.querySelector(".logo")).flat()))).filter((function(e) {
                return null != e
            }
            )).forEach((function(e) {
                e instanceof HTMLElement && !0 !== e.classList.contains("cfx") && e.classList.add("cfx")
            }
            )),
            input.onMoved.add((function() {
                input.hasThroughElem("cfx", "move") ? t._onRollover() : t._onRollout()
            }
            ))
        }
    }, {
        key: "init",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "init", this).call(this)
        }
    }, {
        key: "show",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "show", this).call(this)
        }
    }, {
        key: "hide",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "hide", this).call(this)
        }
    }, {
        key: "resize",
        value: function(e, t) {
            _get(_getPrototypeOf(r.prototype), "resize", this).call(this, e, t),
            this.easePosX = e / 2,
            this.easePosY = t / 2
        }
    }, {
        key: "update",
        value: function(e) {
            if (_get(_getPrototypeOf(r.prototype), "update", this).call(this, e),
            !0 !== browser.isMobile) {
                var t, i, n;
                this.currHoveredElement = input.hasThroughElem("cfx", "move"),
                this.isHovered = this.currHoveredElement;
                var a = (.5 * input.mouseXY.x + .5) * properties.rawWidth
                  , o = (.5 - .5 * input.mouseXY.y) * properties.rawHeight;
                this.easePosX += .2 * (a - this.easePosX),
                this.easePosY += .2 * (o - this.easePosY),
                this.velocityX += (a - this.easePosX) * e * 100,
                this.velocityY += (o - this.easePosY) * e * 100,
                this.velocityX *= .9,
                this.velocityY *= .9,
                this.easePosX += this.velocityX * e,
                this.easePosY += this.velocityY * e,
                t = math.saturate(math.fit(1 - this.hoverRatio, 0, 1, .75, 1, ease.sineInOut)),
                n = "scale3d(".concat(t, ", ").concat(t, ", 1)"),
                i = "translate3d(calc(".concat(this.easePosX, "px - 50%), calc(").concat(this.easePosY, "px - 50%), 0)"),
                this.dom.container && (this.dom.container.style.opacity = this.activeRatio),
                this.dom.cursorInner && (this.dom.cursorInner.style.transform = i + n,
                this.dom.cursorInner.style.opacity = this.activeRatio)
            }
        }
    }]),
    r
}()
  , cursor = new Cursor
  , CreditsLogo = function(e) {
    _inherits(r, Component);
    var t = _createSuper(r);
    function r() {
        var e;
        _classCallCheck(this, r);
        for (var i = arguments.length, n = new Array(i), a = 0; a < i; a++)
            n[a] = arguments[a];
        return _defineProperty(_assertThisInitialized(e = t.call.apply(t, [this].concat(n))), "addDefaultListeners", !0),
        e
    }
    return _createClass(r, [{
        key: "prePreInit",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "prePreInit", this).call(this),
            this.dom.container = document.querySelector(".logo"),
            this.dom.logoSvg = this.dom.container.querySelector("svg"),
            this.dom.logoSvgPathList = Array.from(this.dom.logoSvg.querySelectorAll("path")),
            this.dom.logoSvgPathList.forEach((function(e) {
                e.setAttribute("stroke", "#DC1A31"),
                e.setAttribute("stroke-width", "1"),
                e.setAttribute("stroke-linecap", "round"),
                e.setAttribute("stroke-linejoin", "round"),
                e.setAttribute("fill", "none")
            }
            ))
        }
    }, {
        key: "preInit",
        value: function(e) {
            _get(_getPrototypeOf(r.prototype), "preInit", this).call(this, e)
        }
    }, {
        key: "init",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "init", this).call(this)
        }
    }, {
        key: "show",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "show", this).call(this)
        }
    }, {
        key: "hide",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "hide", this).call(this)
        }
    }, {
        key: "resize",
        value: function(e, t) {
            _get(_getPrototypeOf(r.prototype), "resize", this).call(this, e, t)
        }
    }, {
        key: "update",
        value: function(e) {
            _get(_getPrototypeOf(r.prototype), "update", this).call(this, e);
            for (var t = 0; t < this.dom.logoSvgPathList.length; t++) {
                var i = this.dom.logoSvgPathList[t]
                  , n = math.saturate(math.mix(1, .25, this.hoverRatio) + (Math.random() < .01 ? Math.random() : 1))
                  , a = math.mix(this.activeRatio, n, this.hoverRatio);
                i.style.opacity = a
            }
        }
    }, {
        key: "onClick",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "onClick", this).call(this),
            properties.onPageChanged.dispatch(1)
        }
    }, {
        key: "onRollover",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "onRollover", this).call(this)
        }
    }, {
        key: "onRollout",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "onRollout", this).call(this)
        }
    }]),
    r
}()
  , logo = new CreditsLogo
  , LoadingLogo = function(e) {
    _inherits(r, Component);
    var t = _createSuper(r);
    function r() {
        var e;
        _classCallCheck(this, r);
        for (var i = arguments.length, n = new Array(i), a = 0; a < i; a++)
            n[a] = arguments[a];
        return _defineProperty(_assertThisInitialized(e = t.call.apply(t, [this].concat(n))), "addDefaultListeners", !0),
        _defineProperty(_assertThisInitialized(e), "preloaderAnimationRatio", 0),
        e
    }
    return _createClass(r, [{
        key: "prePreInit",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "prePreInit", this).call(this),
            this.dom.container = document.querySelector(".loading-logo"),
            this.dom.logoSvg = this.dom.container.querySelector("svg"),
            this.dom.logoSvgPathList = Array.from(this.dom.logoSvg.querySelectorAll("path")),
            this.dom.logoSvgPathList.forEach((function(e) {
                e.setAttribute("stroke", "#DC1A31"),
                e.setAttribute("stroke-width", "2.5"),
                e.setAttribute("stroke-linecap", "round"),
                e.setAttribute("stroke-linejoin", "round"),
                e.setAttribute("fill", "none")
            }
            ))
        }
    }, {
        key: "preInit",
        value: function(e) {
            _get(_getPrototypeOf(r.prototype), "preInit", this).call(this, e)
        }
    }, {
        key: "init",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "init", this).call(this)
        }
    }, {
        key: "show",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "show", this).call(this)
        }
    }, {
        key: "hide",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "hide", this).call(this)
        }
    }, {
        key: "resize",
        value: function(e, t) {
            _get(_getPrototypeOf(r.prototype), "resize", this).call(this, e, t)
        }
    }, {
        key: "update",
        value: function(e) {
            _get(_getPrototypeOf(r.prototype), "update", this).call(this, e);
            for (var t = 0; t < this.dom.logoSvgPathList.length; t++) {
                var i = this.dom.logoSvgPathList[t];
                !0 !== properties.isPreloaderFinished ? i.style.opacity = ease.quintOut(math.saturate(2 * ease.cubicOut(this.preloaderAnimationRatio) - Math.random())) : i.style.opacity = Math.random() < .02 ? math.saturate(1 * this.preloaderAnimationRatio - Math.random()) * ease.cubicOut(this.preloaderAnimationRatio) : this.preloaderAnimationRatio
            }
        }
    }, {
        key: "onClick",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "onClick", this).call(this),
            properties.onPageChanged.dispatch(1)
        }
    }, {
        key: "onRollover",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "onRollover", this).call(this)
        }
    }, {
        key: "onRollout",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "onRollout", this).call(this)
        }
    }]),
    r
}()
  , loadingLogo = new LoadingLogo
  , OverlayLoading = function(e) {
    _inherits(r, Component);
    var t = _createSuper(r);
    function r() {
        var e;
        _classCallCheck(this, r);
        for (var i = arguments.length, n = new Array(i), a = 0; a < i; a++)
            n[a] = arguments[a];
        return _defineProperty(_assertThisInitialized(e = t.call.apply(t, [this].concat(n))), "subComponents", [loadingLogo]),
        _defineProperty(_assertThisInitialized(e), "percentTarget", 0),
        _defineProperty(_assertThisInitialized(e), "forceMinPreloaderDuration", 3.5),
        _defineProperty(_assertThisInitialized(e), "afterPreloaderHoldDuration", 2),
        _defineProperty(_assertThisInitialized(e), "afterPreloaderRatio", 0),
        _defineProperty(_assertThisInitialized(e), "preloaderAnimationRatio", 0),
        _defineProperty(_assertThisInitialized(e), "activeTime", 0),
        e
    }
    return _createClass(r, [{
        key: "prePreInit",
        value: function(e) {
            _get(_getPrototypeOf(r.prototype), "prePreInit", this).call(this),
            this.dom.container = document.querySelector(".overlay-loading"),
            this.dom.background = this.dom.container.querySelector(".overlay-background"),
            this.dom.loadingBar = this.dom.container.querySelector(".loading-bar"),
            this.dom.loadingBarInner = this.dom.container.querySelector(".loading-bar--progress"),
            properties.loader.add(settings.IMAGE_PATH + "logo_2.png"),
            properties.loader.start((function(t) {
                1 === t && e()
            }
            )),
            this.subComponents.forEach((function(e) {
                return e.prePreInit()
            }
            ))
        }
    }, {
        key: "preInit",
        value: function(e) {
            _get(_getPrototypeOf(r.prototype), "preInit", this).call(this, e),
            this.subComponents.forEach((function(e) {
                return e.preInit()
            }
            ))
        }
    }, {
        key: "init",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "init", this).call(this),
            this.subComponents.forEach((function(e) {
                return e.init()
            }
            ))
        }
    }, {
        key: "show",
        value: function() {
            settings.SKIP_ANIMATION || (_get(_getPrototypeOf(r.prototype), "show", this).call(this),
            this.subComponents.forEach((function(e) {
                return e.show()
            }
            )))
        }
    }, {
        key: "hide",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "hide", this).call(this),
            this.subComponents.forEach((function(e) {
                return e.hide()
            }
            ))
        }
    }, {
        key: "resize",
        value: function(e, t) {
            _get(_getPrototypeOf(r.prototype), "resize", this).call(this, e, t),
            this.subComponents.forEach((function(r) {
                return r.resize(e, t)
            }
            ))
        }
    }, {
        key: "update",
        value: function(e) {
            var t;
            if (_get(_getPrototypeOf(r.prototype), "update", this).call(this, e),
            this.subComponents.forEach((function(t) {
                return t.update(e)
            }
            )),
            properties.isPreloaderFinished = 1 === properties.easedPercent,
            this.percentTarget = null !== (t = properties.percent) && void 0 !== t ? t : 0,
            this.activeTime += e,
            !0 === settings.SKIP_ANIMATION ? (properties.easedPercent = properties.percent,
            properties.isPreloaderWaitFinished = !0) : properties.easedPercent = math.saturate(Math.min(this.percentTarget, math.saturate(properties.easedPercent + e * (1 / this.forceMinPreloaderDuration) * (this.percentTarget > properties.easedPercent ? 1 : 0)))),
            !1 === properties.isPreloaderFinished)
                this.activeTime = 0,
                this.preloaderAnimationRatio = properties.easedPercent,
                loadingLogo.preloaderAnimationRatio = properties.easedPercent,
                this.dom.loadingBar.style.opacity = properties.easedPercent,
                this.dom.loadingBarInner.style.transform = "scale3d(".concat(properties.easedPercent.toFixed(4), ", 1, 1)"),
                this.dom.loadingBarInner.style.transformOrigin = "left center",
                this.dom.container.style.opacity = ease.quintOut(math.saturate(3.5 * ease.quintOut(properties.easedPercent) - Math.random())),
                properties.canvas.style.display = "none";
            else {
                if (loadingLogo.preloaderAnimationRatio = this.activeRatio,
                properties.canvas.style.display = "block",
                !0 === settings.SKIP_ANIMATION)
                    return;
                if (math.clamp(this.activeTime, 0, this.afterPreloaderHoldDuration) === this.afterPreloaderHoldDuration) {
                    this.afterPreloaderRatio = math.saturate(this.afterPreloaderRatio + e / 2);
                    var i = math.fit(this.afterPreloaderRatio, 0, .5, 0, 1);
                    math.fit(this.afterPreloaderRatio, .5, 1, 0, 1),
                    this.preloaderAnimationRatio = 1 - this.afterPreloaderRatio,
                    this.dom.background.style.opacity = 1 - i,
                    this.dom.loadingBar.style.opacity = this.preloaderAnimationRatio,
                    this.dom.loadingBarInner.style.transform = "scale3d(".concat(1 - i.toFixed(4), ", 1, 1)"),
                    this.dom.loadingBarInner.style.transformOrigin = "right center",
                    1 === this.afterPreloaderRatio && (properties.isPreloaderWaitFinished = !0)
                }
            }
        }
    }]),
    r
}()
  , loading = new OverlayLoading
  , CreditsBtnClose = function(e) {
    _inherits(r, Component);
    var t = _createSuper(r);
    function r() {
        var e;
        _classCallCheck(this, r);
        for (var i = arguments.length, n = new Array(i), a = 0; a < i; a++)
            n[a] = arguments[a];
        return _defineProperty(_assertThisInitialized(e = t.call.apply(t, [this].concat(n))), "addDefaultListeners", !0),
        e
    }
    return _createClass(r, [{
        key: "prePreInit",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "prePreInit", this).call(this),
            this.dom.container = document.querySelector(".btn-close")
        }
    }, {
        key: "update",
        value: function(e) {
            _get(_getPrototypeOf(r.prototype), "update", this).call(this, e),
            this.dom.container.style.opacity = math.saturate(this.activeTime * ease.quintInOut(this.activeRatio) * 2 - Math.random())
        }
    }, {
        key: "onClick",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "onClick", this).call(this),
            properties.onPageChanged.dispatch(1)
        }
    }, {
        key: "onRollover",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "onRollover", this).call(this)
        }
    }, {
        key: "onRollout",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "onRollout", this).call(this)
        }
    }]),
    r
}()
  , creditsBtnClose = new CreditsBtnClose
  , OverlayCredits = function(e) {
    _inherits(r, Component);
    var t = _createSuper(r);
    function r() {
        var e;
        _classCallCheck(this, r);
        for (var i = arguments.length, n = new Array(i), a = 0; a < i; a++)
            n[a] = arguments[a];
        return _defineProperty(_assertThisInitialized(e = t.call.apply(t, [this].concat(n))), "subComponents", [creditsBtnClose]),
        _defineProperty(_assertThisInitialized(e), "isBboxSet", !1),
        _defineProperty(_assertThisInitialized(e), "bbox", {
            top: 0,
            bottom: 0,
            left: 0,
            right: 0,
            height: 0,
            width: 0
        }),
        _defineProperty(_assertThisInitialized(e), "scroll", {}),
        e
    }
    return _createClass(r, [{
        key: "prePreInit",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "prePreInit", this).call(this),
            this.dom.container = document.querySelector(".overlay-credits"),
            this.dom.content = this.dom.container.querySelector(".overlay-content"),
            this.dom.creditsTitle = this.dom.container.querySelector(".credits-title"),
            this.dom.sectionsList = Array.from(this.dom.container.querySelectorAll(".credits-section")),
            this.dom.sectionsList.unshift(this.dom.creditsTitle),
            this.subComponents.forEach((function(e) {
                return e.prePreInit()
            }
            ))
        }
    }, {
        key: "preInit",
        value: function(e) {
            _get(_getPrototypeOf(r.prototype), "preInit", this).call(this, e),
            this.subComponents.forEach((function(e) {
                return e.preInit()
            }
            )),
            this._setupScroller()
        }
    }, {
        key: "init",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "init", this).call(this),
            this.subComponents.forEach((function(e) {
                return e.init()
            }
            ))
        }
    }, {
        key: "show",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "show", this).call(this),
            this.subComponents.forEach((function(e) {
                return e.show()
            }
            )),
            this.isBboxSet = !1,
            this.scroll.current = 0,
            this.scroll.target = 0
        }
    }, {
        key: "hide",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "hide", this).call(this),
            this.subComponents.forEach((function(e) {
                return e.hide()
            }
            )),
            this.isBboxSet = !1
        }
    }, {
        key: "resize",
        value: function(e, t) {
            _get(_getPrototypeOf(r.prototype), "resize", this).call(this, e, t),
            this.subComponents.forEach((function(e) {
                return e.hide()
            }
            )),
            this.isBboxSet = !1
        }
    }, {
        key: "update",
        value: function(e) {
            _get(_getPrototypeOf(r.prototype), "update", this).call(this, e),
            this.subComponents.forEach((function(t) {
                return t.update(e)
            }
            ));
            for (var t = this.dom.sectionsList.length, i = 0; i < t; i++) {
                var n = this.dom.sectionsList[i]
                  , a = i / t
                  , o = Math.min(1, a + 1 / t * 1.5)
                  , s = math.fit(this.activeRatio, a, o, 0, 1);
                n.style.opacity = s,
                browser.isMobile || (n.style.filter = "blur(".concat(5 * (1 - s), "px)"))
            }
            1 === this.activeRatio && this._updateBoundingBox(),
            this.scroll.current < .1 && (this.scroll.current = 0),
            this.scroll.current = Number((math.lerp(this.scroll.current, this.scroll.target, this.scroll.lerp) * this.activeRatio).toFixed(5)),
            this.dom.content.style.transform = "translate3d(0, ".concat(-this.scroll.current, "px, 0)"),
            this.dom.content.style.opacity = this.focusRatio * this.activeRatio
        }
    }, {
        key: "_updateBoundingBox",
        value: function() {
            if (!1 === this.isBboxSet) {
                var e = this.dom.container.getBoundingClientRect();
                this.bbox.top = e.top,
                this.bbox.bottom = e.bottom,
                this.bbox.left = e.left,
                this.bbox.right = e.right,
                this.bbox.height = e.height,
                this.bbox.width = e.width,
                this.scroll.limit = this.bbox.height - properties.rawHeight,
                this.bbox.width > 0 && this.bbox.height > 0 && (this.isBboxSet = !0)
            }
        }
    }, {
        key: "_setupScroller",
        value: function() {
            var e = this;
            this.scroll = {
                current: 0,
                target: 0,
                lerp: .1,
                limit: 0,
                offset: 0
            },
            input.onWheeled.add((function(t, r, i) {
                var n = i.pixelY;
                e.scroll.target += n,
                e.scroll.target = math.clamp(e.scroll.target, 0, e.scroll.limit)
            }
            ))
        }
    }]),
    r
}()
  , credits = new OverlayCredits
  , ControlsBtnAudio = function(e) {
    _inherits(r, Component);
    var t = _createSuper(r);
    function r() {
        var e;
        _classCallCheck(this, r);
        for (var i = arguments.length, n = new Array(i), a = 0; a < i; a++)
            n[a] = arguments[a];
        return _defineProperty(_assertThisInitialized(e = t.call.apply(t, [this].concat(n))), "addDefaultListeners", !0),
        e
    }
    return _createClass(r, [{
        key: "prePreInit",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "prePreInit", this).call(this),
            this.dom.container = document.querySelector(".btn-audio")
        }
    }, {
        key: "update",
        value: function(e) {
            _get(_getPrototypeOf(r.prototype), "update", this).call(this, e),
            this.dom.container.style.opacity = math.mix(.5, 1, this.activeRatio * properties.audioActiveRatio),
            this.dom.container.classList.toggle("is-playing", properties.isAudioActive)
        }
    }, {
        key: "onClick",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "onClick", this).call(this),
            properties.onToggleAudio.dispatch(!properties.isAudioActive)
        }
    }, {
        key: "onRollover",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "onRollover", this).call(this)
        }
    }, {
        key: "onRollout",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "onRollout", this).call(this)
        }
    }]),
    r
}()
  , controlsBtnAudio = new ControlsBtnAudio
  , ControlsBtnCredits = function(e) {
    _inherits(r, Component);
    var t = _createSuper(r);
    function r() {
        var e;
        _classCallCheck(this, r);
        for (var i = arguments.length, n = new Array(i), a = 0; a < i; a++)
            n[a] = arguments[a];
        return _defineProperty(_assertThisInitialized(e = t.call.apply(t, [this].concat(n))), "addDefaultListeners", !0),
        e
    }
    return _createClass(r, [{
        key: "prePreInit",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "prePreInit", this).call(this),
            this.dom.container = document.querySelector(".btn-credits")
        }
    }, {
        key: "update",
        value: function(e) {
            _get(_getPrototypeOf(r.prototype), "update", this).call(this, e),
            this.dom.container.style.opacity = math.saturate(this.activeTime * ease.quintIn(this.activeRatio) * 2 - Math.random())
        }
    }, {
        key: "onClick",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "onClick", this).call(this),
            properties.onPageChanged.dispatch(2)
        }
    }, {
        key: "onRollover",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "onRollover", this).call(this)
        }
    }, {
        key: "onRollout",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "onRollout", this).call(this)
        }
    }]),
    r
}()
  , controlsBtnCredits = new ControlsBtnCredits
  , ControlsBtnDial = function(e) {
    _inherits(r, Component);
    var t = _createSuper(r);
    function r() {
        var e;
        _classCallCheck(this, r);
        for (var i = arguments.length, n = new Array(i), a = 0; a < i; a++)
            n[a] = arguments[a];
        return _defineProperty(_assertThisInitialized(e = t.call.apply(t, [this].concat(n))), "addDefaultListeners", !0),
        e
    }
    return _createClass(r, [{
        key: "prePreInit",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "prePreInit", this).call(this),
            this.dom.container = document.querySelector(".btn-dial")
        }
    }, {
        key: "update",
        value: function(e) {
            _get(_getPrototypeOf(r.prototype), "update", this).call(this, e),
            this.dom.container.style.opacity = math.saturate(this.activeTime * ease.quintIn(this.activeRatio) * 2 - Math.random())
        }
    }, {
        key: "onClick",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "onClick", this).call(this)
        }
    }, {
        key: "onRollover",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "onRollover", this).call(this)
        }
    }, {
        key: "onRollout",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "onRollout", this).call(this)
        }
    }]),
    r
}()
  , controlsBtnDial = new ControlsBtnDial
  , ControlsBtnKeyboard = function(e) {
    _inherits(r, Component);
    var t = _createSuper(r);
    function r() {
        var e;
        _classCallCheck(this, r);
        for (var i = arguments.length, n = new Array(i), a = 0; a < i; a++)
            n[a] = arguments[a];
        return _defineProperty(_assertThisInitialized(e = t.call.apply(t, [this].concat(n))), "addDefaultListeners", !0),
        e
    }
    return _createClass(r, [{
        key: "prePreInit",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "prePreInit", this).call(this),
            this.dom.container = document.querySelector(".btn-keyboard")
        }
    }, {
        key: "update",
        value: function(e) {
            _get(_getPrototypeOf(r.prototype), "update", this).call(this, e)
        }
    }, {
        key: "onClick",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "onClick", this).call(this)
        }
    }, {
        key: "onRollover",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "onRollover", this).call(this)
        }
    }, {
        key: "onRollout",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "onRollout", this).call(this)
        }
    }]),
    r
}()
  , controlsBtnKeyboard = new ControlsBtnKeyboard
  , OverlayControls = function(e) {
    _inherits(r, Component);
    var t = _createSuper(r);
    function r() {
        var e;
        _classCallCheck(this, r);
        for (var i = arguments.length, n = new Array(i), a = 0; a < i; a++)
            n[a] = arguments[a];
        return _defineProperty(_assertThisInitialized(e = t.call.apply(t, [this].concat(n))), "subComponents", [controlsBtnAudio, controlsBtnCredits, controlsBtnDial, controlsBtnKeyboard]),
        e
    }
    return _createClass(r, [{
        key: "prePreInit",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "prePreInit", this).call(this),
            this.dom.container = document.querySelector(".overlay-controls"),
            this.subComponents.forEach((function(e) {
                return e.prePreInit()
            }
            ))
        }
    }, {
        key: "preInit",
        value: function(e) {
            _get(_getPrototypeOf(r.prototype), "preInit", this).call(this, e),
            this.subComponents.forEach((function(e) {
                return e.preInit()
            }
            ))
        }
    }, {
        key: "init",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "init", this).call(this),
            this.subComponents.forEach((function(e) {
                return e.init()
            }
            ))
        }
    }, {
        key: "show",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "show", this).call(this),
            controlsBtnAudio.show(),
            controlsBtnCredits.show(),
            browser.isMobile ? controlsBtnDial.show() : controlsBtnKeyboard.show()
        }
    }, {
        key: "hide",
        value: function() {
            _get(_getPrototypeOf(r.prototype), "hide", this).call(this),
            this.subComponents.forEach((function(e) {
                return e.hide()
            }
            ))
        }
    }, {
        key: "resize",
        value: function(e, t) {
            _get(_getPrototypeOf(r.prototype), "resize", this).call(this, e, t),
            this.subComponents.forEach((function(r) {
                return r.resize(e, t)
            }
            ))
        }
    }, {
        key: "update",
        value: function(e) {
            _get(_getPrototypeOf(r.prototype), "update", this).call(this, e),
            this.subComponents.forEach((function(t) {
                return t.update(e)
            }
            ))
        }
    }]),
    r
}()
  , controls = new OverlayControls
  , UI = function() {
    function e() {
        _classCallCheck(this, e),
        _defineProperty(this, "afterLoadingTimeout", null),
        _defineProperty(this, "dom", {}),
        _defineProperty(this, "afterPreloaderTimeout", null)
    }
    return _createClass(e, [{
        key: "prePreInit",
        value: function(e) {
            var t = this;
            loading.prePreInit(e),
            controls.prePreInit(),
            credits.prePreInit(),
            cursor.prePreInit(),
            logo.prePreInit(),
            window.addEventListener("contextmenu", (function(e) {
                return e.preventDefault()
            }
            )),
            properties.onPageChanged.add((function(e) {
                0 === e ? (loading.show(),
                controls.hide(),
                credits.hide()) : 1 === e ? (null !== t.afterPreloaderTimeout ? window.clearTimeout(t.afterPreloaderTimeout) : t.afterPreloaderTimeout = window.setTimeout((function() {
                    loading.hide(),
                    logo.show()
                }
                ), 2e3),
                controls.show(),
                credits.hide()) : 2 === e && (loading.hide(),
                controls.hide(),
                credits.show())
            }
            ))
        }
    }, {
        key: "preInit",
        value: function() {
            audios.preInit(),
            loading.preInit(),
            controls.preInit(),
            credits.preInit(),
            cursor.preInit(),
            logo.preInit(),
            properties.onPageChanged.dispatch(0)
        }
    }, {
        key: "init",
        value: function() {
            audios.init(),
            loading.init(),
            controls.init(),
            credits.init(),
            cursor.init(),
            logo.init(),
            document.documentElement.classList.add("is-".concat(browser.device)),
            document.documentElement.classList.add("is-ready")
        }
    }, {
        key: "start",
        value: function() {
            properties.onPageChanged.dispatch(1)
        }
    }, {
        key: "resize",
        value: function(e, t) {
            loading.resize(e, t),
            controls.resize(e, t),
            credits.resize(e, t),
            cursor.resize(e, t),
            logo.resize(e, t),
            document.documentElement.style.setProperty("--vh", .01 * properties.rawHeight + "px")
        }
    }, {
        key: "render",
        value: function(e) {
            audios.update(e),
            loading.update(e),
            controls.update(e),
            credits.update(e),
            cursor.update(e),
            logo.update(e)
        }
    }]),
    e
}();
window[settings.GLOBAL_ID] = new APP;
var MAIN_APP = window[settings.GLOBAL_ID]
  , MAIN_UI = new UI
  , canvas = null !== (_document$getElementB = document.getElementById("canvas")) && void 0 !== _document$getElementB ? _document$getElementB : null
  , dateTime = performance.now()
  , isSupportedWebGL = MAIN_APP.setCanvas(canvas);
if (isSupportedWebGL) {
    var preInit = function() {
        MAIN_UI.preInit(),
        MAIN_APP.preInit(),
        properties.loader.start((function(e) {
            properties.percent = e,
            1 === properties.percent && init()
        }
        ))
    }
      , init = function() {
        MAIN_APP.init(),
        MAIN_UI.init()
    }
      , onResize = function() {
        var e = window.innerWidth
          , t = window.innerHeight;
        MAIN_APP.resize(e, t),
        MAIN_UI.resize(e, t)
    }
      , _start12 = function() {
        properties.hasStarted = !0,
        MAIN_APP.start(),
        MAIN_UI.start(),
        onResize()
    }
      , loop = function e() {
        window.requestAnimationFrame(e);
        var t = performance.now()
          , r = (t - dateTime) / 1e3;
        dateTime = t,
        r = Math.min(r, .05),
        1 !== properties.easedPercent || properties.hasStarted || !0 !== properties.isPreloaderWaitFinished || _start12(),
        properties.hasStarted && (properties.startRatio = settings.SKIP_ANIMATION ? 1 : math.saturate(properties.startRatio + r / 5)),
        MAIN_APP.render(r),
        MAIN_UI.render(r)
    };
    MAIN_APP.settings.override({
        CROSS_ORIGINS: {
            "https://my_cdn/": "anonymous"
        }
    }),
    MAIN_UI.prePreInit((function() {
        preInit(),
        window.addEventListener("resize", onResize),
        onResize(),
        loop()
    }
    ))
}
